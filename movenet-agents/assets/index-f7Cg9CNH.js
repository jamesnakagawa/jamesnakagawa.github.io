function Em(n,e){for(var t=0;t<e.length;t++){const r=e[t];if(typeof r!="string"&&!Array.isArray(r)){for(const s in r)if(s!=="default"&&!(s in n)){const o=Object.getOwnPropertyDescriptor(r,s);o&&Object.defineProperty(n,s,o.get?o:{enumerable:!0,get:()=>r[s]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&r(i)}).observe(document,{childList:!0,subtree:!0});function t(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function r(s){if(s.ep)return;s.ep=!0;const o=t(s);fetch(s.href,o)}})();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _m=1e-7,Am=1e-4;class Rm{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Hl{refCount(e){return ct("refCount")}incRef(e){return ct("incRef")}timerAvailable(){return!0}time(e){return ct("time")}read(e){return ct("read")}readSync(e){return ct("readSync")}readToGPU(e,t){return ct("readToGPU")}numDataIds(){return ct("numDataIds")}disposeData(e,t){return ct("disposeData")}write(e,t,r){return ct("write")}move(e,t,r,s,o){return ct("move")}createTensorFromGPUData(e,t,r){return ct("createTensorFromGPUData")}memory(){return ct("memory")}floatPrecision(){return ct("floatPrecision")}epsilon(){return this.floatPrecision()===32?_m:Am}dispose(){return ct("dispose")}}function ct(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mr(n,e,t){const r=n[e];n[e]=n[t],n[t]=r}function Dm(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function I(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function bt(n,e,t=""){I(ot(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function kr(n){I(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function H(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function Ou(n){return n.length===0}function Pm(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==null&&e[t]!==null&&n[t]!==e[t])return!1;return!0}function ot(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Yr(n){return n%1===0}function Ds(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function Om(n,e){let t=1,r=-1;for(let o=0;o<n.length;++o)if(n[o]>=0)t*=n[o];else if(n[o]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${o}`);r=o}else if(n[o]<0)throw Error(`Shapes can not be < 0. Found ${n[o]} at dim ${o}`);if(r===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const s=n.slice();return s[r]=e/t,s}function Tt(n,e){const t=e.length;return n=n==null?e.map((r,s)=>s):[].concat(n),I(n.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),I(n.every(r=>Yr(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function Fm(n,e){const t=[],r=[],s=e!=null&&Array.isArray(e)&&e.length===0,o=e==null||s?null:Tt(e,n).sort();let i=0;for(let a=0;a<n.length;++a){if(o!=null){if(o[i]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(o[i]==null||o[i]>a)&&n[a]===1&&(t.push(n[a]),r.push(a)),o[i]<=a&&i++}n[a]!==1&&(t.push(n[a]),r.push(a))}return{newShape:t,keptDims:r}}function wn(n,e){return We(n,e)}function We(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function zm(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function Lm(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function Bm(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function ai(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function Mm(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function io(n){return typeof n=="string"||n instanceof String}function Vm(n){return typeof n=="boolean"}function Wm(n){return typeof n=="number"}function us(n){return Array.isArray(n)?us(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":Wm(n)?"float32":io(n)?"string":Vm(n)?"bool":"float32"}function ui(n){return!!(n&&n.constructor&&n.call&&n.apply)}function Qe(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function jl(n,e,t,r=!1){const s=new Array;if(e.length===1){const o=e[0]*(r?2:1);for(let i=0;i<o;i++)s[i]=t[n+i]}else{const o=e[0],i=e.slice(1),a=i.reduce((u,l)=>u*l)*(r?2:1);for(let u=0;u<o;u++)s[u]=jl(n+u*a,i,t,r)}return s}function li(n,e,t=!1){if(n.length===0)return e[0];const r=n.reduce((s,o)=>s*o)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return jl(0,n,e,t)}function jo(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function ql(n,e){const t=on(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function on(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function wt(n){n.forEach(e=>{I(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function ci(n,e,t){if(e===0)return 0;if(e===1)return n[0];let r=n[n.length-1];for(let s=0;s<n.length-1;++s)r+=t[s]*n[s];return r}function qi(n,e,t){if(e===0)return[];if(e===1)return[n];const r=new Array(e);for(let s=0;s<r.length-1;++s)r[s]=Math.floor(n/t[s]),n-=r[s]*t[s];return r[r.length-1]=n,r}function Gn(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fu="tfjsflags";class Um{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Gm,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(oe().getBool("IS_TEST")||oe().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){const s=this.urlFlags[e];oe().getBool("IS_TEST")||oe().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${s}.`),this.set(e,s)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Gn(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);Fu in e&&e[Fu].split(",").forEach(r=>{const[s,o]=r.split(":");this.urlFlags[s]=jm(s,o)})}}function Gm(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(Hm(e,r[0],r[1]),r.join("="))),e}function Hm(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function jm(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function oe(){return Kl}let Kl=null;function qm(n){Kl=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let qo;function Xl(){if(qo==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");qo=n}return qo}function Km(){const n=Xl();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function Ki(n,e){const t=Km();if(t.has(n))return t.get(n);{const r=e();return t.set(n,r),t.get(n)}}const Yl="Abs",Ql="Acos",Zl="Acosh",Xi="Add",Jl="AddN",ec="All",tc="Any",nc="ArgMax",rc="ArgMin",sc="Asin",oc="Asinh",ic="Atan",ac="Atanh",uc="Atan2",lc="AvgPool",Xm="AvgPoolGrad",cc="AvgPool3D",Ym="AvgPool3DGrad",hc="BatchMatMul",dc="BatchToSpaceND",pc="Bincount",Qm="BitwiseAnd",fc="BroadcastArgs",Yi="Cast",mc="Ceil",gc="ClipByValue",yc="Complex",bc="ComplexAbs",wc="Concat",xc="Conv2D",vc="Conv2DBackpropFilter",Sc="Conv2DBackpropInput",Cc="Conv3D",Zm="Conv3DBackpropFilterV2",Ic="Conv3DBackpropInputV2",kc="Cos",Nc="Cosh",$c="Cumprod",Tc="Cumsum",Ec="CropAndResize",_c="DenseBincount",Ac="DepthToSpace",Rc="DepthwiseConv2dNative",Dc="DepthwiseConv2dNativeBackpropFilter",Pc="DepthwiseConv2dNativeBackpropInput",Oc="Diag",Fc="Dilation2D",Jm="Dilation2DBackpropInput",eg="Dilation2DBackpropFilter",tg="Draw",zc="RealDiv",Lc="Einsum",Bc="Elu",ng="EluGrad",Mc="Erf",Vc="Equal",Wc="Exp",Uc="ExpandDims",Gc="Expm1",Hc="FFT",jc="Fill",qc="FlipLeftRight",Kc="Floor",Xc="FloorDiv",Yc="FusedBatchNorm",Qc="GatherV2",Zc="GatherNd",Jc="Greater",eh="GreaterEqual",Qi="Identity",th="IFFT",nh="Imag",rh="IsFinite",sh="IsInf",oh="IsNan",ih="LeakyRelu",ah="Less",uh="LessEqual",lh="LinSpace",ch="Log",hh="Log1p",dh="LogicalAnd",ph="LogicalNot",fh="LogicalOr",mh="LRN",rg="LRNGrad",gh="Max",yh="Maximum",bh="MaxPool",sg="MaxPoolGrad",wh="MaxPool3D",og="MaxPool3DGrad",xh="MaxPoolWithArgmax",vh="Mean",Sh="Min",Ch="Minimum",Ih="MirrorPad",kh="Mod",Nh="Multinomial",$h="Multiply",Th="Neg",Eh="NotEqual",_h="NonMaxSuppressionV3",ig="NonMaxSuppressionV4",Ah="NonMaxSuppressionV5",Rh="OnesLike",Dh="OneHot",Ph="Pack",Oh="PadV2",Fh="Pow",zh="Prelu",Lh="Prod",ag="RaggedGather",ug="RaggedRange",lg="RaggedTensorToTensor",Bh="Range",Mh="Real",Vh="Reciprocal",Wh="Relu",Uh="Reshape",Gh="ResizeNearestNeighbor",cg="ResizeNearestNeighborGrad",Hh="ResizeBilinear",hg="ResizeBilinearGrad",jh="Relu6",qh="Reverse",Kh="Round",Xh="Rsqrt",Yh="ScatterNd",Qh="TensorScatterUpdate",Zh="SearchSorted",Jh="Select",ed="Selu",td="Slice",nd="Sin",rd="Sinh",sd="Sign",od="Sigmoid",id="Softplus",ad="Sqrt",ud="Sum",ld="SpaceToBatchND",cd="SplitV",hd="Softmax",dg="SparseFillEmptyRows",pg="SparseReshape",dd="SparseSegmentMean",pd="SparseSegmentSum",fd="SparseToDense",md="SquaredDifference",fg="Square",mg="StaticRegexReplace",gd="StridedSlice",yd="StringNGrams",gg="StringSplit",yg="StringToHashBucketFast",bd="Sub",wd="Tan",xd="Tanh",Zi="Tile",vd="TopK",Sd="Transform",Ps="Transpose",bg="Unique",Cd="Unpack",Id="UnsortedSegmentSum",kd="ZerosLike",Nd="Step",hi="FromPixels",$d="RotateWithOffset",di="_FusedMatMul",pi="FusedConv2D",fi="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hr(...n){oe().getBool("IS_TEST")||oe().getBool("PROD")||console.warn(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bs=Ki("kernelRegistry",()=>new Map),wg=Ki("gradRegistry",()=>new Map);function mi(n,e){const t=Td(n,e);return Bs.get(t)}function zu(n){return wg.get(n)}function Lu(n){const e=Bs.entries(),t=[];for(;;){const{done:r,value:s}=e.next();if(r)break;const[o,i]=s,[a]=o.split("_");a===n&&t.push(i)}return t}function xg(n){const{kernelName:e,backendName:t}=n,r=Td(e,t);Bs.has(r)&&hr(`The kernel '${e}' for backend '${t}' is already registered`),Bs.set(r,n)}function Td(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ed(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var Kt=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function vg(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function Sg(n){if(n.__esModule)return n;var e=n.default;if(typeof e=="function"){var t=function r(){return this instanceof r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(r){var s=Object.getOwnPropertyDescriptor(n,r);Object.defineProperty(t,r,s.get?s:{enumerable:!0,get:function(){return n[r]}})}),t}var _d=$e,It=null;try{It=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function $e(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}$e.prototype.__isLong__;Object.defineProperty($e.prototype,"__isLong__",{value:!0});function mt(n){return(n&&n.__isLong__)===!0}$e.isLong=mt;var Bu={},Mu={};function Jn(n,e){var t,r,s;return e?(n>>>=0,(s=0<=n&&n<256)&&(r=Mu[n],r)?r:(t=Te(n,(n|0)<0?-1:0,!0),s&&(Mu[n]=t),t)):(n|=0,(s=-128<=n&&n<128)&&(r=Bu[n],r)?r:(t=Te(n,n<0?-1:0,!1),s&&(Bu[n]=t),t))}$e.fromInt=Jn;function kt(n,e){if(isNaN(n))return e?zn:Nt;if(e){if(n<0)return zn;if(n>=Ad)return Pd}else{if(n<=-Wu)return pt;if(n+1>=Wu)return Dd}return n<0?kt(-n,e).neg():Te(n%wr|0,n/wr|0,e)}$e.fromNumber=kt;function Te(n,e,t){return new $e(n,e,t)}$e.fromBits=Te;var Ms=Math.pow;function Ji(n,e,t){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return Nt;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var r;if((r=n.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return Ji(n.substring(1),e,t).neg();for(var s=kt(Ms(t,8)),o=Nt,i=0;i<n.length;i+=8){var a=Math.min(8,n.length-i),u=parseInt(n.substring(i,i+a),t);if(a<8){var l=kt(Ms(t,a));o=o.mul(l).add(kt(u))}else o=o.mul(s),o=o.add(kt(u))}return o.unsigned=e,o}$e.fromString=Ji;function zt(n,e){return typeof n=="number"?kt(n,e):typeof n=="string"?Ji(n,e):Te(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}$e.fromValue=zt;var Vu=65536,Cg=1<<24,wr=Vu*Vu,Ad=wr*wr,Wu=Ad/2,Uu=Jn(Cg),Nt=Jn(0);$e.ZERO=Nt;var zn=Jn(0,!0);$e.UZERO=zn;var mr=Jn(1);$e.ONE=mr;var Rd=Jn(1,!0);$e.UONE=Rd;var gi=Jn(-1);$e.NEG_ONE=gi;var Dd=Te(-1,2147483647,!1);$e.MAX_VALUE=Dd;var Pd=Te(-1,-1,!0);$e.MAX_UNSIGNED_VALUE=Pd;var pt=Te(0,-2147483648,!1);$e.MIN_VALUE=pt;var Y=$e.prototype;Y.toInt=function(){return this.unsigned?this.low>>>0:this.low};Y.toNumber=function(){return this.unsigned?(this.high>>>0)*wr+(this.low>>>0):this.high*wr+(this.low>>>0)};Y.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(pt)){var t=kt(e),r=this.div(t),s=r.mul(t).sub(this);return r.toString(e)+s.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var o=kt(Ms(e,6),this.unsigned),i=this,a="";;){var u=i.div(o),l=i.sub(u.mul(o)).toInt()>>>0,h=l.toString(e);if(i=u,i.isZero())return h+a;for(;h.length<6;)h="0"+h;a=""+h+a}};Y.getHighBits=function(){return this.high};Y.getHighBitsUnsigned=function(){return this.high>>>0};Y.getLowBits=function(){return this.low};Y.getLowBitsUnsigned=function(){return this.low>>>0};Y.getNumBitsAbs=function(){if(this.isNegative())return this.eq(pt)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return this.high!=0?t+33:t+1};Y.isZero=function(){return this.high===0&&this.low===0};Y.eqz=Y.isZero;Y.isNegative=function(){return!this.unsigned&&this.high<0};Y.isPositive=function(){return this.unsigned||this.high>=0};Y.isOdd=function(){return(this.low&1)===1};Y.isEven=function(){return(this.low&1)===0};Y.equals=function(e){return mt(e)||(e=zt(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};Y.eq=Y.equals;Y.notEquals=function(e){return!this.eq(e)};Y.neq=Y.notEquals;Y.ne=Y.notEquals;Y.lessThan=function(e){return this.comp(e)<0};Y.lt=Y.lessThan;Y.lessThanOrEqual=function(e){return this.comp(e)<=0};Y.lte=Y.lessThanOrEqual;Y.le=Y.lessThanOrEqual;Y.greaterThan=function(e){return this.comp(e)>0};Y.gt=Y.greaterThan;Y.greaterThanOrEqual=function(e){return this.comp(e)>=0};Y.gte=Y.greaterThanOrEqual;Y.ge=Y.greaterThanOrEqual;Y.compare=function(e){if(mt(e)||(e=zt(e)),this.eq(e))return 0;var t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};Y.comp=Y.compare;Y.negate=function(){return!this.unsigned&&this.eq(pt)?pt:this.not().add(mr)};Y.neg=Y.negate;Y.add=function(e){mt(e)||(e=zt(e));var t=this.high>>>16,r=this.high&65535,s=this.low>>>16,o=this.low&65535,i=e.high>>>16,a=e.high&65535,u=e.low>>>16,l=e.low&65535,h=0,c=0,d=0,f=0;return f+=o+l,d+=f>>>16,f&=65535,d+=s+u,c+=d>>>16,d&=65535,c+=r+a,h+=c>>>16,c&=65535,h+=t+i,h&=65535,Te(d<<16|f,h<<16|c,this.unsigned)};Y.subtract=function(e){return mt(e)||(e=zt(e)),this.add(e.neg())};Y.sub=Y.subtract;Y.multiply=function(e){if(this.isZero())return Nt;if(mt(e)||(e=zt(e)),It){var t=It.mul(this.low,this.high,e.low,e.high);return Te(t,It.get_high(),this.unsigned)}if(e.isZero())return Nt;if(this.eq(pt))return e.isOdd()?pt:Nt;if(e.eq(pt))return this.isOdd()?pt:Nt;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(Uu)&&e.lt(Uu))return kt(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,s=this.high&65535,o=this.low>>>16,i=this.low&65535,a=e.high>>>16,u=e.high&65535,l=e.low>>>16,h=e.low&65535,c=0,d=0,f=0,m=0;return m+=i*h,f+=m>>>16,m&=65535,f+=o*h,d+=f>>>16,f&=65535,f+=i*l,d+=f>>>16,f&=65535,d+=s*h,c+=d>>>16,d&=65535,d+=o*l,c+=d>>>16,d&=65535,d+=i*u,c+=d>>>16,d&=65535,c+=r*h+s*l+o*u+i*a,c&=65535,Te(f<<16|m,c<<16|d,this.unsigned)};Y.mul=Y.multiply;Y.divide=function(e){if(mt(e)||(e=zt(e)),e.isZero())throw Error("division by zero");if(It){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?It.div_u:It.div_s)(this.low,this.high,e.low,e.high);return Te(t,It.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?zn:Nt;var r,s,o;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return zn;if(e.gt(this.shru(1)))return Rd;o=zn}else{if(this.eq(pt)){if(e.eq(mr)||e.eq(gi))return pt;if(e.eq(pt))return mr;var i=this.shr(1);return r=i.div(e).shl(1),r.eq(Nt)?e.isNegative()?mr:gi:(s=this.sub(e.mul(r)),o=r.add(s.div(e)),o)}else if(e.eq(pt))return this.unsigned?zn:Nt;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();o=Nt}for(s=this;s.gte(e);){r=Math.max(1,Math.floor(s.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(r)/Math.LN2),u=a<=48?1:Ms(2,a-48),l=kt(r),h=l.mul(e);h.isNegative()||h.gt(s);)r-=u,l=kt(r,this.unsigned),h=l.mul(e);l.isZero()&&(l=mr),o=o.add(l),s=s.sub(h)}return o};Y.div=Y.divide;Y.modulo=function(e){if(mt(e)||(e=zt(e)),It){var t=(this.unsigned?It.rem_u:It.rem_s)(this.low,this.high,e.low,e.high);return Te(t,It.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};Y.mod=Y.modulo;Y.rem=Y.modulo;Y.not=function(){return Te(~this.low,~this.high,this.unsigned)};Y.and=function(e){return mt(e)||(e=zt(e)),Te(this.low&e.low,this.high&e.high,this.unsigned)};Y.or=function(e){return mt(e)||(e=zt(e)),Te(this.low|e.low,this.high|e.high,this.unsigned)};Y.xor=function(e){return mt(e)||(e=zt(e)),Te(this.low^e.low,this.high^e.high,this.unsigned)};Y.shiftLeft=function(e){return mt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Te(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Te(0,this.low<<e-32,this.unsigned)};Y.shl=Y.shiftLeft;Y.shiftRight=function(e){return mt(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Te(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Te(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};Y.shr=Y.shiftRight;Y.shiftRightUnsigned=function(e){if(mt(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var r=this.low;return Te(r>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?Te(t,0,this.unsigned):Te(t>>>e-32,0,this.unsigned)};Y.shru=Y.shiftRightUnsigned;Y.shr_u=Y.shiftRightUnsigned;Y.toSigned=function(){return this.unsigned?Te(this.low,this.high,!1):this};Y.toUnsigned=function(){return this.unsigned?this:Te(this.low,this.high,!0)};Y.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};Y.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};Y.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};$e.fromBytes=function(e,t,r){return r?$e.fromBytesLE(e,t):$e.fromBytesBE(e,t)};$e.fromBytesLE=function(e,t){return new $e(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};$e.fromBytesBE=function(e,t){return new $e(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)};const Od=vg(_d),Ig=Em({__proto__:null,default:Od},[_d]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dn=Od||Ig;function ao(n){return Dn.fromString(n,!0,16)}const Fd=ao("c3a5c85c97cb3127"),An=ao("b492b66fbe98f273"),et=ao("9ae16a3b2f90404f");function yi(n){return n.xor(n.shru(47))}function zd(n,e,t){const r=n.slice(e,e+t);return Dn.fromBytes(Array.from(r),!0,!0)}function Ie(n,e){return zd(n,e,8)}function Gu(n,e){return zd(n,e,4)}function Ve(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function gn(n,e,t=ao("9ddfea08eb382d69")){let r=n.xor(e).mul(t);r=r.xor(r.shru(47));let s=e.xor(r).mul(t);return s=s.xor(s.shru(47)),s=s.mul(t),s}function kg(n,e,t,r,s,o){s=s.add(n),o=Ve(o.add(s).add(r),21);const i=s;return s=s.add(e),s=s.add(t),o=o.add(Ve(s,44)),[s.add(r),o.add(i)]}function _s(n,e,t,r){return kg(Ie(n,e),Ie(n,e+8),Ie(n,e+16),Ie(n,e+24),t,r)}function Ng(n,e=n.length){if(e>=8){const t=et.add(e*2),r=Ie(n,0).add(et),s=Ie(n,e-8),o=Ve(s,37).mul(t).add(r),i=Ve(r,25).add(s).mul(t);return gn(o,i,t)}if(e>=4){const t=et.add(e*2),r=Gu(n,0);return gn(r.shl(3).add(e),Gu(n,e-4),t)}if(e>0){const t=n[0],r=n[e>>1],s=n[e-1],o=t+(r<<8),i=e+(s<<2);return yi(et.mul(o).xor(Fd.mul(i))).mul(et)}return et}function $g(n,e=n.length){const t=et.add(e*2),r=Ie(n,0).mul(An),s=Ie(n,8),o=Ie(n,e-8).mul(t),i=Ie(n,e-16).mul(et);return gn(Ve(r.add(s),43).add(Ve(o,30)).add(i),r.add(Ve(s.add(et),18)).add(o),t)}function Tg(n,e=n.length){const t=et.add(e*2),r=Ie(n,0).mul(et),s=Ie(n,8),o=Ie(n,e-8).mul(t),i=Ie(n,e-16).mul(et),a=Ve(r.add(s),43).add(Ve(o,30)).add(i),u=gn(a,r.add(Ve(s.add(et),18)).add(o),t),l=Ie(n,16).mul(t),h=Ie(n,24),c=a.add(Ie(n,e-32)).mul(t),d=u.add(Ie(n,e-24)).mul(t);return gn(Ve(l.add(h),43).add(Ve(c,30)).add(d),l.add(Ve(h.add(r),18)).add(c),t)}function Eg(n,e=n.length){const t=Dn.fromNumber(81,!0);if(e<=32)return e<=16?Ng(n,e):$g(n,e);if(e<=64)return Tg(n,e);let r=t,s=t.mul(An).add(113),o=yi(s.mul(et).add(113)).mul(et),i=[Dn.UZERO,Dn.UZERO],a=[Dn.UZERO,Dn.UZERO];r=r.mul(et).add(Ie(n,0));let u=0;const l=(e-1>>6)*64,h=l+(e-1&63)-63;do r=Ve(r.add(s).add(i[0]).add(Ie(n,u+8)),37).mul(An),s=Ve(s.add(i[1]).add(Ie(n,u+48)),42).mul(An),r=r.xor(a[1]),s=s.add(i[0]).add(Ie(n,u+40)),o=Ve(o.add(a[0]),33).mul(An),i=_s(n,u,i[1].mul(An),r.add(a[0])),a=_s(n,u+32,o.add(a[1]),s.add(Ie(n,u+16))),[o,r]=[r,o],u+=64;while(u!==l);const c=An.add(o.and(255).shl(1));return u=h,a[0]=a[0].add(e-1&63),i[0]=i[0].add(a[0]),a[0]=a[0].add(i[0]),r=Ve(r.add(s).add(i[0]).add(Ie(n,u+8)),37).mul(c),s=Ve(s.add(i[1]).add(Ie(n,u+48)),42).mul(c),r=r.xor(a[1].mul(9)),s=s.add(i[0].mul(9).add(Ie(n,u+40))),o=Ve(o.add(a[0]),33).mul(c),i=_s(n,u,i[1].mul(c),r.add(a[0])),a=_s(n,u+32,o.add(a[1]),s.add(Ie(n,u+16))),[o,r]=[r,o],gn(gn(i[0],a[0],c).add(yi(s).mul(Fd)).add(o),gn(i[1],a[1],c).add(r),c)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _g(n,e){return e==="string"?Mn(n):uo([n],e)}function Ag(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function uo(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Hn(n)),oe().getBool("DEBUG")&&zm(n,e),Ag(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Vs(){return oe().platform.now()}function Mn(n,e="utf-8"){return e=e||"utf-8",oe().platform.encode(n,e)}function xr(n,e="utf-8"){return e=e||"utf-8",oe().platform.decode(n,e)}function $t(n){return oe().platform.isTypedArray!=null?oe().platform.isTypedArray(n):Ed(n)}function Hn(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Gn(n)||n==null||$t(n)&&t)e.push(n);else if(Array.isArray(n)||$t(n))for(let r=0;r<n.length;++r)Hn(n[r],e,t);else{let r=-1;for(const s of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(s)&&(r=Math.max(r,Number(s)));for(let s=0;s<=r;s++)Hn(n[s],e,t)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rg{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new Pg)}profileKernel(e,t,r){let s;const o=()=>{s=r()};let i;const a=Vs();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(o);else{o();for(const l of s)l.dataSync();i=Promise.resolve({kernelMs:Vs()-a})}if(oe().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<s.length;l++){const h=s[l];h.data().then(c=>{Dg(c,h.dtype,e)})}return{kernelName:e,outputs:s,inputs:t,timeMs:i.then(l=>l.kernelMs),extraInfo:i.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:s,inputs:o,extraInfo:i}=e;r.forEach(a=>{Promise.all([a.data(),s,i]).then(u=>{this.logger.logKernelProfile(t,a,u[0],u[1],o,u[2])})})}}function Dg(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){const s=n[r];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${t}'`),!0}return!1}class Pg{logKernelProfile(e,t,r,s,o,i){const a=typeof s=="number"?Ds(`${s}ms`,9):s.error,u=Ds(e,25),l=t.rank,h=t.size,c=Ds(t.shape.toString(),14);let d="";for(const f in o){const m=o[f];if(m!=null){const x=m.shape||t.shape,b=x.length;d+=`${f}: ${b}D ${b>0?x:""} `}}console.log(`%c${u}	%c${a}	%c${l}D ${c}	%c${h}	%c${d}	%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Og(n,e,t){const r={},s={};for(let u=0;u<e.length;u++)r[e[u].id]=!0;for(let u=0;u<n.length;u++){const l=n[u],h=l.inputs;for(const c in h){const d=h[c];let f=!1;for(let m=0;m<e.length;m++)if(r[d.id]){l.outputs.forEach(x=>r[x.id]=!0),f=!0,s[l.id]=!0;break}if(f)break}}const o={};o[t.id]=!0;const i={};for(let u=n.length-1;u>=0;u--){const l=n[u],h=l.inputs;for(let c=0;c<l.outputs.length;c++)if(o[l.outputs[c].id]){for(const d in h)o[h[d].id]=!0,i[l.id]=!0;break}}const a=[];for(let u=0;u<n.length;u++){const l=n[u];if(s[l.id]&&i[l.id]){const h={};for(const d in l.inputs){const f=l.inputs[d];r[f.id]&&(h[d]=f)}const c=Object.assign({},l);c.inputs=h,c.outputs=l.outputs,a.push(c)}}return a}function Fg(n,e,t,r){for(let s=e.length-1;s>=0;s--){const o=e[s],i=[];if(o.outputs.forEach(u=>{const l=n[u.id];l!=null?i.push(l):i.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const a=o.gradient(i);for(const u in o.inputs){if(!(u in a))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(a)}.`);const l=t(()=>a[u]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${l.dtype}'`);const h=o.inputs[u];if(!ot(l.shape,h.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${u}' has shape '${l.shape}', which does not match the shape of the input '${h.shape}'`);if(n[h.id]==null)n[h.id]=l;else{const c=n[h.id];n[h.id]=r(c,l),c.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hu=20,Vr=3,Ko=7;function zg(n,e,t,r){const s=Qe(e),o=Lg(n,e,t,s),i=e.length,a=Os(n,e,t,s,o),u=["Tensor"];return r&&(u.push(`  dtype: ${t}`),u.push(`  rank: ${i}`),u.push(`  shape: [${e}]`),u.push("  values:")),u.push(a.map(l=>"    "+l).join(`
`)),u.join(`
`)}function Lg(n,e,t,r){const s=H(e),o=r[r.length-1],i=new Array(o).fill(0),a=e.length,u=t==="complex64"?Gr(n):n;if(a>1)for(let l=0;l<s/o;l++){const h=l*o;for(let c=0;c<o;c++)i[c]=Math.max(i[c],Ur(u[h+c],0,t).length)}return i}function Ur(n,e,t){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(Ko))} + ${parseFloat(n[1].toFixed(Ko))}j`:io(n)?r=`'${n}'`:t==="bool"?r=Ld(n):r=parseFloat(n.toFixed(Ko)).toString(),Ds(r,e)}function Ld(n){return n===0?"false":"true"}function Os(n,e,t,r,s,o=!0){const i=t==="complex64"?2:1,a=e[0],u=e.length;if(u===0){if(t==="complex64"){const x=Gr(n);return[Ur(x[0],0,t)]}return t==="bool"?[Ld(n[0])]:[n[0].toString()]}if(u===1){if(a>Hu){const b=Vr*i;let v=Array.from(n.slice(0,b)),k=Array.from(n.slice((a-Vr)*i,a*i));return t==="complex64"&&(v=Gr(v),k=Gr(k)),["["+v.map(($,N)=>Ur($,s[N],t)).join(", ")+", ..., "+k.map(($,N)=>Ur($,s[a-Vr+N],t)).join(", ")+"]"]}return["["+(t==="complex64"?Gr(n):Array.from(n)).map((b,v)=>Ur(b,s[v],t)).join(", ")+"]"]}const l=e.slice(1),h=r.slice(1),c=r[0]*i,d=[];if(a>Hu){for(let x=0;x<Vr;x++){const b=x*c,v=b+c;d.push(...Os(n.slice(b,v),l,t,h,s,!1))}d.push("...");for(let x=a-Vr;x<a;x++){const b=x*c,v=b+c;d.push(...Os(n.slice(b,v),l,t,h,s,x===a-1))}}else for(let x=0;x<a;x++){const b=x*c,v=b+c;d.push(...Os(n.slice(b,v),l,t,h,s,x===a-1))}const f=u===2?",":"";d[0]="["+(a>0?d[0]+f:"");for(let x=1;x<d.length-1;x++)d[x]=" "+d[x]+f;let m=`,
`;for(let x=2;x<u;x++)m+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(o?"":m),d}function Gr(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vr{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=H(e),r!=null){const s=r.length;I(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||We(t,this.size),this.strides=Qe(e)}set(e,...t){t.length===0&&(t=[0]),I(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const r=this.locToIndex(t);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const s of e){if(s<0||s>=this.shape[t]){const o=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(o)}t++}let r=e[e.length-1];for(let s=0;s<e.length-1;++s)r+=this.strides[s]*e[s];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Dt().makeTensor(this.values,this.shape,this.dtype)}}let Dt=null,dr=null;function Bg(n){Dt=n}function Mg(n){dr=n}class Be{constructor(e,t,r,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=H(e),this.strides=Qe(e),this.dataId=r,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return dr.buffer(this.shape,this.dtype,e)}bufferSync(){return dr.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return li(this.shape,e,this.dtype==="complex64")}arraySync(){return li(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Dt().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(r=>xr(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Dt().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Dt().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>xr(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Dt().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Dt().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return dr.print(this,e)}clone(){return this.throwIfDisposed(),dr.clone(this)}toString(e=!1){const t=this.dataSync();return zg(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),dr.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),Dt().makeVariable(this,e,t,r)}}Object.defineProperty(Be,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function Bd(){return Ki("Tensor",()=>Be)}Bd();class Ws extends Be{constructor(e,t,r,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!ot(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Dt().disposeTensor(this),this.dataId=e.dataId,Dt().incRef(this,null)}dispose(){Dt().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Ws,Symbol.hasInstance,{value:n=>n instanceof Be&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ju;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(ju||(ju={}));var bi;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(bi||(bi={}));var wi;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(wi||(wi={}));var xi;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(xi||(xi={}));var vi;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(vi||(vi={}));const Vg={float32:xi,int32:bi,bool:wi,complex64:vi};function xn(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return Vg[n][e]}function Wg(n){return xn(n,"int32")}function Md(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function Vd(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oe(n,e){if(n.dtype===e.dtype)return[n,e];const t=xn(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function Ug(n,e){I(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function Wd(n){const e=[];return Ud(n,e,new Set),e}function Ud(n,e,t){if(n==null)return;if(n instanceof Be){e.push(n);return}if(!Gg(n))return;const r=n;for(const s in r){const o=r[s];t.has(o)||(t.add(o),Ud(o,e,t))}}function Gg(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xo(n){return n.kernelName!=null}class qu{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Sr{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new qu}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(hr(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Rg(this.backendInstance),!0}setupRegisteredKernels(){Lu(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Lu(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=t.factory();if(r&&!(r instanceof Hl)&&typeof r.then=="function"){const s=++this.pendingBackendInitId,o=r.then(i=>s<this.pendingBackendInitId?!1:(this.registry[e]=i,this.pendingBackendInit=null,!0)).catch(i=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,hr(`Initialization of backend ${e} failed`),hr(i.stack||i.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return hr(`Initialization of backend ${e} failed`),hr(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t],{success:s,asyncInit:o}=this.initializeBackend(r);if(o||s)return{name:r,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const r=this.state.tensorInfo.get(t),s=r.backend,o=this.readSync(t),i=s.refCount(t);s.disposeData(t,!0),r.backend=e,e.move(t,o,r.shape,r.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let s;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(s),()=>(s=t(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(e,t,r){e();try{const s=r();return t(),s}catch(s){throw t(),s}}nextTensorId(){return Sr.nextTensorId++}nextVariableId(){return Sr.nextVariableId++}clone(e){const t=D.runKernel(Qi,{x:e}),r={x:e},s=i=>({x:()=>{const a="float32",u={x:i},l={dtype:a};return D.runKernel(Yi,u,l)}}),o=[];return this.addTapeNode(this.state.activeScope.name,r,[t],s,o,{}),t}runKernel(e,t,r){if(this.backendName==null&&this.backend,!(mi(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){const s=this.backend.numDataIds();let o=0;r.forEach(u=>{o+=u.dtype==="complex64"?3:1});const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=s-t-o-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,r=[];const s=this.isTapeOn(),o=this.state.numBytes,i=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let u;const l=Xo(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Xo(e)){const{kernelName:m,inputs:x,attrs:b}=e;this.backendName==null&&this.backend;const v=mi(m,this.backendName);I(v!=null,()=>`Cannot find registered kernel '${m}' for backend '${this.backendName}'`),a=()=>{const k=this.backend.numDataIds();u=v.kernelFunc({inputs:x,attrs:b,backend:this.backend});const $=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(m,k,$);const N=$.map(R=>R.rank!=null?R:this.makeTensorFromTensorInfo(R));if(s){const R=this.getTensorsForGradient(m,x,N);r=this.saveTensorsForBackwardMode(R)}return N}}else{const{forwardFunc:m}=e,x=b=>{s&&(r=b.map(v=>this.keep(this.clone(v))))};a=()=>{const b=this.backend.numDataIds();u=this.tidy(()=>m(this.backend,x));const v=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,b,v),v}}const{inputs:h,attrs:c}=e,d=Xo(e)?null:e.backwardsFunc;let f;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(f=this.profiler.profileKernel(l,h,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(f),t=f.outputs)}),s&&this.addTapeNode(l,h,t,d,r,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(h).map(m=>h[m]!=null?h[m].shape:null),outputShapes:t.map(m=>m.shape),kernelTimeMs:f.timeMs,extraInfo:f.extraInfo}),Array.isArray(u)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,t,r){const s=zu(e);if(s!=null){const o=s.inputsToSave||[],i=s.outputsToSave||[];let a;s.saveAllInputs?(I(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(l=>t[l])):a=o.map(l=>t[l]);const u=r.filter((l,h)=>i[h]);return a.concat(u)}return[]}makeTensor(e,t,r,s){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",s=s||this.backend;let o=e;r==="string"&&io(e[0])&&(o=e.map(u=>Mn(u)));const i=s.write(o,t,r),a=new Be(t,r,i,this.nextTensorId());if(this.trackTensor(a,s),r==="string"){const u=this.state.tensorInfo.get(i),l=Mm(o);this.state.numBytes+=l-u.bytes,u.bytes=l}return a}makeTensorFromDataId(e,t,r,s){r=r||"float32";const o={dataId:e,shape:t,dtype:r};return this.makeTensorFromTensorInfo(o,s)}makeTensorFromTensorInfo(e,t){const{dataId:r,shape:s,dtype:o}=e,i=new Be(s,o,r,this.nextTensorId());return this.trackTensor(i,t),i}makeVariable(e,t=!0,r,s){r=r||this.nextVariableId().toString(),s!=null&&s!==e.dtype&&(e=e.cast(s));const o=new Ws(e,t,r,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*ai(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof Ws||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*ai(e.dtype);this.state.numBytes-=r}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,r,s,o,i){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:o},u=zu(e);u!=null&&(s=u.gradFunc),s!=null&&(a.gradient=l=>(l=l.map((h,c)=>{if(h==null){const d=r[c],f=on(d.size,d.dtype);return this.makeTensor(f,d.shape,d.dtype)}return h}),s(l.length>1?l:l[0],o,i))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=Wd(e),r=new Set(t.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const i=this.state.activeScope.track[o];!i.kept&&!r.has(i.id)&&i.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(o=>{!o.kept&&o.scopeId===s.id&&this.track(o)})}gradients(e,t,r,s=!1){if(I(t.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));I(o instanceof Be,()=>"The result y returned by f() must be a tensor.");const i=Og(this.state.activeTape,t,o);if(!s&&i.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[o.id]=r??Hg(o.shape),Fg(a,i,l=>this.tidy(l),jg);const u=t.map(l=>a[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(const h of l.saved)h.dispose()}),this.state.activeTape=null),{value:o,grads:u}})}customGrad(e){return I(ui(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{I(t.every(a=>a instanceof Be),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const s={};t.forEach((a,u)=>{s[u]=a});const o=(a,u)=>(r=e(...t,u),I(r.value instanceof Be,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),I(ui(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),i=(a,u)=>{const l=r.gradFunc(a,u),h=Array.isArray(l)?l:[l];I(h.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),I(h.every(d=>d instanceof Be),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const c={};return h.forEach((d,f)=>{c[f]=()=>d}),c};return this.runKernelFunc({forwardFunc:o,backwardsFunc:i,inputs:s})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Vs(),r=await this.backend.time(e);return r.wallMs=Vs()-t,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new qu;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Sr.nextTensorId=0;Sr.nextVariableId=0;function Hg(n){const e=ql(H(n),"float32");return D.makeTensor(e,n,"float32")}function Gd(){const n=Xl();if(n._tfengine==null){const e=new Um(n);n._tfengine=new Sr(e)}return qm(n._tfengine.ENV),Bg(()=>n._tfengine),n._tfengine}const D=Gd();function jg(n,e){const t={a:n,b:e};return D.runKernel(Xi,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qg(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const it=oe();it.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});it.registerFlag("IS_BROWSER",()=>qg());it.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");it.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));it.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));it.registerFlag("PROD",()=>!1);it.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>it.getBool("DEBUG"));it.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);it.registerFlag("IS_TEST",()=>!1);it.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>it.getBool("DEBUG"));it.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);it.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);it.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cn(n,e){let t=n;if($t(n))return e==="string"?[]:[n.length];if(Md(n)){const s=n.channels||"RGBA";return[n.height,n.width*s.length]}else if(Vd(n))return[n.buffer.size/(e==null?4:ai(e))];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(t)||$t(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&oe().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Hd(n,r,[]),r}function Hd(n,e,t){if(t=t||[],!Array.isArray(n)&&!$t(n)){I(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}I(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),I(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const r=e.slice(1);for(let s=0;s<n.length;++s)Hd(n[s],r,t.concat(s))}function Ku(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function C(n,e,t,r="numeric"){if(n instanceof Bd())return Ku(r,n.dtype,e,t),n;let s=us(n);if(s!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(s=r),Ku(r,s,e,t),n==null||!$t(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const u=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${u}'`)}const o=Cn(n,s);!$t(n)&&!Array.isArray(n)&&(n=[n]);const a=s!=="string"?uo(n,s):Hn(n,[],!0);return D.makeTensor(a,o,s)}function Us(n,e,t,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((o,i)=>C(o,`${e}[${i}]`,t,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jd="__op";function A(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+jd;const s=(...o)=>{D.startScope(t);try{const i=r(...o);return Gn(i)&&console.error("Cannot return a Promise inside of tidy."),D.endScope(i),i}catch(i){throw D.endScope(null),i}};return Object.defineProperty(s,"name",{value:t,configurable:!0}),s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kg(n,e){const t=C(n,"real","complex"),r=C(e,"imag","complex");bt(t.shape,r.shape,`real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`);const s={real:t,imag:r};return D.runKernel(yc,s)}const vn=A({complex_:Kg});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function In(n,e,t,r){if(r==null)r=us(n);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(Vd(n)||Md(n)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return D.backend.createTensorFromGPUData(n,e||t,r)}if(!$t(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){wt(e);const s=H(e),o=H(t);I(s===o,()=>`Based on the provided shape, [${e}], the tensor should have ${s} values but has ${o}`);for(let i=0;i<t.length;++i){const a=t[i],u=i===t.length-1?a!==H(e.slice(i)):!0;I(t[i]===e[i]||!u,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!$t(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=r!=="string"?uo(n,r):Hn(n,[],!0),D.makeTensor(n,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xt(n,e,t){const r=Cn(n,t);return In(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jn={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class Lt{static join(e){return new Lt(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(r=>$t(r)?r.buffer:r),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let r=0;r<e.length;r++){const s=e[r];r!==e.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const o=t+s.byteLength;this.shards.push({buffer:s,start:t,end:o}),t=o}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const r=this.findShardForByte(e);if(r===-1)throw new Error(`Could not find start shard for byte ${e}`);const s=t-e,o=new ArrayBuffer(s),i=new Uint8Array(o);let a=0;for(let u=r;u<this.shards.length;u++){const l=this.shards[u],c=e+a-l.start,d=a,m=Math.min(t,l.end)-l.start,x=new Uint8Array(l.buffer,c,m-c);if(i.set(x,d),a+=x.length,t<l.end)break}return o}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(s){return e<s.start?-1:e>=s.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const r=Xg(this.shards,t);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function Xg(n,e){let t=0,r=n.length;for(;t<=r;){const s=Math.floor((r-t)/2)+t,o=e(n[s]);if(o===0)return s;o<0?r=s:t=s+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yo(){return D}function be(n,e){return D.tidy(n,e)}function De(n){Wd(n).forEach(t=>t.dispose())}function qt(n){return D.keep(n)}function Yg(n){return D.setBackend(n)}function Qg(){return D.backendName}function Zg(n,e,t=1){return D.registerBackend(n,e,t)}function Jg(){return D.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sn=4;async function ey(n,e){const t=[],r=[],s=Array.isArray(n)?n.map(i=>i.name):Object.keys(n);for(let i=0;i<s.length;++i){const a=s[i],u=Array.isArray(n)?n[i].tensor:n[a];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${u.dtype}`);const l={name:a,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){const h=new Promise(async c=>{const d=await u.bytes(),f=d.reduce((b,v)=>b+v.length,0)+Sn*d.length,m=new Uint8Array(f);let x=0;for(let b=0;b<d.length;b++){const v=d[b],k=new Uint8Array(new Uint32Array([v.length]).buffer);m.set(k,x),x+=Sn,m.set(v,x),x+=v.length}c(m)});r.push(h)}else r.push(u.data());e!=null&&(l.group=e),t.push(l)}const o=await Promise.all(r);return{data:ry(o),specs:t}}function qd(n,e){const t=new Lt(n),r={};let s=0;for(const o of e){const i=ty(o,(a,u)=>t.slice(s+a,s+u));r[o.name]=Kd(o,t.slice(s,s+i)),s+=i}return r}function ty(n,e){const t=H(n.shape);let r;if("quantization"in n){const s=n.quantization;r=jn[s.dtype]}else if(n.dtype==="string"){let s=0;for(let o=0;o<t;o++)s+=Sn+new Uint32Array(e(s,s+Sn))[0];return s}else r=jn[n.dtype];return t*r}async function ny(n,e){const t=H(n.shape);let r;if("quantization"in n){const s=n.quantization;r=jn[s.dtype]}else if(n.dtype==="string"){let s=0;for(let o=0;o<t;o++)s+=Sn+new Uint32Array(await e(s,s+Sn))[0];return s}else r=jn[n.dtype];return t*r}function Kd(n,e){const t=n.name,r=n.dtype,s=n.shape,o=H(s);let i,a=0;if("quantization"in n){const u=n.quantization;if(u.dtype==="uint8"||u.dtype==="uint16"){if(!("min"in u&&"scale"in u))throw new Error(`Weight ${n.name} with quantization ${u.dtype} doesn't have corresponding metadata min and scale.`)}else if(u.dtype==="float16"){if(r!=="float32")throw new Error(`Weight ${n.name} is quantized with ${u.dtype} which only supports weights of type float32 not ${r}.`)}else throw new Error(`Weight ${n.name} has unknown quantization dtype ${u.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const l=jn[u.dtype],h=u.dtype==="uint8"?new Uint8Array(e):new Uint16Array(e);if(r==="float32")if(u.dtype==="uint8"||u.dtype==="uint16"){i=new Float32Array(h.length);for(let c=0;c<h.length;c++){const d=h[c];i[c]=d*u.scale+u.min}}else if(u.dtype==="float16")i=cy()(h);else throw new Error(`Unsupported quantization type ${u.dtype} for weight type float32.`);else if(r==="int32"){if(u.dtype!=="uint8"&&u.dtype!=="uint16")throw new Error(`Unsupported quantization type ${u.dtype} for weight type int32.`);i=new Int32Array(h.length);for(let c=0;c<h.length;c++){const d=h[c];i[c]=Math.round(d*u.scale+u.min)}}else throw new Error(`Unsupported dtype in weight '${t}': ${r}`);a+=o*l}else if(r==="string"){const u=H(n.shape);i=[];for(let l=0;l<u;l++){const h=new Uint32Array(e.slice(a,a+Sn))[0];a+=Sn;const c=new Uint8Array(e.slice(a,a+h));i.push(c),a+=h}}else{const u=jn[r];if(r==="float32")i=new Float32Array(e);else if(r==="int32")i=new Int32Array(e);else if(r==="bool")i=new Uint8Array(e);else if(r==="complex64"){i=new Float32Array(e);const l=new Float32Array(i.length/2),h=new Float32Array(i.length/2);for(let m=0;m<l.length;m++)l[m]=i[m*2],h[m]=i[m*2+1];const c=Xt(l,s,"float32"),d=Xt(h,s,"float32"),f=vn(c,d);return c.dispose(),d.dispose(),f}else throw new Error(`Unsupported dtype in weight '${t}': ${r}`);a+=o*u}return Xt(i,s,r)}async function Xu(n,e,t){let r=new Uint8Array(e);for(;r.byteLength<t;){const{done:s,value:o}=await n.read();if(s&&o==null){const a=t-r.byteLength;throw new Error(`Reader is done but ${a} bytes are still expected`)}const i=new Uint8Array(r.length+o.byteLength);i.set(r,0),i.set(new Uint8Array(o),r.length),r=i}return r.buffer}async function Xd(n,e){const t={},r=n.getReader();let s=new ArrayBuffer(0);for(const o of e){const i=await ny(o,async(l,h)=>(s=await Xu(r,s,h),s.slice(l,h)));s=await Xu(r,s,i);const a=s.slice(0,i);s=s.slice(i);const u=Kd(o,a);if(t[o.name]=u,Qg()==="webgpu"){const l=Jg();"uploadToGPU"in l&&H(u.shape)>=oe().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&l.uploadToGPU(u.dataId)}}return t}function ry(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(o=>{if(e+=o.byteLength,t.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const r=new Uint8Array(e);let s=0;return t.forEach(o=>{r.set(new Uint8Array(o.buffer),s),s+=o.byteLength}),r.buffer}const ea=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function Yu(n){return ea?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function sy(n){if(ea)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let r=0,s=e.length;r<s;r++)t+=String.fromCharCode(e[r]);return btoa(t)}function oy(n){if(ea){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t.set([e.charCodeAt(r)],r);return t.buffer}function iy(n){return Lt.join(n)}function Qu(n){const e="/";for(n=n.trim();n.endsWith(e);)n=n.slice(0,n.length-1);const t=n.split(e);return t[t.length-1]}function Yd(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function Qd(n,e,t){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(r.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=t}return n.signature!=null&&(r.signature=n.signature),n.userDefinedMetadata!=null&&(r.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(r.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(r.initializerSignature=n.initializerSignature),r}async function ta(n,e){let t,r;return n.weightsManifest!=null&&([t,r]=await e(n.weightsManifest)),Qd(n,t,r)}function ls(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:Yu(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:Yu(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Lt(n.weightData).byteLength}}function Si(n){const e=[];for(const t of n)e.push(...t.weights);return e}function ay(){const n=t=>{let r=t<<13,s=0;for(;!(r&8388608);)s-=8388608,r<<=1;return r&=-8388609,s+=947912704,r|s},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function uy(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function ly(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function cy(){const n=ay(),e=uy(),t=ly();return r=>{const s=new ArrayBuffer(4*r.length),o=new Uint32Array(s);for(let i=0;i<r.length;i++){const a=r[i],u=n[t[a>>10]+(a&1023)]+e[a>>10];o[i]=u}return new Float32Array(s)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Re{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return Re.instance==null&&(Re.instance=new Re),Re.instance}static registerSaveRouter(e){Re.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Re.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Re.getHandlers(e,"save")}static getLoadHandlers(e,t){return Re.getHandlers(e,"load",t)}static getHandlers(e,t,r){const s=[];return(t==="load"?Re.getInstance().loadRouters:Re.getInstance().saveRouters).forEach(i=>{const a=i(e,r);a!==null&&s.push(a)}),s}}const hy=n=>Re.registerSaveRouter(n),dy=n=>Re.registerLoadRouter(n),py=n=>Re.getSaveHandlers(n),fy=(n,e)=>Re.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ci="tensorflowjs",Ii=1,Ln="models_store",mn="model_info_store";function Zd(){if(!oe().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function ki(n){const e=n.result;e.createObjectStore(Ln,{keyPath:"modelPath"}),e.createObjectStore(mn,{keyPath:"modelPath"})}class qn{constructor(e){if(this.indexedDB=Zd(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((r,s)=>{const o=this.indexedDB.open(Ci,Ii);o.onupgradeneeded=()=>ki(o),o.onsuccess=()=>{const i=o.result;if(t==null){const a=i.transaction(Ln,"readonly"),l=a.objectStore(Ln).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return i.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(l.result.modelArtifacts)},l.onerror=h=>(i.close(),s(l.error)),a.oncomplete=()=>i.close()}else{t.weightData=Lt.join(t.weightData);const a=ls(t),u=i.transaction(mn,"readwrite");let l=u.objectStore(mn),h;try{h=l.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(d){return s(d)}let c;h.onsuccess=()=>{c=i.transaction(Ln,"readwrite");const d=c.objectStore(Ln);let f;try{f=d.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(m){return s(m)}f.onsuccess=()=>r({modelArtifactsInfo:a}),f.onerror=m=>{l=u.objectStore(mn);const x=l.delete(this.modelPath);x.onsuccess=()=>(i.close(),s(f.error)),x.onerror=b=>(i.close(),s(f.error))}},h.onerror=d=>(i.close(),s(h.error)),u.oncomplete=()=>{c==null?i.close():c.oncomplete=()=>i.close()}}},o.onerror=i=>s(o.error)})}}qn.URL_SCHEME="indexeddb://";const Jd=n=>oe().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(qn.URL_SCHEME)?my(n.slice(qn.URL_SCHEME.length)):null;Re.registerSaveRouter(Jd);Re.registerLoadRouter(Jd);function my(n){return new qn(n)}function gy(n){return n.startsWith(qn.URL_SCHEME)?n.slice(qn.URL_SCHEME.length):n}class yy{constructor(){this.indexedDB=Zd()}async listModels(){return new Promise((e,t)=>{const r=this.indexedDB.open(Ci,Ii);r.onupgradeneeded=()=>ki(r),r.onsuccess=()=>{const s=r.result,o=s.transaction(mn,"readonly"),a=o.objectStore(mn).getAll();a.onsuccess=()=>{const u={};for(const l of a.result)u[l.modelPath]=l.modelArtifactsInfo;e(u)},a.onerror=u=>(s.close(),t(a.error)),o.oncomplete=()=>s.close()},r.onerror=s=>t(r.error)})}async removeModel(e){return e=gy(e),new Promise((t,r)=>{const s=this.indexedDB.open(Ci,Ii);s.onupgradeneeded=()=>ki(s),s.onsuccess=()=>{const o=s.result,i=o.transaction(mn,"readwrite"),a=i.objectStore(mn),u=a.get(e);let l;u.onsuccess=()=>{if(u.result==null)return o.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const h=a.delete(e),c=()=>{l=o.transaction(Ln,"readwrite");const f=l.objectStore(Ln).delete(e);f.onsuccess=()=>t(u.result.modelArtifactsInfo),f.onerror=m=>r(u.error)};h.onsuccess=c,h.onerror=d=>(c(),o.close(),r(u.error))}},u.onerror=h=>(o.close(),r(u.error)),i.oncomplete=()=>{l==null?o.close():l.oncomplete=()=>o.close()}},s.onerror=o=>r(s.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rn="/",pr="tensorflowjs_models",ep="info",by="model_topology",wy="weight_specs",xy="weight_data",vy="model_metadata";function tp(n){return{info:[pr,n,ep].join(rn),topology:[pr,n,by].join(rn),weightSpecs:[pr,n,wy].join(rn),weightData:[pr,n,xy].join(rn),modelMetadata:[pr,n,vy].join(rn)}}function np(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function Sy(n){const e=n.split(rn);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(rn)}function Cy(n){return n.startsWith(Kn.URL_SCHEME)?n.slice(Kn.URL_SCHEME.length):n}class Kn{constructor(e){if(!oe().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=tp(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),s=ls(e),o=Lt.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,sy(o));const i={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:s}}catch{throw np(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=r;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=s;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const a=JSON.parse(o);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.initializerSignature!=null&&(t.initializerSignature=a.initializerSignature),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(i==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=oy(i),t}}Kn.URL_SCHEME="localstorage://";const rp=n=>oe().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Kn.URL_SCHEME)?Iy(n.slice(Kn.URL_SCHEME.length)):null;Re.registerSaveRouter(rp);Re.registerLoadRouter(rp);function Iy(n){return new Kn(n)}class ky{constructor(){I(oe().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),I(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=pr+rn,r=rn+ep;for(let s=0;s<this.LS.length;++s){const o=this.LS.key(s);if(o.startsWith(t)&&o.endsWith(r)){const i=Sy(o);e[i]=JSON.parse(this.LS.getItem(o))}}return e}async removeModel(e){e=Cy(e);const t=tp(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(t.info));return np(t),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gr="://";class Je{constructor(){this.managers={}}static getInstance(){return Je.instance==null&&(Je.instance=new Je),Je.instance}static registerManager(e,t){I(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(gr)&&(e=e.slice(0,e.indexOf(gr))),I(e.length>0,()=>"scheme must not be an empty string.");const r=Je.getInstance();I(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){const t=Je.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(Je.getInstance().managers)}}function Fs(n){if(n.indexOf(gr)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${Je.getSchemes().join(",")}`);return{scheme:n.split(gr)[0],path:n.split(gr)[1]}}async function sp(n,e,t=!1){I(n!==e,()=>`Old path and new path are the same: '${n}'`);const r=Re.getLoadHandlers(n);I(r.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),I(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${n}.`);const s=r[0],o=Re.getSaveHandlers(e);I(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),I(o.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const i=o[0],a=Fs(n).scheme,u=Fs(n).path,l=a===Fs(n).scheme,h=await s.load();t&&l&&await Je.getManager(a).removeModel(u);const c=await i.save(h);return t&&!l&&await Je.getManager(a).removeModel(u),c.modelArtifactsInfo}async function Ny(){const n=Je.getSchemes(),e={};for(const t of n){const r=await Je.getManager(t).listModels();for(const s in r){const o=t+gr+s;e[o]=r[s]}}return e}async function $y(n){const e=Fs(n);return Je.getManager(e.scheme).removeModel(e.path)}async function Ty(n,e){return sp(n,e,!1)}async function Ey(n,e){return sp(n,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _y{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!oe().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const s=this.functionRefs[r.data.index];s(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return Ed(e)}}if(oe().get("IS_BROWSER")){oe().setPlatform("browser",new _y);try{Je.registerManager(Kn.URL_SCHEME,new ky)}catch{}try{Je.registerManager(qn.URL_SCHEME,new yy)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ay={importFetch:()=>require("node-fetch")};let Qo;class Ry{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return oe().global.fetch!=null?oe().global.fetch(e,t):(Qo==null&&(Qo=Ay.importFetch()),Qo(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}oe().get("IS_NODE")&&!oe().get("IS_BROWSER")&&oe().setPlatform("node",new Ry);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ee(n,e="float32",t){return e=e||"float32",wt(n),new vr(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dy(n,e){const t=C(n,"x","cast");if(!Lm(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:t},s={dtype:e};return D.runKernel(Yi,r,s)}const Pe=A({cast_:Dy});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Py(n){const t={x:C(n,"x","clone","string_or_numeric")};return D.runKernel(Qi,t)}const yn=A({clone_:Py});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function op(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */Gd();const Oy={buffer:Ee,cast:Pe,clone:yn,print:op};Mg(Oy);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fy(n,e){let t=C(n,"a","add"),r=C(e,"b","add");[t,r]=Oe(t,r);const s={a:t,b:r};return D.runKernel(Xi,s)}const ie=A({add_:Fy});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zy(n,e){let t=C(n,"a","floorDiv"),r=C(e,"b","floorDiv");[t,r]=Oe(t,r);const s={a:t,b:r};return D.runKernel(Xc,s)}const ip=A({floorDiv_:zy});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ly(n,e){let t=C(n,"a","div"),r=C(e,"b","div");if([t,r]=Oe(t,r),t.dtype==="int32"&&r.dtype==="int32")return ip(t,r);const s={a:t,b:r},o={};return D.runKernel(zc,s,o)}const ye=A({div_:Ly});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function By(n,e){let t=C(n,"a","mul"),r=C(e,"b","mul");[t,r]=Oe(t,r);const s={a:t,b:r};return D.runKernel($h,s)}const q=A({mul_:By});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function My(n){const e=C(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return D.runKernel(bc,t)}else{const t={x:e};return D.runKernel(Yl,t)}}const gt=A({abs_:My});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vy(n){const t={x:C(n,"x","acos")};return D.runKernel(Ql,t)}const Wy=A({acos_:Vy});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uy(n){const t={x:C(n,"x","acosh")};return D.runKernel(Zl,t)}const Gy=A({acosh_:Uy});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hy(n){I(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),I(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((s,o)=>C(s,`tensors${o}`,"addN")),t=e[0];e.forEach(s=>{if(s.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(s=>{if(!ot(s.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return D.runKernel(Jl,r)}const jy=A({addN_:Hy});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qy(n,e=null,t=!1){const s={x:C(n,"x","all","bool")},o={axis:e,keepDims:t};return D.runKernel(ec,s,o)}const Ky=A({all_:qy});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xy(n,e=null,t=!1){const s={x:C(n,"x","any","bool")},o={axis:e,keepDims:t};return D.runKernel(tc,s,o)}const Yy=A({any_:Xy});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qy(n,e=0){const r={x:C(n,"x","argMax")},s={axis:e};return D.runKernel(nc,r,s)}const Zy=A({argMax_:Qy});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jy(n,e=0){const r={x:C(n,"x","argMin")},s={axis:e};return D.runKernel(rc,r,s)}const e0=A({argMin_:Jy});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t0(n){const t={x:C(n,"x","asin")};return D.runKernel(sc,t)}const n0=A({asin_:t0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r0(n){const t={x:C(n,"x","asinh")};return D.runKernel(oc,t)}const s0=A({asinh_:r0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o0(n){const t={x:C(n,"x","atan")};return D.runKernel(ic,t)}const i0=A({atan_:o0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a0(n,e){let t=C(n,"a","atan2"),r=C(e,"b","atan2");[t,r]=Oe(t,r);const s={a:t,b:r};return D.runKernel(uc,s)}const u0=A({atan2_:a0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l0(n){const t={x:C(n,"x","atanh")};return D.runKernel(ac,t)}const c0=A({atanh_:l0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function na(n,e,t,r,s="NHWC",o){const i=n[3],a=[...e,i],u=$r(s);return Et(n,a,t,o,r,null,null,u)}function Nr(n,e,t,r,s,o,i="channelsLast"){const[a,u]=Qr(e);let l;if(i==="channelsLast")l=[a,u,n[3],n[3]];else if(i==="channelsFirst")l=[a,u,n[1],n[1]];else throw new Error(`Unknown dataFormat ${i}`);return Et(n,l,t,r,s,o,!1,i)}function lo(n,e,t,r,s,o,i="NDHWC"){const[a,u,l]=Ni(e);let h,c;if(i==="NDHWC")c="channelsLast",h=[a,u,l,n[4],n[4]];else if(i==="NCDHW")c="channelsFirst",h=[a,u,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${i}`);return co(n,h,t,r,s,!1,c,o)}function Et(n,e,t,r,s,o,i=!1,a="channelsLast"){let[u,l,h,c]=[-1,-1,-1,-1];if(a==="channelsLast")[u,l,h,c]=n;else if(a==="channelsFirst")[u,c,l,h]=n;else throw new Error(`Unknown dataFormat ${a}`);const[d,f,,m]=e,[x,b]=Qr(t),[v,k]=Qr(r),$=yr(d,v),N=yr(f,k),{padInfo:R,outHeight:O,outWidth:F}=p0(s,l,h,x,b,$,N,o,a),B=i?m*c:m;let L;return a==="channelsFirst"?L=[u,B,O,F]:a==="channelsLast"&&(L=[u,O,F,B]),{batchSize:u,dataFormat:a,inHeight:l,inWidth:h,inChannels:c,outHeight:O,outWidth:F,outChannels:B,padInfo:R,strideHeight:x,strideWidth:b,filterHeight:d,filterWidth:f,effectiveFilterHeight:$,effectiveFilterWidth:N,dilationHeight:v,dilationWidth:k,inShape:n,outShape:L,filterShape:e}}function co(n,e,t,r,s,o=!1,i="channelsLast",a){let[u,l,h,c,d]=[-1,-1,-1,-1,-1];if(i==="channelsLast")[u,l,h,c,d]=n;else if(i==="channelsFirst")[u,d,l,h,c]=n;else throw new Error(`Unknown dataFormat ${i}`);const[f,m,x,,b]=e,[v,k,$]=Ni(t),[N,R,O]=Ni(r),F=yr(f,N),B=yr(m,R),L=yr(x,O),{padInfo:W,outDepth:V,outHeight:ee,outWidth:J}=f0(s,l,h,c,v,k,$,F,B,L,a),ne=o?b*d:b;let re;return i==="channelsFirst"?re=[u,ne,V,ee,J]:i==="channelsLast"&&(re=[u,V,ee,J,ne]),{batchSize:u,dataFormat:i,inDepth:l,inHeight:h,inWidth:c,inChannels:d,outDepth:V,outHeight:ee,outWidth:J,outChannels:ne,padInfo:W,strideDepth:v,strideHeight:k,strideWidth:$,filterDepth:f,filterHeight:m,filterWidth:x,effectiveFilterDepth:F,effectiveFilterHeight:B,effectiveFilterWidth:L,dilationDepth:N,dilationHeight:R,dilationWidth:O,inShape:n,outShape:re,filterShape:e}}function h0(n,e,t,r,s){r==null&&(r=ap(n,e,t));const o=n[0],i=n[1],a=Zr((o-e+2*r)/t+1,s),u=Zr((i-e+2*r)/t+1,s);return[a,u]}function d0(n,e,t,r,s,o){s==null&&(s=ap(n,e[0],r[0]));const i=[0,0,0,t];for(let a=0;a<3;a++)n[a]+2*s>=e[a]&&(i[a]=Zr((n[a]-e[a]+2*s)/r[a]+1,o));return i}function ap(n,e,t,r=1){const s=yr(e,r);return Math.floor((n[0]*(t-1)-t+s)/2)}function Qr(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function Ni(n){return typeof n=="number"?[n,n,n]:n}function yr(n,e){return e<=1?n:n+(n-1)*(e-1)}function p0(n,e,t,r,s,o,i,a,u){let l,h,c;if(typeof n=="number"){l={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const f=h0([e,t],o,r,n,a);h=f[0],c=f[1]}else if(n==="same"){h=Math.ceil(e/r),c=Math.ceil(t/s);const d=Math.max(0,(h-1)*r+o-e),f=Math.max(0,(c-1)*s+i-t),m=Math.floor(d/2),x=d-m,b=Math.floor(f/2),v=f-b;l={top:m,bottom:x,left:b,right:v,type:"SAME"}}else if(n==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},h=Math.ceil((e-o+1)/r),c=Math.ceil((t-i+1)/s);else if(typeof n=="object"){const d=u==="channelsLast"?n[1][0]:n[2][0],f=u==="channelsLast"?n[1][1]:n[2][1],m=u==="channelsLast"?n[2][0]:n[3][0],x=u==="channelsLast"?n[2][1]:n[3][1];l={top:d,bottom:f,left:m,right:x,type:d===0&&f===0&&m===0&&x===0?"VALID":"EXPLICIT"},h=Zr((e-o+d+f)/r+1,a),c=Zr((t-i+m+x)/s+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:l,outHeight:h,outWidth:c}}function f0(n,e,t,r,s,o,i,a,u,l,h){let c,d,f,m;if(n==="valid"&&(n=0),typeof n=="number"){c={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const b=d0([e,t,r,1],[a,u,l],1,[s,o,i],n,h);d=b[0],f=b[1],m=b[2]}else if(n==="same"){d=Math.ceil(e/s),f=Math.ceil(t/o),m=Math.ceil(r/i);const x=(d-1)*s+a-e,b=(f-1)*o+u-t,v=(m-1)*i+l-r,k=Math.floor(x/2),$=x-k,N=Math.floor(b/2),R=b-N,O=Math.floor(v/2),F=v-O;c={top:N,bottom:R,left:O,right:F,front:k,back:$,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outDepth:d,outHeight:f,outWidth:m}}function Zr(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function Gs(n){const[e,t,r]=Qr(n);return e===1&&t===1&&r===1}function Zt(n,e){return Gs(n)||Gs(e)}function Cr(n){return Qr(n).every(e=>e>0)}function $r(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function Bt(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")I(Yr(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(s=>{I(Yr(s),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${s}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m0(n,e){const r={x:C(n,"x","reshape","string_or_numeric")},s={shape:e};return D.runKernel(Uh,r,s)}const M=A({reshape_:m0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g0(n,e,t,r,s){const o=C(n,"x","avgPool","float32"),i=1;I(Zt(t,i),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);let a=o,u=!1;o.rank===3&&(u=!0,a=M(o,[1,o.shape[0],o.shape[1],o.shape[2]])),I(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),Bt("avgPool",r,s);const l={x:a},h={filterSize:e,strides:t,pad:r,dimRoundingMode:s};let c=D.runKernel(lc,l,h);return c=Pe(c,o.dtype),u?M(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const up=A({avgPool_:g0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y0(n,e,t,r,s,o="NDHWC"){const i=C(n,"x","avgPool3d","float32");let a=i,u=!1;i.rank===4&&(u=!0,a=M(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),I(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),I(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),I(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),Bt("avgPool3d",r,s);const l={x:a},h={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:o};let c=D.runKernel(cc,l,h);return c=Pe(c,a.dtype),u?M(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}const b0=A({avgPool3d_:y0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w0(n,e=0){I(n.length>=1,()=>"Pass at least one tensor to concat");const t=Us(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),t.length===1)return yn(t[0]);const r=t,s={axis:e};return D.runKernel(wc,r,s)}const je=A({concat_:w0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x0(n,e,t=!1,r=!1){let s=C(n,"a","matMul"),o=C(e,"b","matMul");[s,o]=Oe(s,o);const i={a:s,b:o},a={transposeA:t,transposeB:r};return D.runKernel(hc,i,a)}const Se=A({matMul_:x0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v0(n){const t={x:C(n,"x","sigmoid","float32")};return D.runKernel(od,t)}const Vn=A({sigmoid_:v0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S0(n,e,t){const r=C(n,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const s={x:r},o={begin:e,size:t};return D.runKernel(td,s,o)}const pe=A({slice_:S0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C0(n){const t={x:C(n,"x","tanh","float32")};return D.runKernel(xd,t)}const $i=A({tanh_:C0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I0(n,e,t,r,s,o){const i=C(n,"forgetBias","basicLSTMCell"),a=C(e,"lstmKernel","basicLSTMCell"),u=C(t,"lstmBias","basicLSTMCell"),l=C(r,"data","basicLSTMCell"),h=C(s,"c","basicLSTMCell"),c=C(o,"h","basicLSTMCell"),d=je([l,c],1),f=Se(d,a),m=ie(f,u),x=m.shape[0],b=m.shape[1]/4,v=[x,b],k=pe(m,[0,0],v),$=pe(m,[0,b],v),N=pe(m,[0,b*2],v),R=pe(m,[0,b*3],v),O=ie(q(Vn(k),$i($)),q(h,Vn(ie(i,N)))),F=q($i(O),Vn(R));return[O,F]}const k0=A({basicLSTMCell_:I0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N0(n,e,t){const r=C(n,"x","batchToSpaceND"),s=e.reduce((a,u)=>a*u);I(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),I(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),I(r.shape[0]%s===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${s}`);const o={x:r},i={blockShape:e,crops:t};return D.runKernel(dc,o,i)}const lp=A({batchToSpaceND_:N0});function $0(n){let e;return n.rank===0||n.rank===1?e=M(n,[1,1,1,n.size]):n.rank===2?e=M(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=M(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T0(n,e,t,r,s,o){o==null&&(o=.001);const i=C(n,"x","batchNorm"),a=C(e,"mean","batchNorm"),u=C(t,"variance","batchNorm");let l;s!=null&&(l=C(s,"scale","batchNorm"));let h;r!=null&&(h=C(r,"offset","batchNorm")),I(a.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),I(h==null||a.rank===h.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),I(l==null||a.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:$0(i),scale:l,offset:h,mean:a,variance:u},f={varianceEpsilon:o},m=D.runKernel(Yc,d,f);return M(m,i.shape)}const ho=A({batchNorm_:T0});function E0(n,e,t,r,s,o){const i=C(n,"x","batchNorm"),a=C(e,"mean","batchNorm"),u=C(t,"variance","batchNorm");let l;s!=null&&(l=C(s,"scale","batchNorm"));let h;return r!=null&&(h=C(r,"offset","batchNorm")),I(i.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${i.rank}.`),I(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),I(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),l!=null&&I(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),h!=null&&I(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${h.rank}.`),ho(i,a,u,h,l,o)}const _0=A({batchNorm2d_:E0});function A0(n,e,t,r,s,o){const i=C(n,"x","batchNorm"),a=C(e,"mean","batchNorm"),u=C(t,"variance","batchNorm");let l;s!=null&&(l=C(s,"scale","batchNorm"));let h;return r!=null&&(h=C(r,"offset","batchNorm")),I(i.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${i.rank}.`),I(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),I(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),l!=null&&I(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),h!=null&&I(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${h.rank}.`),ho(i,a,u,h,l,o)}const R0=A({batchNorm3d_:A0});function D0(n,e,t,r,s,o){const i=C(n,"x","batchNorm"),a=C(e,"mean","batchNorm"),u=C(t,"variance","batchNorm");let l;s!=null&&(l=C(s,"scale","batchNorm"));let h;return r!=null&&(h=C(r,"offset","batchNorm")),I(i.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${i.rank}.`),I(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),I(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),l!=null&&I(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),h!=null&&I(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${h.rank}.`),ho(i,a,u,h,l,o)}const P0=A({batchNorm4d_:D0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O0(n,e,t){const r=C(n,"x","bincount"),s=C(e,"weights","bincount");I(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),I(t>=0,()=>`size must be non-negative, but got ${t}.`),I(s.size===r.size||s.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${s.shape}.`);const o={x:r,weights:s},i={size:t};return D.runKernel(pc,o,i)}const cp=A({bincount_:O0});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F0(n,e){const t=C(n,"x","bitwiseAnd"),r=C(e,"y","bitwiseAnd");if(!ot(t.shape,r.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${r.shape}`);if(t.dtype!=="int32"||r.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${r.dtype}`);const s={a:t,b:r};return D.runKernel(Qm,s)}const z0=A({bitwiseAnd_:F0});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L0(n,e){const t=C(n,"s0","broadcastArgs","int32"),r=C(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const s={s0:t,s1:r};return D.runKernel(fc,s)}const B0=A({broadcastArgs_:L0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M0(n,e){let t=C(n,"broadcastTo","x");const r=t.shape;if(wt(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const l=t.shape.slice();for(;l.length<e.length;)l.unshift(1);t=M(t,l)}const s=t.shape,o=Array.from(e);for(let l=e.length-1;l>=0;l--)if(s[l]===e[l])o[l]=1;else if(t.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(o.map((l,h)=>l>1?h:-1).filter(l=>l>=0).length===0)return yn(t);const a={x:t},u={reps:o};return D.runKernel(Zi,a,u)}const qr=A({broadcastTo_:M0});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V0(n){const t={x:C(n,"x","ceil","float32")};return D.runKernel(mc,t)}const W0=A({ceil_:V0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cs(n,e,t){wt(n),t=t||us(e);const r={shape:n,value:e,dtype:t};return D.runKernel(jc,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U0(n,e,t){const r=C(n,"x","clipByValue");if(I(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return cs(r.shape,e,r.dtype);const s={x:r},o={clipValueMin:e,clipValueMax:t};return D.runKernel(gc,s,o)}const hp=A({clipByValue_:U0});function G0(n){return je(n,0)}const H0=A({concat1d_:G0});function j0(n,e){return je(n,e)}const q0=A({concat2d_:j0});function K0(n,e){return je(n,e)}const X0=A({concat3d_:K0});function Y0(n,e){return je(n,e)}const Q0=A({concat4d_:Y0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z0(n,e,t,r,s="NHWC",o=[1,1],i){const a=C(n,"x","conv2d","float32"),u=C(e,"filter","conv2d","float32");let l=a,h=!1;a.rank===3&&(h=!0,l=M(a,[1,a.shape[0],a.shape[1],a.shape[2]])),I(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),I(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),Bt("conv2d",r,i);const c=s==="NHWC"?l.shape[3]:l.shape[1];I(c===u.shape[2],()=>`Error in conv2d: depth of input (${c}) must match input depth for filter ${u.shape[2]}.`),I(Zt(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),I(Cr(o),()=>"Error in conv2D: Dilated rates should be larger than 0."),I(Cr(t),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:l,filter:u},f={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i},m=D.runKernel(xc,d,f);return h?M(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const po=A({conv2d_:Z0});function J0(n,e,t,r,s="NWC",o=1,i){const a=C(n,"x","conv1d"),u=C(e,"filter","conv1d");let l=a,h=!1;a.rank===2&&(h=!0,l=M(a,[1,a.shape[0],a.shape[1]])),I(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),I(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),Bt("conv1d",r,i),I(l.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${u.shape[1]}.`),I(Zt(t,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${o}'`),I(Cr(o),()=>"Error in conv1D: Dilated rates should be larger than 0."),I(Cr(t),()=>"Error in conv1D: Stride should be larger than 0."),I(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);const c=M(u,[1,u.shape[0],u.shape[1],u.shape[2]]),d=M(l,[l.shape[0],1,l.shape[1],l.shape[2]]),b=po(d,c,[1,t],r,"NHWC",[1,o],i);return h?M(b,[b.shape[2],b.shape[3]]):M(b,[b.shape[0],b.shape[2],b.shape[3]])}const eb=A({conv1d_:J0});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tb(n,e,t,r,s,o="NHWC",i){I(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,u=e,l=!1;e.rank===3&&(l=!0,u=M(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),I(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),I(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),I(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const h=o==="NHWC"?a[3]:a[1],c=o==="NHWC"?u.shape[3]:u.shape[1];I(h===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${h}) must match input depth for filter ${t.shape[2]}.`),I(c===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${c}) must match output depth for filter ${t.shape[3]}.`),Bt("conv2dDerInput",s,i);const d={dy:u,filter:t},f={strides:r,pad:s,dataFormat:o,dimRoundingMode:i,inputShape:a},m=D.runKernel(Sc,d,f);return l?M(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const dp=A({conv2DBackpropInput_:tb});function nb(n,e,t,r,s,o){const i=C(n,"x","conv2dTranspose"),a=C(e,"filter","conv2dTranspose");return dp(t,i,a,r,s,"NHWC",o)}const rb=A({conv2dTranspose_:nb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sb(n,e,t,r,s="NDHWC",o=[1,1,1]){const i=C(n,"x","conv3d"),a=C(e,"filter","conv3d");let u=i,l=!1;i.rank===4&&(l=!0,u=M(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),I(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),I(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),I(u.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${a.shape[3]}.`),I(Zt(t,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),I(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`),I(Cr(o),()=>"Error in conv3D: Dilated rates should be larger than 0."),I(Cr(t),()=>"Error in conv3D: Strides should be larger than 0.");const h={x:u,filter:a},c={strides:t,pad:r,dataFormat:s,dilations:o},d=D.runKernel(Cc,h,c);return l?M(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const ob=A({conv3d_:sb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ib(n,e,t,r,s){I(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let o=n,i=e,a=!1;e.rank===4&&(a=!0,i=M(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),o=[1,n[0],n[1],n[2],n[3]]);const u=o[4],l=i.shape[4];I(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),I(i.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${i.rank}`),I(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),I(u===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[3]}.`),I(l===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${t.shape[4]}.`);const h={dy:i,filter:t},c={pad:s,strides:r,inputShape:o},d=D.runKernel(Ic,h,c);return a?M(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const ab=A({conv3DBackpropInput_:ib});function ub(n,e,t,r,s){const o=C(n,"x","conv3dTranspose"),i=C(e,"filter","conv3dTranspose");return ab(t,o,i,r,s)}const lb=A({conv3dTranspose_:ub});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cb(n){const t={x:C(n,"x","cos","float32")};return D.runKernel(kc,t)}const hb=A({cos_:cb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function db(n){const t={x:C(n,"x","cosh","float32")};return D.runKernel(Nc,t)}const pb=A({cosh_:db});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fb(n,e=0,t=!1,r=!1){const o={x:C(n,"x","cumprod")},i={axis:e,exclusive:t,reverse:r};return D.runKernel($c,o,i)}const mb=A({cumprod_:fb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gb(n,e=0,t=!1,r=!1){const o={x:C(n,"x","cumsum")},i={axis:e,exclusive:t,reverse:r};return D.runKernel(Tc,o,i)}const yb=A({cumsum_:gb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bb(n,e,t,r=!1){const s=C(n,"x","denseBincount"),o=C(e,"weights","denseBincount");I(s.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${s.dtype}`),I(s.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${s.rank}.`),I(t>=0,()=>`size must be non-negative, but got ${t}.`),I(o.size===s.size||o.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${s.shape}, weights shape: ${o.shape}.`);const i={x:s,weights:o},a={size:t,binaryOutput:r};return D.runKernel(_c,i,a)}const wb=A({denseBincount_:bb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xb(n,e,t="NHWC"){const r=C(n,"x","depthToSpace","float32"),s=t==="NHWC"?r.shape[1]:r.shape[2],o=t==="NHWC"?r.shape[2]:r.shape[3],i=t==="NHWC"?r.shape[3]:r.shape[1];I(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),I(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e}  for depthToSpace with input shape
    ${r.shape}`),I(o*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${e} for depthToSpace with input shape
        ${r.shape}`),I(i%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${i} for depthToSpace with input shape ${r.shape}`);const a={x:r},u={blockSize:e,dataFormat:t};return D.runKernel(Ac,a,u)}const vb=A({depthToSpace_:xb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sb(n,e,t,r,s="NHWC",o=[1,1],i){const a=C(n,"x","depthwiseConv2d","float32"),u=C(e,"filter","depthwiseConv2d","float32");let l=a,h=!1;a.rank===3&&(h=!0,l=M(a,[1,a.shape[0],a.shape[1],a.shape[2]])),I(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),I(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`);const c=s==="NHWC"?l.shape[3]:l.shape[1];I(c===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${c}) must match the inChannels dimension in filter ${u.shape[2]}.`),Bt("depthwiseConv2d",r,i);const d={x:l,filter:u},f={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i},m=D.runKernel(Rc,d,f);return h?M(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const ra=A({depthwiseConv2d_:Sb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cb(n){const t={x:C(n,"x","diag")};return D.runKernel(Oc,t)}const Ib=A({diag_:Cb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kb(n,e,t,r,s=[1,1],o="NHWC"){const i=C(n,"x","dilation2d"),a=C(e,"filter","dilation2d");I(i.rank===3||i.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${i.rank}.`),I(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),I(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let u=i,l=!1;i.rank===3&&(u=M(i,[1,i.shape[0],i.shape[1],i.shape[2]]),l=!0),I(u.shape[3]===a.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${u.shape[3]} vs ${a.shape[2]}`);const h={x:u,filter:a},c={strides:t,pad:r,dilations:s},d=D.runKernel(Fc,h,c);return l?M(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Nb=A({dilation2d_:kb});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hs(n,e){const t=n.length,r=[];for(let s=0;s<t;s++){const o=t-1-s,i=n[o]||1;(e[e.length-1-s]||1)>1&&i===1&&r.unshift(o)}return r}function $b(n,e){const t=[];for(let r=0;r<e.length;r++){const s=n[n.length-r-1],o=e.length-r-1,i=e[o];(s==null||s===1&&i>1)&&t.unshift(o)}return t}function Ce(n,e){const t=Math.max(n.length,e.length),r=new Array(t);for(let s=0;s<t;s++){let o=n[n.length-s-1];o==null&&(o=1);let i=e[e.length-s-1];if(i==null&&(i=1),o===1)r[t-s-1]=i;else if(i===1)r[t-s-1]=o;else if(o!==i){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else r[t-s-1]=o}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tb(n,e){let t=C(n,"a","equal","string_or_numeric"),r=C(e,"b","equal","string_or_numeric");[t,r]=Oe(t,r),Ce(t.shape,r.shape);const s={a:t,b:r};return D.runKernel(Vc,s)}const pp=A({equal_:Tb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eb(n,e,t){const r=C(e,"a","where"),s=C(t,"b","where"),o=C(n,"condition","where","bool"),i=Ce(Ce(o.shape,r.shape),s.shape),a=qr(o,i),u=qr(r,i),l=qr(s,i),h={condition:a,t:u,e:l};return D.runKernel(Jh,h)}const bn=A({where_:Eb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _b(n){const t={x:C(n,"x","zerosLike")};return D.runKernel(kd,t)}const yt=A({zerosLike_:_b});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ab(n,e){let t=C(n,"a","div"),r=C(e,"b","div");[t,r]=Oe(t,r);const s=ye(t,r),o=yt(s),i=pp(r,o);return bn(i,o,s)}const Rb=A({divNoNan_:Ab});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Db(n,e){const t=C(n,"t1","dot"),r=C(e,"t2","dot");I((t.rank===1||t.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${r.rank}.`);const s=t.rank===1?t.size:t.shape[1],o=r.rank===1?r.size:r.shape[0];if(I(s===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${o}.`),t.rank===1&&r.rank===1){const i=M(t,[1,-1]),a=M(r,[-1,1]),u=Se(i,a);return M(u,[])}else if(t.rank===1&&r.rank===2){const i=M(t,[1,-1]),a=M(r,[r.shape[0],r.shape[1]]),u=Se(i,a);return M(u,[u.size])}else if(t.rank===2&&r.rank===1){const i=M(r,[-1,1]),a=Se(t,i);return M(a,[a.size])}else{const i=M(r,[r.shape[0],r.shape[1]]);return Se(t,i)}}const Pb=A({dot_:Db});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ob(n,...e){const t=e.map((s,o)=>C(s,`tensors${o}`,"einsum")),r={equation:n};return D.runKernel(Lc,t,r)}const fr=A({einsum_:Ob});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fb(n){const t={x:C(n,"x","elu","float32")};return D.runKernel(Bc,t)}const fp=A({elu_:Fb});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zb(n,e){const t=C(n,"x","ensureShape","string_or_numeric");if(!Pm(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return n}const Lb=A({ensureShape_:zb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bb(n){let e=C(n,"x","erf");I(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Pe(e,"float32"));const t={x:e};return D.runKernel(Mc,t)}const Mb=A({erf_:Bb});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mp(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function Vb(n,e,t){const r=n.length+e.length,s=[];let o=0,i=0;for(let a=0;a<r;a++)t.indexOf(a)===-1?s.push(n[o++]):s.push(e[i++]);return s}function fo(n,e){const t=[],r=n.length;for(let o=0;o<r;o++)e.indexOf(o)===-1&&t.push(n[o]);const s=e.map(o=>n[o]);return[t,s]}function hs(n,e){const t=e.map(r=>1);return Vb(n,t,e)}function sa(n,e,t){I(mp(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function ds(n,e){if(mp(n,e))return null;const t=[];for(let r=0;r<e;++r)n.indexOf(r)===-1&&t.push(r);return n.forEach(r=>t.push(r)),t}function gp(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function ps(n,e){const t=[];for(let r=e-n;r<e;++r)t.push(r);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wb(n,e=null,t=!1){const s={x:C(n,"x","max")},o={reductionIndices:e,keepDims:t};return D.runKernel(gh,s,o)}const br=A({max_:Wb});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ub(n,e=null,t=!1){const s={x:C(n,"x","min")},o={axis:e,keepDims:t};return D.runKernel(Sh,s,o)}const Ti=A({min_:Ub});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gb(n,e){let t=C(n,"base","pow"),r=C(e,"exp","pow");[t,r]=Oe(t,r);const s={a:t,b:r};return D.runKernel(Fh,s)}const Jr=A({pow_:Gb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function we(n,e){if(($t(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&$t(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return In(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hb(n){const t={x:C(n,"x","sqrt","float32")};return D.runKernel(ad,t)}const an=A({sqrt_:Hb});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jb(n){const e=C(n,"x","square"),t={};return D.runKernel("Square",{x:e},t)}const Pt=A({square_:jb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qb(n,e=null,t=!1){let r=C(n,"x","sum");r.dtype==="bool"&&(r=Pe(r,"int32"));const s={x:r},o={axis:e,keepDims:t};return D.runKernel(ud,s,o)}const Ne=A({sum_:qb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kb(n,e="euclidean",t=null,r=!1){n=C(n,"x","norm");const s=yp(n,e,t);let o=s.shape;if(r){const i=Tt(t,n.shape);o=hs(s.shape,i)}return M(s,o)}function yp(n,e,t=null){if(n.rank===0)return gt(n);if(n.rank!==1&&t===null)return yp(M(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Ne(gt(n),t);if(e===1/0)return br(gt(n),t);if(e===-1/0)return Ti(gt(n),t);if(e==="euclidean"||e===2)return an(Ne(Jr(gt(n),we(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return br(Ne(gt(n),t[0]),t[1]-1);if(e===1/0)return br(Ne(gt(n),t[1]),t[0]);if(e===-1/0)return Ti(Ne(gt(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return an(Ne(Pt(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const mo=A({norm_:Kb});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xb(n,e=null,t=!1){return mo(n,"euclidean",e,t)}const Yb=A({euclideanNorm_:Xb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qb(n){const t={x:C(n,"x","exp")};return D.runKernel(Wc,t)}const un=A({exp_:Qb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zb(n,e=0){const t=C(n,"x","expandDims","string_or_numeric");I(e<=t.rank,()=>"Axis must be <= rank of the tensor");const r={input:t},s={dim:e};return D.runKernel(Uc,r,s)}const Ht=A({expandDims_:Zb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jb(n){const t={x:C(n,"x","expm1")};return D.runKernel(Gc,t)}const ew=A({expm1_:Jb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tw(n,e){const t=C(n,"x","tile","string_or_numeric");I(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const r={x:t},s={reps:e};return D.runKernel(Zi,r,s)}const Kr=A({tile_:tw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nw(n,e,t,r="float32"){e==null&&(e=n);const s=Ee([n,e],r),o=n<=e?n:e;for(let a=0;a<o;++a)s.set(1,a,a);const i=M(s.toTensor(),[n,e]);if(t==null)return i;if(t.length===1)return Kr(Ht(i,0),[t[0],1,1]);if(t.length===2)return Kr(Ht(Ht(i,0),0),[t[0],t[1],1,1]);if(t.length===3)return Kr(Ht(Ht(Ht(i,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const bp=A({eye_:nw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rw(n){const t={x:C(n,"x","floor","float32")};return D.runKernel(Kc,t)}const wp=A({floor_:rw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sw(n,e,t=0,r=0){const s=C(n,"x","gather"),o=C(e,"indices","gather","int32"),i={x:s,indices:o},a={axis:t,batchDims:r};return D.runKernel(Qc,i,a)}const xp=A({gather_:sw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ow(n,e){let t=C(n,"a","greater","string_or_numeric"),r=C(e,"b","greater","string_or_numeric");[t,r]=Oe(t,r),Ce(t.shape,r.shape);const s={a:t,b:r};return D.runKernel(Jc,s)}const go=A({greater_:ow});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iw(n,e){let t=C(n,"a","greaterEqual","string_or_numeric"),r=C(e,"b","greaterEqual","string_or_numeric");[t,r]=Oe(t,r),Ce(t.shape,r.shape);const s={a:t,b:r};return D.runKernel(eh,s)}const vp=A({greaterEqual_:iw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aw(n){const t={input:C(n,"input","imag")};return D.runKernel(nh,t)}const yo=A({imag_:aw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uw(n){const t={x:C(n,"x","isFinite")};return D.runKernel(rh,t)}const lw=A({isFinite_:uw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cw(n){const t={x:C(n,"x","isInf")};return D.runKernel(sh,t)}const hw=A({isInf_:cw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dw(n){const t={x:C(n,"x","isNaN")};return D.runKernel(oh,t)}const pw=A({isNaN_:dw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fw(n,e=.2){const r={x:C(n,"x","leakyRelu")},s={alpha:e};return D.runKernel(ih,r,s)}const Sp=A({leakyRelu_:fw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mw(n,e){let t=C(n,"a","less","string_or_numeric"),r=C(e,"b","less","string_or_numeric");[t,r]=Oe(t,r),Ce(t.shape,r.shape);const s={a:t,b:r};return D.runKernel(ah,s)}const Ei=A({less_:mw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gw(n,e){let t=C(n,"a","lessEqual","string_or_numeric"),r=C(e,"b","lessEqual","string_or_numeric");[t,r]=Oe(t,r),Ce(t.shape,r.shape);const s={a:t,b:r};return D.runKernel(uh,s)}const oa=A({lessEqual_:gw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yw(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const r={start:n,stop:e,num:t};return D.runKernel(lh,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bw(n,e=5,t=1,r=1,s=.5){const o=C(n,"x","localResponseNormalization");I(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),I(Yr(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let i=o,a=!1;o.rank===3&&(a=!0,i=M(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const u={x:i},l={depthRadius:e,bias:t,alpha:r,beta:s},h=D.runKernel(mh,u,l);return a?M(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const ww=A({localResponseNormalization_:bw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xw(n){const t={x:C(n,"x","log","float32")};return D.runKernel(ch,t)}const es=A({log_:xw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vw(n){const t={x:C(n,"x","log1p")};return D.runKernel(hh,t)}const Cp=A({log1p_:vw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sw(n,e){I(ui(n),()=>"The f passed in variableGrads(f) must be a function"),I(e==null||Array.isArray(e)&&e.every(l=>l instanceof Ws),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const l in D.registeredVariables)e.push(D.registeredVariables[l])}const r=t?e.filter(l=>!l.trainable):null,s=e.length;e=e.filter(l=>l.trainable),I(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);const o=!0,{value:i,grads:a}=D.gradients(n,e,null,o);I(a.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),I(i.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`);const u={};return e.forEach((l,h)=>{a[h]!=null&&(u[l.name]=a[h])}),r!=null&&r.forEach(l=>u[l.name]=null),{value:i,grads:u}}function ln(n){return D.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cw(n){const t={x:C(n,"x","neg")};return D.runKernel(Th,t)}const Yt=A({neg_:Cw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iw(n){const t={x:C(n,"x","softplus")};return D.runKernel(id,t)}const Ip=A({softplus_:Iw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kw(n){const e=C(n,"x","logSigmoid");return ln(r=>({value:Yt(Ip(Yt(r))),gradFunc:i=>q(i,Vn(Yt(r)))}))(e)}const Nw=A({logSigmoid_:kw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $w(n,e){let t=C(n,"a","sub"),r=C(e,"b","sub");[t,r]=Oe(t,r);const s={a:t,b:r};return D.runKernel(bd,s)}const fe=A({sub_:$w});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tw(n,e=-1){const t=C(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return ln((s,o)=>{const a=br(s,e,!0),u=fe(s,a),l=fe(Pe(u,"float32"),es(Ne(un(u),e,!0)));return o([l]),{value:l,gradFunc:(c,d)=>{const[f]=d,m=!0,x=un(f);return fe(c,q(Ne(c,e,m),x))}}})(t)}const Ew=A({logSoftmax_:Tw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _w(n,e=null,t=!1){const r=C(n,"x","logSumExp"),s=Tt(e,r.shape),o=br(r,s,!0),i=fe(r,o),a=un(i),u=Ne(a,s),l=es(u),h=ie(M(o,l.shape),l);if(t){const c=hs(h.shape,s);return M(h,c)}return h}const kp=A({logSumExp_:_w});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aw(n,e){const t=C(n,"a","logicalAnd","bool"),r=C(e,"b","logicalAnd","bool");Ce(t.shape,r.shape);const s={a:t,b:r};return D.runKernel(dh,s)}const js=A({logicalAnd_:Aw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rw(n){const t={x:C(n,"x","logicalNot","bool")};return D.runKernel(ph,t)}const Np=A({logicalNot_:Rw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dw(n,e){const t=C(n,"a","logicalOr","bool"),r=C(e,"b","logicalOr","bool");Ce(t.shape,r.shape);const s={a:t,b:r};return D.runKernel(fh,s)}const $p=A({logicalOr_:Dw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pw(n,e){const t=C(n,"a","logicalXor","bool"),r=C(e,"b","logicalXor","bool");return Ce(t.shape,r.shape),js($p(n,e),Np(js(n,e)))}const Ow=A({logicalXor_:Pw});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const As=2147483648;function Fw(n,e,t="left"){const r=C(n,"sortedSequence","searchSorted"),s=C(e,"values","searchSorted"),o=r.shape[r.shape.length-1],i=s.shape[s.shape.length-1],a=M(r,[-1,o]),u=M(s,[-1,i]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==u.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(H(u.shape)>=As)throw new Error(`values tensor size must less than ${As}`);if(a.shape[1]>=As)throw new Error(`trailing dim_size must less than ${As} for int32 output type, was ${a.shape[1]}`);const l={sortedSequence:a,values:u},h={side:t};return D.runKernel(Zh,l,h)}const ia=A({searchSorted_:Fw});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zw(n,e){return ia(n,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lw(n,e,t,r,s){const o=C(n,"x","maxPool"),i=1;let a=o,u=!1;o.rank===3&&(u=!0,a=M(o,[1,o.shape[0],o.shape[1],o.shape[2]])),I(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),I(Zt(t,i),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),Bt("maxPool",r,s);const l={x:a},h={filterSize:e,strides:t,pad:r,dimRoundingMode:s},c=D.runKernel(bh,l,h);return u?M(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const Tp=A({maxPool_:Lw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bw(n,e=[1,1,1],t,r,s,o="NDHWC"){const i=C(n,"x","maxPool3d");let a=i,u=!1;i.rank===4&&(u=!0,a=M(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),I(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),I(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),Bt("maxPool3d",r,s);const l={x:a},h={filterSize:e,strides:t,pad:r,dimRoundingMode:s,dataFormat:o},c=D.runKernel(wh,l,h);return u?M(c,[c.shape[1],c.shape[2],c.shape[3],c.shape[4]]):c}const Mw=A({maxPool3d_:Bw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vw(n,e,t,r,s=!1){const i={x:C(n,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:r,includeBatchInIndex:s},u=D.runKernel(xh,i,a);return{result:u[0],indexes:u[1]}}const Ww=A({maxPoolWithArgmax_:Vw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uw(n,e){let t=C(n,"a","maximum"),r=C(e,"b","maximum");[t,r]=Oe(t,r),t.dtype==="bool"&&(t=Pe(t,"int32"),r=Pe(r,"int32")),Ce(t.shape,r.shape);const s={a:t,b:r};return D.runKernel(yh,s)}const Ep=A({maximum_:Uw});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gw(n,e=null,t=!1){const s={x:C(n,"x","mean")},o={axis:e,keepDims:t};return D.runKernel(vh,s,o)}const qs=A({mean_:Gw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xn(n,e="float32"){if(wt(n),e==="complex64"){const r=Xn(n,"float32"),s=Xn(n,"float32");return vn(r,s)}const t=on(H(n),e);return D.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bn(n,e="float32"){if(wt(n),e==="complex64"){const r=Bn(n,"float32"),s=Xn(n,"float32");return vn(r,s)}const t=ql(H(n),e);return D.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hw(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let r=C(n,"x","meshgrid",n instanceof Be?n.dtype:"float32");if(e===void 0)return[r];let s=C(e,"y","meshgrid",e instanceof Be?e.dtype:"float32");const o=H(r.shape),i=H(s.shape);return t==="xy"?(r=M(r,[1,-1]),s=M(s,[-1,1]),[Se(Bn([i,1],r.dtype),r),Se(s,Bn([1,o],s.dtype))]):(r=M(r,[-1,1]),s=M(s,[1,-1]),[Se(r,Bn([1,i],r.dtype)),Se(Bn([o,1],s.dtype),s)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jw(n,e){let t=C(n,"a","minimum"),r=C(e,"b","minimum");[t,r]=Oe(t,r),t.dtype==="bool"&&(t=Pe(t,"int32"),r=Pe(r,"int32")),Ce(t.shape,r.shape);const s={a:t,b:r};return D.runKernel(Ch,s)}const Ks=A({minimum_:jw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qw(n,e,t){I(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const r=C(n,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");I(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const s=t==="reflect"?1:0;for(let a=0;a<r.rank;a++)I(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),I(e[a][0]>=0&&e[a][0]<=r.shape[a]-s&&e[a][1]>=0&&e[a][1]<=r.shape[a]-s,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-s} or less than 0 for input of shape ${r.shape}`);const o={paddings:e,mode:t},i={x:r};return D.runKernel(Ih,i,o)}const Kw=A({mirrorPad_:qw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xw(n,e){let t=C(n,"a","mod"),r=C(e,"b","mod");[t,r]=Oe(t,r);const s={a:t,b:r};return D.runKernel(kh,s)}const Yw=A({mod_:Xw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qw(n,e=null,t=!1){n=C(n,"x","moments");const r=Tt(e,n.shape),s=qs(n,r,t);let o=s.shape;t||(o=hs(s.shape,r));const i=Pt(fe(Pe(n,"float32"),M(s,o))),a=qs(i,r,t);return{mean:s,variance:a}}const Zw=A({moments_:Qw});function Jw(n,e,t,r){const s=C(e,"data","multiRNNCell"),o=Us(t,"c","multiRNNCell"),i=Us(r,"h","multiRNNCell");let a=s;const u=[];for(let c=0;c<n.length;c++){const d=n[c](a,o[c],i[c]);u.push(d[0]),u.push(d[1]),a=d[1]}const l=[],h=[];for(let c=0;c<u.length;c+=2)l.push(u[c]),h.push(u[c+1]);return[l,h]}const e1=A({multiRNNCell_:Jw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t1(n,e,t,r=!1){const s=C(n,"logits","multinomial"),o=s.size,i=s.rank;if(o<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${o}.`);if(i>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${i}`);t=t||Math.random();const u={logits:i===1?M(s,[1,-1]):s},l={numSamples:e,seed:t,normalized:r},h=D.runKernel(Nh,u,l);return i===1?M(h,[h.size]):h}const n1=A({multinomial_:t1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r1(n,e){let t=C(n,"a","notEqual","string_or_numeric"),r=C(e,"b","notEqual","string_or_numeric");[t,r]=Oe(t,r),Ce(t.shape,r.shape);const s={a:t,b:r};return D.runKernel(Eh,s)}const _p=A({notEqual_:r1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s1(n,e,t=1,r=0,s="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const i={indices:C(n,"indices","oneHot","int32")},a={dtype:s,depth:e,onValue:t,offValue:r};return D.runKernel(Dh,i,a)}const o1=A({oneHot_:s1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i1(n){const t={x:C(n,"x","onesLike")};return D.runKernel(Rh,t)}const a1=A({onesLike_:i1});function u1(n,e){const t=C(n,"v1","outerProduct"),r=C(e,"v2","outerProduct");I(t.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${r.rank}.`);const s=M(t,[-1,1]),o=M(r,[1,-1]);return Se(s,o)}const l1=A({outerProduct_:u1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c1(n,e,t=0){const r=C(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const s={paddings:e,constantValue:t},o={x:r};return D.runKernel(Oh,o,s)}const fs=A({pad_:c1});function h1(n,e,t=0){return I(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),fs(n,[e],t)}const d1=A({pad1d_:h1});function p1(n,e,t=0){return I(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),fs(n,e,t)}const f1=A({pad2d_:p1});function m1(n,e,t=0){return I(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),fs(n,e,t)}const g1=A({pad3d_:m1});function y1(n,e,t=0){return I(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),fs(n,e,t)}const b1=A({pad4d_:y1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w1(n,e,t){const r=C(n,"x","spaceToBatchND");I(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),I(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),I(r.shape.reduce((i,a,u)=>u>0&&u<=e.length?i&&(a+t[u-1][0]+t[u-1][1])%e[u-1]===0:i,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const s={x:r},o={blockShape:e,paddings:t};return D.runKernel(ld,s,o)}const Ap=A({spaceToBatchND_:w1});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x1(n,e,t,r,s,o,i){s==null&&(s=[1,1]),o==null&&(o=1),r===0&&(r="valid");const a=C(n,"x","maxPool");let u=a,l=!1;a.rank===3&&(l=!0,u=M(a,[1,a.shape[0],a.shape[1],a.shape[2]])),I(Zt(o,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`);const h=Nr(u.shape,e,o,s,r),c=[h.dilationHeight,h.dilationWidth];let d;r==="same"?d=S1([h.filterHeight,h.filterWidth],c):d=[[0,0],[0,0]];const f=c[0]===1&&c[1]===1,[m,x]=v1([h.inHeight,h.inWidth],c,d),b=f?r:"valid",v=f?u:Ap(u,c,m),$=(t==="avg"?()=>up(v,e,o,b,i):()=>Tp(v,e,o,b,i))(),N=f?$:lp($,c,x);return l?M(N,[N.shape[1],N.shape[2],N.shape[3]]):N}function v1(n,e,t){const r=t.map(h=>h[0]),s=t.map(h=>h[1]),o=n.concat(r,s),i=e.map((h,c)=>(h-o[c]%h)%h),a=s.map((h,c)=>h+i[c]),u=e.map((h,c)=>[r[c],a[c]]),l=e.map((h,c)=>[0,i[c]]);return[u,l]}function S1(n,e){const r=n.map((i,a)=>i+(i-1)*(e[a]-1)).map(i=>i-1),s=r.map(i=>Math.floor(i/2)),o=r.map((i,a)=>i-s[a]);return r.map((i,a)=>[s[a],o[a]])}const C1=A({pool_:x1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I1(n,e){const t=C(n,"x","prelu"),r=C(e,"alpha","prelu"),s={x:t,alpha:r};return D.runKernel(zh,s)}const Rp=A({prelu_:I1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k1(n,e=null,t=!1){let r=C(n,"x","prod");r.dtype==="bool"&&(r=Pe(r,"int32"));const s={x:r},o={axis:e,keepDims:t};return D.runKernel(Lh,s,o)}const N1=A({prod_:k1});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $1(n,e,t,r){const s=n.map((h,c)=>C(h,`tensors${c}`,"raggedGather","int32")),o=C(e,"paramsDenseValues","raggedGather"),i=C(t,"indices","raggedGather","int32"),a={paramsNestedSplits:s,paramsDenseValues:o,indices:i},u={outputRaggedRank:r},l=D.runKernel(ag,a,u);return{outputNestedSplits:l.slice(0,l.length-1),outputDenseValues:l[l.length-1]}}const T1=A({raggedGather_:$1});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E1(n,e,t){const r=C(n,"starts","raggedRange"),s=C(e,"limits","raggedRange",r.dtype),o=C(t,"deltas","raggedRange",r.dtype),i={starts:r,limits:s,deltas:o},a=D.runKernel(ug,i);return{rtNestedSplits:a[0],rtDenseValues:a[1]}}const _1=A({raggedRange_:E1});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A1(n,e,t,r,s){const o=C(n,"shape","raggedTensorToTensor","int32"),i=C(e,"values","raggedTensorToTensor"),a=C(t,"defaultValue","raggedTensorToTensor",i.dtype),u=r.map((c,d)=>C(c,`tensors${d}`,"raggedTensorToTensor","int32")),l={shape:o,values:i,defaultValue:a,rowPartitionTensors:u},h={rowPartitionTypes:s};return D.runKernel(lg,l,h)}const R1=A({raggedTensorToTensor_:A1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D1(n,e,t){wt(n);const r=H(n);let s=null;if(t==null||t==="float32")s=new Float32Array(r);else if(t==="int32")s=new Int32Array(r);else if(t==="bool")s=new Uint8Array(r);else throw new Error(`Unknown data type ${t}`);for(let o=0;o<r;o++)s[o]=e();return D.makeTensor(s,n,t)}const P1=A({rand_:D1});var aa={exports:{}};aa.exports;(function(n){(function(e,t,r){function s(u){var l=this,h=a();l.next=function(){var c=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=c-(l.c=c|0)},l.c=1,l.s0=h(" "),l.s1=h(" "),l.s2=h(" "),l.s0-=h(u),l.s0<0&&(l.s0+=1),l.s1-=h(u),l.s1<0&&(l.s1+=1),l.s2-=h(u),l.s2<0&&(l.s2+=1),h=null}function o(u,l){return l.c=u.c,l.s0=u.s0,l.s1=u.s1,l.s2=u.s2,l}function i(u,l){var h=new s(u),c=l&&l.state,d=h.next;return d.int32=function(){return h.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,c&&(typeof c=="object"&&o(c,h),d.state=function(){return o(h,{})}),d}function a(){var u=4022871197,l=function(h){h=String(h);for(var c=0;c<h.length;c++){u+=h.charCodeAt(c);var d=.02519603282416938*u;u=d>>>0,d-=u,d*=u,u=d>>>0,d-=u,u+=d*4294967296}return(u>>>0)*23283064365386963e-26};return l}t&&t.exports?t.exports=i:this.alea=i})(Kt,n)})(aa);var O1=aa.exports,ua={exports:{}};ua.exports;(function(n){(function(e,t,r){function s(a){var u=this,l="";u.x=0,u.y=0,u.z=0,u.w=0,u.next=function(){var c=u.x^u.x<<11;return u.x=u.y,u.y=u.z,u.z=u.w,u.w^=u.w>>>19^c^c>>>8},a===(a|0)?u.x=a:l+=a;for(var h=0;h<l.length+64;h++)u.x^=l.charCodeAt(h)|0,u.next()}function o(a,u){return u.x=a.x,u.y=a.y,u.z=a.z,u.w=a.w,u}function i(a,u){var l=new s(a),h=u&&u.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var d=l.next()>>>11,f=(l.next()>>>0)/4294967296,m=(d+f)/(1<<21);while(m===0);return m},c.int32=l.next,c.quick=c,h&&(typeof h=="object"&&o(h,l),c.state=function(){return o(l,{})}),c}t&&t.exports?t.exports=i:this.xor128=i})(Kt,n)})(ua);var F1=ua.exports,la={exports:{}};la.exports;(function(n){(function(e,t,r){function s(a){var u=this,l="";u.next=function(){var c=u.x^u.x>>>2;return u.x=u.y,u.y=u.z,u.z=u.w,u.w=u.v,(u.d=u.d+362437|0)+(u.v=u.v^u.v<<4^(c^c<<1))|0},u.x=0,u.y=0,u.z=0,u.w=0,u.v=0,a===(a|0)?u.x=a:l+=a;for(var h=0;h<l.length+64;h++)u.x^=l.charCodeAt(h)|0,h==l.length&&(u.d=u.x<<10^u.x>>>4),u.next()}function o(a,u){return u.x=a.x,u.y=a.y,u.z=a.z,u.w=a.w,u.v=a.v,u.d=a.d,u}function i(a,u){var l=new s(a),h=u&&u.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var d=l.next()>>>11,f=(l.next()>>>0)/4294967296,m=(d+f)/(1<<21);while(m===0);return m},c.int32=l.next,c.quick=c,h&&(typeof h=="object"&&o(h,l),c.state=function(){return o(l,{})}),c}t&&t.exports?t.exports=i:this.xorwow=i})(Kt,n)})(la);var z1=la.exports,ca={exports:{}};ca.exports;(function(n){(function(e,t,r){function s(a){var u=this;u.next=function(){var h=u.x,c=u.i,d,f;return d=h[c],d^=d>>>7,f=d^d<<24,d=h[c+1&7],f^=d^d>>>10,d=h[c+3&7],f^=d^d>>>3,d=h[c+4&7],f^=d^d<<7,d=h[c+7&7],d=d^d<<13,f^=d^d<<9,h[c]=f,u.i=c+1&7,f};function l(h,c){var d,f=[];if(c===(c|0))f[0]=c;else for(c=""+c,d=0;d<c.length;++d)f[d&7]=f[d&7]<<15^c.charCodeAt(d)+f[d+1&7]<<13;for(;f.length<8;)f.push(0);for(d=0;d<8&&f[d]===0;++d);for(d==8?f[7]=-1:f[d],h.x=f,h.i=0,d=256;d>0;--d)h.next()}l(u,a)}function o(a,u){return u.x=a.x.slice(),u.i=a.i,u}function i(a,u){a==null&&(a=+new Date);var l=new s(a),h=u&&u.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var d=l.next()>>>11,f=(l.next()>>>0)/4294967296,m=(d+f)/(1<<21);while(m===0);return m},c.int32=l.next,c.quick=c,h&&(h.x&&o(h,l),c.state=function(){return o(l,{})}),c}t&&t.exports?t.exports=i:this.xorshift7=i})(Kt,n)})(ca);var L1=ca.exports,ha={exports:{}};ha.exports;(function(n){(function(e,t,r){function s(a){var u=this;u.next=function(){var h=u.w,c=u.X,d=u.i,f,m;return u.w=h=h+1640531527|0,m=c[d+34&127],f=c[d=d+1&127],m^=m<<13,f^=f<<17,m^=m>>>15,f^=f>>>12,m=c[d]=m^f,u.i=d,m+(h^h>>>16)|0};function l(h,c){var d,f,m,x,b,v=[],k=128;for(c===(c|0)?(f=c,c=null):(c=c+"\0",f=0,k=Math.max(k,c.length)),m=0,x=-32;x<k;++x)c&&(f^=c.charCodeAt((x+32)%c.length)),x===0&&(b=f),f^=f<<10,f^=f>>>15,f^=f<<4,f^=f>>>13,x>=0&&(b=b+1640531527|0,d=v[x&127]^=f+b,m=d==0?m+1:0);for(m>=128&&(v[(c&&c.length||0)&127]=-1),m=127,x=4*128;x>0;--x)f=v[m+34&127],d=v[m=m+1&127],f^=f<<13,d^=d<<17,f^=f>>>15,d^=d>>>12,v[m]=f^d;h.w=b,h.X=v,h.i=m}l(u,a)}function o(a,u){return u.i=a.i,u.w=a.w,u.X=a.X.slice(),u}function i(a,u){a==null&&(a=+new Date);var l=new s(a),h=u&&u.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var d=l.next()>>>11,f=(l.next()>>>0)/4294967296,m=(d+f)/(1<<21);while(m===0);return m},c.int32=l.next,c.quick=c,h&&(h.X&&o(h,l),c.state=function(){return o(l,{})}),c}t&&t.exports?t.exports=i:this.xor4096=i})(Kt,n)})(ha);var B1=ha.exports,da={exports:{}};da.exports;(function(n){(function(e,t,r){function s(a){var u=this,l="";u.next=function(){var c=u.b,d=u.c,f=u.d,m=u.a;return c=c<<25^c>>>7^d,d=d-f|0,f=f<<24^f>>>8^m,m=m-c|0,u.b=c=c<<20^c>>>12^d,u.c=d=d-f|0,u.d=f<<16^d>>>16^m,u.a=m-c|0},u.a=0,u.b=0,u.c=-1640531527,u.d=1367130551,a===Math.floor(a)?(u.a=a/4294967296|0,u.b=a|0):l+=a;for(var h=0;h<l.length+20;h++)u.b^=l.charCodeAt(h)|0,u.next()}function o(a,u){return u.a=a.a,u.b=a.b,u.c=a.c,u.d=a.d,u}function i(a,u){var l=new s(a),h=u&&u.state,c=function(){return(l.next()>>>0)/4294967296};return c.double=function(){do var d=l.next()>>>11,f=(l.next()>>>0)/4294967296,m=(d+f)/(1<<21);while(m===0);return m},c.int32=l.next,c.quick=c,h&&(typeof h=="object"&&o(h,l),c.state=function(){return o(l,{})}),c}t&&t.exports?t.exports=i:this.tychei=i})(Kt,n)})(da);var M1=da.exports,Dp={exports:{}};const V1={},W1=Object.freeze(Object.defineProperty({__proto__:null,default:V1},Symbol.toStringTag,{value:"Module"})),U1=Sg(W1);(function(n){(function(e,t,r){var s=256,o=6,i=52,a="random",u=r.pow(s,o),l=r.pow(2,i),h=l*2,c=s-1,d;function f(N,R,O){var F=[];R=R==!0?{entropy:!0}:R||{};var B=v(b(R.entropy?[N,$(t)]:N??k(),3),F),L=new m(F),W=function(){for(var V=L.g(o),ee=u,J=0;V<l;)V=(V+J)*s,ee*=s,J=L.g(1);for(;V>=h;)V/=2,ee/=2,J>>>=1;return(V+J)/ee};return W.int32=function(){return L.g(4)|0},W.quick=function(){return L.g(4)/4294967296},W.double=W,v($(L.S),t),(R.pass||O||function(V,ee,J,ne){return ne&&(ne.S&&x(ne,L),V.state=function(){return x(L,{})}),J?(r[a]=V,ee):V})(W,B,"global"in R?R.global:this==r,R.state)}function m(N){var R,O=N.length,F=this,B=0,L=F.i=F.j=0,W=F.S=[];for(O||(N=[O++]);B<s;)W[B]=B++;for(B=0;B<s;B++)W[B]=W[L=c&L+N[B%O]+(R=W[B])],W[L]=R;(F.g=function(V){for(var ee,J=0,ne=F.i,re=F.j,he=F.S;V--;)ee=he[ne=c&ne+1],J=J*s+he[c&(he[ne]=he[re=c&re+ee])+(he[re]=ee)];return F.i=ne,F.j=re,J})(s)}function x(N,R){return R.i=N.i,R.j=N.j,R.S=N.S.slice(),R}function b(N,R){var O=[],F=typeof N,B;if(R&&F=="object")for(B in N)try{O.push(b(N[B],R-1))}catch{}return O.length?O:F=="string"?N:N+"\0"}function v(N,R){for(var O=N+"",F,B=0;B<O.length;)R[c&B]=c&(F^=R[c&B]*19)+O.charCodeAt(B++);return $(R)}function k(){try{var N;return d&&(N=d.randomBytes)?N=N(s):(N=new Uint8Array(s),(e.crypto||e.msCrypto).getRandomValues(N)),$(N)}catch{var R=e.navigator,O=R&&R.plugins;return[+new Date,e,O,e.screen,$(t)]}}function $(N){return String.fromCharCode.apply(0,N)}if(v(r.random(),t),n.exports){n.exports=f;try{d=U1}catch{}}else r["seed"+a]=f})(typeof self<"u"?self:Kt,[],Math)})(Dp);var G1=Dp.exports,H1=O1,j1=F1,q1=z1,K1=L1,X1=B1,Y1=M1,er=G1;er.alea=H1;er.xor128=j1;er.xorwow=q1;er.xorshift7=K1;er.xor4096=X1;er.tychei=Y1;var pa=er;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fa{constructor(e,t,r,s,o){this.mean=e,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const i=o||Math.random();this.random=pa.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const s=this.nextVal;return this.nextVal=NaN,s}let e,t,r=!1;for(;!r;){let s,o,i;do s=2*this.random()-1,o=2*this.random()-1,i=s*s+o*o;while(i>=1||i===0);const a=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*s*a,t=this.mean+this.stdDev*o*a,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class Q1{constructor(e,t,r,s){this.alpha=e,this.beta=1/t,this.dtype=r;const o=s||Math.random();this.randu=pa.alea(o.toString()),this.randn=new fa(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,r,s,o,i;for(;;){do s=this.randn.nextValue(),i=1+this.c*s;while(i<=0);if(i*=i*i,e=s*s,t=1-.331*e*e,r=.5*e+this.d*(1-i+Math.log(i)),o=this.randu(),o<t||Math.log(o)<r)break}return i=1/this.beta*this.d*i,this.alpha<1&&(i*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(i)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class Z1{constructor(e=0,t=1,r,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=r,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=pa.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J1(n,e,t=1,r="float32",s){if(wt(n),t==null&&(t=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const o=new Q1(e,t,r,s),i=Ee(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const ex=A({randomGamma_:J1});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tx(n,e=0,t=1,r,s){if(wt(n),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const o=new fa(e,t,r,!1,s),i=Ee(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const Pp=A({randomNormal_:tx});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nx(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return Pp(n,0,1,e,t)}const rx=A({randomStandardNormal_:nx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sx(n,e=0,t=1,r="float32",s){wt(n);const o=Ee(n,r),i=new Z1(e,t,null,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const ma=A({randomUniform_:sx});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ox(n,e,t,r){return ma(n,e,t,"int32",r)}const ix=A({randomUniformInt_:ox});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ts(n,e,t=1,r="float32"){if(t===0)throw new Error("Cannot have a step of zero");const s={start:n,stop:e,step:t,dtype:r};return D.runKernel(Bh,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ax(n){const t={input:C(n,"input","real")};return D.runKernel(Mh,t)}const ns=A({real_:ax});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ux(n){const t={x:C(n,"x","reciprocal")};return D.runKernel(Vh,t)}const lx=A({reciprocal_:ux});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cx(n){const t={x:C(n,"x","relu")};return D.runKernel(Wh,t)}const bo=A({relu_:cx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hx(n){const t={x:C(n,"x","relu6")};return D.runKernel(jh,t)}const Op=A({relu6_:hx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dx(n,e){const r={x:C(n,"x","reverse")},s={dims:e};return D.runKernel(qh,r,s)}const Yn=A({reverse_:dx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function px(n){const e=C(n,"x","reverse");return I(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),Yn(e,0)}const fx=A({reverse1d_:px});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mx(n,e){const t=C(n,"x","reverse");return I(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),Yn(t,e)}const gx=A({reverse2d_:mx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yx(n,e){const t=C(n,"x","reverse");return I(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),Yn(t,e)}const bx=A({reverse3d_:yx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wx(n,e){const t=C(n,"x","reverse");return I(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),Yn(t,e)}const xx=A({reverse4d_:wx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vx(n){const t={x:C(n,"x","round")};return D.runKernel(Kh,t)}const Fp=A({round_:vx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sx(n){const t={x:C(n,"x","rsqrt","float32")};return D.runKernel(Xh,t)}const Cx=A({rsqrt_:Sx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ix(n){const t={x:C(n,"x","selu")};return D.runKernel(ed,t)}const kx=A({selu_:Ix});function Nx(n,e,t,r,s,o=[1,1],i="NHWC"){const a=C(n,"x","separableConv2d"),u=C(e,"depthwiseFilter","separableConv2d"),l=C(t,"pointwiseFilter","separableConv2d");let h=a,c=!1;if(a.rank===3&&(c=!0,h=M(a,[1,a.shape[0],a.shape[1],a.shape[2]])),i==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");I(h.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${h.rank}.`),I(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),I(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),I(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),I(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);const d=u.shape[2],f=u.shape[3];I(l.shape[2]===d*f,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*f}, but got ${l.shape[2]}.`);const m=ra(h,u,r,s,i,o),b=po(m,l,1,"valid",i);return c?M(b,[b.shape[1],b.shape[2],b.shape[3]]):b}const $x=A({separableConv2d_:Nx});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Tx(n,e){const t=C(n,"x","setdiff1d"),r=C(e,"y","setdiff1d");I(t.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${r.dtype}).`),I(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),I(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const s=await t.data(),o=await r.data(),i=new Set(o);let a=0;for(let h=0;h<s.length;h++)i.has(s[h])||a++;const u=new vr([a],t.dtype),l=new vr([a],"int32");for(let h=0,c=0;h<s.length;h++)i.has(s[h])||(u.values[c]=s[h],l.values[c]=h,c++);return[u.toTensor(),l.toTensor()]}const Ex=Tx;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _x(n){const t={x:C(n,"x","sign")};return D.runKernel(sd,t)}const Ax=A({sign_:_x});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rx(n){const t={x:C(n,"x","sin","float32")};return D.runKernel(nd,t)}const Dx=A({sin_:Rx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Px(n){const t={x:C(n,"x","sinh")};return D.runKernel(rd,t)}const Ox=A({sinh_:Px});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fx(n,e,t){const r=C(n,"x","slice1d");return I(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),pe(r,[e],[t])}const zx=A({slice1d_:Fx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lx(n,e,t){const r=C(n,"x","slice2d");return I(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),pe(r,e,t)}const Bx=A({slice2d_:Lx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mx(n,e,t){const r=C(n,"x","slice3d");return I(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),pe(r,e,t)}const Vx=A({slice3d_:Mx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wx(n,e,t){const r=C(n,"x","slice4d");return I(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),pe(r,e,t)}const Ux=A({slice4d_:Wx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gx(n,e=-1){const t=C(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const r={logits:t},s={dim:e};return D.runKernel(hd,r,s)}const Hx=A({softmax_:Gx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jx(n){I(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return D.runKernel(Hc,e)}const ga=A({fft_:jx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qx(n){I(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return D.runKernel(th,e)}const Xs=A({ifft_:qx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kx(n){const e=n.shape[n.shape.length-1],t=n.size/e;let r;if(e<=2){const s=M(n,[t,e]);r=Xs(s)}else{const s=[t,2*(e-1)],o=M(ns(n),[t,e]),i=M(yo(n),[t,e]),a=Yn(pe(o,[0,1],[t,e-2]),1),u=q(Yn(pe(i,[0,1],[t,e-2]),1),we(-1)),l=je([o,a],1),h=je([i,u],1),c=M(vn(l,h),[s[0],s[1]]);r=Xs(c)}if(r=ns(r),n.rank===3&&n.shape[0]!==0){const s=r,o=n.shape[0];r=M(r,[o,r.shape[0]/o,r.shape[1]]),s.dispose()}return r}const zp=A({irfft_:Kx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xx(n,e,t=0){const s={x:C(n,"x","split")},o={numOrSizeSplits:e,axis:t};return D.runKernel(cd,s,o)}const rs=A({split_:Xx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yx(n,e){I(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const r=n.size/t;let s;if(e!=null&&e<t){const m=n.shape.map(b=>0),x=n.shape.map(b=>b);x[n.shape.length-1]=e,s=pe(n,m,x),t=e}else if(e!=null&&e>t){const m=n.shape.map(x=>x);m[n.shape.length-1]=e-t,s=je([n,Xn(m)],n.shape.length-1),t=e}else s=n;const o=yt(s),i=M(vn(s,o),[r,t]),a=ga(i),u=Math.floor(t/2)+1,l=ns(a),h=yo(a),c=rs(l,[u,t-u],l.shape.length-1),d=rs(h,[u,t-u],h.shape.length-1),f=s.shape.slice();return f[s.shape.length-1]=u,M(vn(c[0],d[0]),f)}const ya=A({rfft_:Yx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qx(n,e){let t=C(n,"a","squaredDifference"),r=C(e,"b","squaredDifference");[t,r]=Oe(t,r),Ce(t.shape,r.shape);const s={a:t,b:r},o={};return D.runKernel(md,s,o)}const Lp=A({squaredDifference_:Qx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zx(n,e){const t=C(n,"x","squeeze","string_or_numeric");return M(t,Fm(t.shape,e).newShape)}const Ge=A({squeeze_:Zx});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jx(n,e=0){const t=Us(n,"tensors","stack","string_or_numeric");I(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&I(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const r=t,s={axis:e};return D.runKernel(Ph,r,s)}const cn=A({stack_:Jx});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e2(n,e=0){const r={x:C(n,"x","step")},s={alpha:e};return D.runKernel(Nd,r,s)}const Bp=A({step_:e2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t2(n,e,t,r,s=0,o=0,i=0,a=0,u=0){const h={x:C(n,"x","stridedSlice","string_or_numeric")},c={begin:e,end:t,strides:r,beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};return D.runKernel(gd,h,c)}const n2=A({stridedSlice_:t2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r2(n){const t={x:C(n,"x","tan","float32")};return D.runKernel(wd,t)}const s2=A({tan_:r2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ye(n,e){kr(n);const t=Cn(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return In(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wn(n,e,t){if(kr(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=Cn(n,t);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return In(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mp(n,e,t){if(kr(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=Cn(n,t);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return In(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o2(n,e,t){if(kr(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=Cn(n,t);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return In(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i2(n,e,t){if(kr(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=Cn(n,t);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return In(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a2(n,e,t){if(kr(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=Cn(n,t);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,In(n,e,r,t)}function u2(n,e,t){const r=e.rank>1?e.shape[e.rank-1]:1,s=e.rank>1?e.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${s}.`;if(t.rank<s)throw new Error(o+` update.rank < ${s}. `);if(n.length<r+(t.rank-s))throw new Error(o+` Output shape length < ${r+(t.rank-s)}`);if(t.rank!==s+n.length-r)throw new Error(o+` update.rank != ${s+n.length-r}`);for(let i=0;i<s;++i)if(t.shape[i]!==e.shape[i])throw new Error(o+` updates.shape[${i}] (${t.shape[i]}) != indices.shape[${i}] (${e.shape[i]}).`);for(let i=0;i<t.rank-s;++i)if(t.shape[i+s]!==n[i+r])throw new Error(o+` updates.shape[${i+s}] (${t.shape[i+s]}) != shape[${i+s}] (${n[i+s]})`)}function Vp(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}u2(t,e,n)}function ba(n,e,t){const r=e.shape.length,s=r>1?e.shape[r-1]:1,o=t.length;let i=1;for(let c=s;c<o;++c)i*=t[c];const a=s<1?1:s,u=H(e.shape)/a,l=[...Qe(t.slice(0,s)),1],h=H(t);return{sliceRank:s,numUpdates:u,sliceSize:i,strides:l,outputSize:h}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l2(n,e,t){const r=C(n,"tensor","tensorScatterupdate"),s=C(e,"indices","tensorScatterupdate","int32"),o=C(t,"updates","tensorScatterupdate");if(Vp(o,s,r.shape),r.dtype!==o.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${r.dtype} and ${o.dtype}.`);const i={tensor:r,indices:s,updates:o},a={};return D.runKernel(Qh,i,a)}const c2=A({tensorScatterUpdate_:l2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h2(n,e=1,t=!0){const r=C(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const s=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${e}`);const o={x:r},i={k:e,sorted:t},[a,u]=D.runKernel(vd,o,i);return{values:a,indices:u}}const d2=A({topk_:h2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p2(n,e=0,t=1,r,s){if(wt(n),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const o=new fa(e,t,r,!0,s),i=Ee(n,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const f2=A({truncatedNormal_:p2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m2(n,e=0){const t=C(n,"x","unique","string_or_numeric");I(t.rank>0,()=>"The input tensor must be at least 1D");const r={x:t},s={axis:e},[o,i]=D.runKernel(bg,r,s);return{values:o,indices:i}}const g2=A({unique_:m2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y2(n,e,t){const r=C(n,"x","unsortedSegmentSum"),s=C(e,"segmentIds","unsortedSegmentSum","int32");I(Yr(t),()=>"numSegments must be of dtype int");const o={x:r,segmentIds:s},i={numSegments:t};return D.runKernel(Id,o,i)}const b2=A({unsortedSegmentSum_:y2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w2(n,e=0){const t=C(n,"x","unstack","string_or_numeric");I(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const r={value:t},s={axis:e};return D.runKernel(Cd,r,s)}const tr=A({unstack_:w2});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x2(n,e){return ia(n,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v2(n,e=!0,t,r){return D.makeVariable(n,e,t,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S2(n,e){const t=[];for(let o=0;o<e.length;o++)e[o]&&t.push(o);const r=Ee(n,"int32"),s=Ee([t.length,n.length],"int32");for(let o=0;o<t.length;o++){const i=r.indexToLoc(t[o]),a=o*n.length;s.values.set(i,a)}return s.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function C2(n){const e=C(n,"condition","whereAsync","bool"),t=await e.data(),r=S2(e.shape,t);return n!==e&&e.dispose(),r}const Wp=C2;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function I2(n,e,t){const r=C(n,"tensor","boolMask"),s=C(e,"mask","boolMask","bool"),o=t??0,i=s.rank,a=r.shape;I(i>0,()=>"mask cannot be scalar"),bt(a.slice(o,o+i),s.shape,"mask's shape must match the first K dimensions of tensor's shape,");let u=1;for(let x=o;x<o+i;x++)u*=a[x];const l=a.slice(0,o).concat([u],a.slice(o+i)),h=M(r,l),c=M(s,[-1]),d=await Wp(c),f=Ge(d,[1]),m=xp(h,f,o);return n!==r&&r.dispose(),e!==s&&s.dispose(),f.dispose(),h.dispose(),c.dispose(),d.dispose(),m}const k2=I2;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N2(n,e,t){const r=C(n,"x","transpose");if(e==null&&(e=r.shape.map((i,a)=>a).reverse()),I(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(i=>{I(i>=0&&i<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const s={x:r},o={perm:e};return r.dtype==="complex64"?be(()=>{let i=ns(r),a=yo(r);return i=D.runKernel(Ps,{x:i},o),a=D.runKernel(Ps,{x:a},o),t&&(a=Yt(a)),vn(i,a)}):D.runKernel(Ps,s,o)}const _i=A({transpose_:N2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $2(n,e,t,r,s=!0){const o=C(n,"v","movingAverage"),i=C(e,"x","movingAverage"),a=C(t,"decay","movingAverage");Ug(o,i),I(ot(o.shape,i.shape),()=>"Shape mismatch in v and x");const u=we(1),l=fe(u,a);let h=q(fe(i,o),l);if(s){I(r!=null,()=>"When using zeroDebias: true, step is required.");const c=C(r,"step","movingAverage");h=ye(h,fe(u,Jr(a,c)))}return ie(o,h)}const T2=A({movingAverage_:$2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E2(n,e,t){wt(t);const r=C(n,"indices","scatterND","int32"),s=C(e,"updates","scatterND");Vp(s,r,t);const o={indices:r,updates:s},i={shape:t};return D.runKernel(Yh,o,i)}const _2=A({scatterND_:E2});function A2(n,e,t,r){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const s=n.rank>0?n.shape[0]:1,o=n.rank>1?n.shape[1]:1;if(t.length!==o)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${o}.`);const i=e.size;if(!(e.rank===0||e.rank===1&&i===s))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${s}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R2(n,e,t,r=0){wt(t);const s=C(n,"sparseIndices","sparseToDense","int32"),o=C(e,"sparseValues","sparseToDense","string_or_numeric"),i=C(r,"defaultValue","sparseToDense",o.dtype);A2(s,o,t,i);const a={sparseIndices:s,sparseValues:o,defaultValue:i},u={outputShape:t};return D.runKernel(fd,a,u)}const D2=A({sparseToDense_:R2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P2(n,e){const t=C(e,"indices","gatherND","int32"),s={params:C(n,"x","gatherND","string_or_numeric"),indices:t};return D.runKernel(Zc,s)}const O2=A({gatherND_:P2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F2(n,e){if(e==null)return n.shape.slice();if(ot(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let r=0;r<n.shape.length;r++)e[r]==null&&n.shape[r]!=null?t.push(n.shape[r]):t.push(e[r]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z2(n,e,t,r){const s=C(n,"x","dropout");if(I(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),I(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof Be?s.clone():s;const o=F2(s,t),i=1-e,a=ye(wp(ie(ma(o,0,1,"float32",r),i)),i);return q(s,a)}const L2=A({dropout_:z2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Up(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function wa(n,e,t){const r=1-n%2,s=new Float32Array(n);for(let o=0;o<n;++o){const i=2*Math.PI*o/(n+r-1);s[o]=e-t*Math.cos(i)}return Ye(s,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function B2(n,e,t=1){const r=C(n,"predictions","inTopK"),s=C(e,"targets","inTopK");I(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),I(r.rank-1===s.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${s.rank}`),bt(r.shape.slice(0,r.shape.length-1),s.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const o=r.shape[r.shape.length-1];I(t>0&&t<=o,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${o}), but got ${t}`);const i=await r.data(),a=await s.data(),[u,l]=[i.length/o,o],h=wn("bool",u);for(let c=0;c<u;c++){const d=c*l,f=i.subarray(d,d+l),m=[];for(let x=0;x<f.length;x++)m.push({value:f[x],index:x});m.sort((x,b)=>b.value-x.value),h[c]=0;for(let x=0;x<t;x++)if(m[x].index===a[c]){h[c]=1;break}}return n!==r&&r.dispose(),e!==s&&s.dispose(),Xt(h,s.shape,"bool")}const M2=B2;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V2(n,e,t,r,s,o="NHWC",i){let a=n;n.rank===3&&(a=M(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=M(e,[1,e.shape[0],e.shape[1],e.shape[2]])),I(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),I(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),I(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const l=o==="NHWC"?a.shape[3]:a.shape[1],h=o==="NHWC"?u.shape[3]:u.shape[1];I(l===t[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${t[2]}.`),I(h===t[3],()=>`Error in conv2dDerFilter: depth of dy (${h}) must match output depth for filter (${t[3]}).`),Bt("conv2dDerFilter",s,i);const c={x:a,dy:u},d={strides:r,pad:s,dataFormat:o,dimRoundingMode:i,filterShape:t};return D.runKernel(vc,c,d)}const W2=A({conv2DBackpropFilter_:V2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xa(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return q(n,Bp(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function va(n,e){let t=e;const r=$b(n.shape,e.shape);return r.length>0&&(t=Ne(t,r)),M(t,n.shape)}function Sa(n,e,t,r){if(e==="linear")return n;if(e==="relu")return bo(n);if(e==="elu")return fp(n);if(e==="relu6")return Op(n);if(e==="prelu")return Rp(n,t);if(e==="leakyrelu")return Sp(n,r);if(e==="sigmoid")return Vn(n);throw new Error(`Unknown fused activation ${e}.`)}const Ca=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U2({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:h}){if(u=u||"linear",Ca(D.state.gradientDepth,u)===!1){I(s==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${s} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let O=po(n,e,t,r,s,o,i);return a!=null&&(O=ie(O,a)),Sa(O,u,l,h)}const c=C(n,"x","conv2d","float32"),d=C(e,"filter","conv2d","float32");let f=c,m=!1;c.rank===3&&(m=!0,f=M(c,[1,c.shape[0],c.shape[1],c.shape[2]])),I(f.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`),I(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),Bt("fused conv2d",r,i);const x=s==="NHWC"?f.shape[3]:f.shape[1];I(d.shape[2]===x,()=>`Error in conv2d: depth of input (${x}) must match input depth for filter ${d.shape[2]}.`),I(Zt(t,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);const b=Et(f.shape,d.shape,t,o,r,i);let v;a!=null&&(v=C(a,"bias","fused conv2d"),[v]=Oe(v,c),s==="NHWC"?Ce(b.outShape,v.shape):(I(v.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${v.shape.length}.`),I(v.shape.length===0||v.shape[0]===b.outChannels||v.shape[0]===1,()=>`Error in fused conv2d: bias shape (${v.shape}) is not compatible with the number of output channels (${b.outChannels})`)));let k;if(l!=null){const O=l.shape;if(I(O.length<=1||O.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${O.length}.`),O.length===1)I(O[0]===1||O[0]===b.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${O}) is not compatible with the number of output channels (${b.outChannels}).`);else if(O.length===3)try{Ce(O,b.outShape)}catch{const B=`Error in fused conv2d: PReLU activation weights (${O}) is not compatible with the output shape of the conv2d (${b.outShape}).`;throw Error(B)}k=C(l,"prelu weights","fused conv2d")}const $=(O,F)=>{I(s==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${s} but only NHWC is currently supported.`);const[B,L,W,V]=F,ee=xa(O,W,u);I(Gs(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);const J=dp(L.shape,ee,B,t,r),ne=W2(L,ee,B.shape,t,r),re=[J,ne];if(V!=null){const he=va(V,ee);re.push(he)}return re},N={x:f,filter:d,bias:v,preluActivationWeights:k},R={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:u,leakyreluAlpha:h};return a==null?ln((F,B,L)=>{let W=D.runKernel(pi,N,R);return L([B,F,W]),m&&(W=M(W,[W.shape[1],W.shape[2],W.shape[3]])),{value:W,gradFunc:$}})(f,d):ln((F,B,L,W)=>{let V=D.runKernel(pi,N,R);return W([B,F,V,L]),m&&(V=M(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:$}})(f,d,v)}const G2=A({fusedConv2d_:U2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H2(n,e,t,r,s,o=[1,1],i){let a=n;n.rank===3&&(a=M(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let u=e;u.rank===3&&(u=M(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={x:a,dy:u},h={strides:r,pad:s,dimRoundingMode:i,dilations:o,filterShape:t};return D.runKernel(Dc,l,h)}const j2=A({depthwiseConv2dNativeBackpropFilter_:H2});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q2(n,e,t,r,s,o=[1,1],i){let a=e,u=!1;e.rank===3&&(u=!0,a=M(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={dy:a,filter:t},h={strides:r,pad:s,dimRoundingMode:i,dilations:o,inputShape:n},c=D.runKernel(Pc,l,h);return u?M(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const K2=A({depthwiseConv2dNativeBackpropInput_:q2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X2({x:n,filter:e,strides:t,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:a,activation:u="linear",preluActivationWeights:l,leakyreluAlpha:h}){if(Ca(D.state.gradientDepth,u)===!1){let R=ra(n,e,t,r,s,o,i);return a!=null&&(R=ie(R,a)),Sa(R,u,l,h)}const c=C(n,"x","depthwiseConv2d","float32"),d=C(e,"filter","depthwiseConv2d","float32");let f=c,m=!1;c.rank===3&&(m=!0,f=M(c,[1,c.shape[0],c.shape[1],c.shape[2]])),I(f.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${f.rank}.`),I(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),I(f.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${f.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),o==null&&(o=[1,1]),I(Zt(t,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),Bt("fused depthwiseConv2d",r,i);const x=Et(f.shape,d.shape,t,o,r,i,!0);let b;a!=null&&(b=C(a,"bias","fused conv2d"),[b]=Oe(b,c),Ce(x.outShape,b.shape));let v;l!=null&&(v=C(l,"prelu weights","fused depthwiseConv2d"));const k=(R,O)=>{I(Gs(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[F,B,L,W]=O,V=xa(R,L,u),ee=K2(B.shape,V,F,t,r,o,i),J=j2(B,V,F.shape,t,r,o,i);if(W!=null){const ne=va(b,V);return[ee,J,ne]}return[ee,J]},$={x:f,filter:d,bias:b,preluActivationWeights:v},N={strides:t,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:u,leakyreluAlpha:h};return a==null?ln((O,F,B)=>{let L=D.runKernel(fi,$,N);return B([F,O,L]),m&&(L=M(L,[L.shape[1],L.shape[2],L.shape[3]])),{value:L,gradFunc:k}})(f,d):ln((O,F,B,L)=>{let W=D.runKernel(fi,$,N);return L([F,O,W,B]),m&&(W=M(W,[W.shape[1],W.shape[2],W.shape[3]])),{value:W,gradFunc:k}})(f,d,b)}const Y2=A({fusedDepthwiseConv2d_:X2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q2({a:n,b:e,transposeA:t=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:a=.2}){if(Ca(D.state.gradientDepth,o)===!1){let V=Se(n,e,t,r);return s!=null&&(V=ie(V,s)),Sa(V,o,i,a)}let u=C(n,"a","fused matMul"),l=C(e,"b","fused matMul");[u,l]=Oe(u,l);const h=t?u.shape[u.rank-2]:u.shape[u.rank-1],c=r?l.shape[l.rank-1]:l.shape[l.rank-2],d=t?u.shape[u.rank-1]:u.shape[u.rank-2],f=r?l.shape[l.rank-2]:l.shape[l.rank-1],m=u.shape.slice(0,-2),x=l.shape.slice(0,-2),b=H(m),v=H(x);I(h===c,()=>`Error in fused matMul: inner shapes (${h}) and (${c}) of Tensors with shapes ${u.shape} and ${l.shape} and transposeA=${t} and transposeB=${r} must match.`);const $=Ce(u.shape.slice(0,-2),l.shape.slice(0,-2)).concat([d,f]),N=t?M(u,[b,h,d]):M(u,[b,d,h]),R=r?M(l,[v,f,c]):M(l,[v,c,f]);let O;s!=null&&(O=C(s,"bias","fused matMul"),[O]=Oe(O,u),Ce($,O.shape));let F;i!=null&&(F=C(i,"prelu weights","fused matMul"));const B=(V,ee)=>{const[J,ne,re,he]=ee,Le=xa(M(V,re.shape),re,o);let ge,ce;if(!t&&!r?(ge=Se(Le,ne,!1,!0),ce=Se(J,Le,!0,!1)):!t&&r?(ge=Se(Le,ne,!1,!1),ce=Se(Le,J,!0,!1)):t&&!r?(ge=Se(ne,Le,!1,!0),ce=Se(J,Le,!1,!1)):(ge=Se(ne,Le,!0,!0),ce=Se(Le,J,!0,!0)),s!=null){const Ae=va(he,Le);return[ge,ce,Ae]}else return[ge,ce]},L={a:N,b:R,bias:O,preluActivationWeights:F},W={transposeA:t,transposeB:r,activation:o,leakyreluAlpha:a};return s==null?ln((ee,J,ne)=>{const re=D.runKernel(di,L,W);return ne([ee,J,re]),{value:M(re,$),gradFunc:B}})(N,R):ln((ee,J,ne,re)=>{const he=D.runKernel(di,L,W);return re([ee,J,he,ne]),{value:M(he,$),gradFunc:B}})(N,R,O)}const Z2=A({fusedMatMul_:Q2});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J2=Object.freeze(Object.defineProperty({__proto__:null,conv2d:G2,depthwiseConv2d:Y2,matMul:Z2},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ev(n){return wa(n,.54,.46)}const tv=A({hammingWindow_:ev});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nv(n){return wa(n,.5,.5)}const Gp=A({hannWindow_:nv});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rv(n,e,t,r=!1,s=0){let o=0;const i=[];for(;o+e<=n.size;)i.push(pe(n,o,e)),o+=t;if(r)for(;o<n.size;){const a=o+e-n.size,u=je([pe(n,o,e-a),cs([a],s)]);i.push(u),o+=t}return i.length===0?Wn([],[0,e]):M(je(i),[i.length,e])}const Hp=A({frame_:rv});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sv(n,e,t,r,s=Gp){r==null&&(r=Up(e));const o=Hp(n,e,t),i=q(o,s(e));return ya(i,r)}const ov=A({stft_:sv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iv(n,e,t,r,s="bilinear",o=0){const i=C(n,"image","cropAndResize"),a=C(e,"boxes","cropAndResize","float32"),u=C(t,"boxInd","cropAndResize","int32"),l=a.shape[0];I(i.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${i.rank}.`),I(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${a.shape}.`),I(u.rank===1&&u.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${a.shape}.`),I(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),I(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),I(s==="bilinear"||s==="nearest",()=>`method must be bilinear or nearest, but was ${s}`);const h={image:i,boxes:a,boxInd:u},c={method:s,extrapolationValue:o,cropSize:r};return D.runKernel(Ec,h,c)}const av=A({cropAndResize_:iv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uv(n){const e=C(n,"image","flipLeftRight","float32");I(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return D.runKernel(qc,t,{})}const lv=A({flipLeftRight_:uv});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cv(n){const e=C(n,"image","grayscaleToRGB"),t=e.rank-1,r=e.shape[t];I(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),I(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const s=new Array(e.rank);return s.fill(1,0,t),s[t]=3,Kr(e,s)}const hv=A({grayscaleToRGB_:cv});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dv(n){const e=C(n,"image","RGBToGrayscale"),t=e.rank-1,r=e.shape[t];I(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),I(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const s=e.dtype,o=Pe(e,"float32"),i=Ye([.2989,.587,.114]);let a;switch(e.rank){case 2:a=fr("ij,j->i",o,i);break;case 3:a=fr("ijk,k->ij",o,i);break;case 4:a=fr("ijkl,l->ijk",o,i);break;case 5:a=fr("ijklm,m->ijkl",o,i);break;case 6:a=fr("ijklmn,n->ijklm",o,i);break;default:throw new Error("Not a valid tensor rank.")}return a=Ht(a,-1),Pe(a,s)}const pv=A({rgbToGrayscale_:dv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fv(n,e,t=0,r=.5){const s=C(n,"image","rotateWithOffset","float32");I(s.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${s.rank}.`);const o={image:s},i={radians:e,fillValue:t,center:r};return D.runKernel($d,o,i)}const mv=A({rotateWithOffset_:fv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tr(n,e,t,r,s,o){r==null&&(r=.5),s==null&&(s=Number.NEGATIVE_INFINITY),o==null&&(o=0);const i=n.shape[0];return t=Math.min(t,i),I(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),I(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),I(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),I(e.rank===1,()=>"scores must be a 1D tensor"),I(e.shape[0]===i,()=>`scores has incompatible shape with boxes. Expected ${i}, but was ${e.shape[0]}`),I(0<=o&&o<=1,()=>`softNmsSigma must be in [0, 1], but was '${o}'`),{maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gv(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const o=C(n,"boxes","nonMaxSuppression","float32"),i=C(e,"scores","nonMaxSuppression","float32"),a=Tr(o,i,t,r,s);t=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const u={maxOutputSize:t,iouThreshold:r,scoreThreshold:s};return D.runKernel(_h,{boxes:o,scores:i},u)}const yv=A({nonMaxSuppression_:gv});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bv(n,e,t){const r=wv(n,e,t),s=r<0?-(r+1):r;n.splice(s,0,e)}function wv(n,e,t){return vv(n,e,t||xv)}function xv(n,e){return n>e?1:n<e?-1:0}function vv(n,e,t){let r=0,s=n.length,o=0,i=!1;for(;r<s;){o=r+(s-r>>>1);const a=t(e,n[o]);a>0?r=o+1:(s=o,i=!a)}return i?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jp(n,e,t,r,s){return Ia(n,e,t,r,s,0)}function Sv(n,e,t,r,s,o){return Ia(n,e,t,r,s,0,!1,o,!0)}function qp(n,e,t,r,s,o){return Ia(n,e,t,r,s,o,!0)}function Ia(n,e,t,r,s,o,i=!1,a=!1,u=!1){const l=[];for(let b=0;b<e.length;b++)e[b]>s&&l.push({score:e[b],boxIndex:b,suppressBeginIndex:0});l.sort(Zu);const h=o>0?-.5/o:0,c=[],d=[];for(;c.length<t&&l.length>0;){const b=l.pop(),{score:v,boxIndex:k,suppressBeginIndex:$}=b;if(v<s)break;let N=!1;for(let R=c.length-1;R>=$;--R){const O=Cv(n,k,c[R]);if(O>=r){N=!0;break}if(b.score=b.score*Iv(r,h,O),b.score<=s)break}b.suppressBeginIndex=c.length,N||(b.score===v?(c.push(k),d.push(b.score)):b.score>s&&bv(l,b,Zu))}const f=c.length,m=t-f;a&&m>0&&(c.push(...new Array(m).fill(0)),d.push(...new Array(m).fill(0)));const x={selectedIndices:c};return i&&(x.selectedScores=d),u&&(x.validOutputs=f),x}function Cv(n,e,t){const r=n.subarray(e*4,e*4+4),s=n.subarray(t*4,t*4+4),o=Math.min(r[0],r[2]),i=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),u=Math.max(r[1],r[3]),l=Math.min(s[0],s[2]),h=Math.min(s[1],s[3]),c=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),f=(a-o)*(u-i),m=(c-l)*(d-h);if(f<=0||m<=0)return 0;const x=Math.max(o,l),b=Math.max(i,h),v=Math.min(a,c),k=Math.min(u,d),$=Math.max(v-x,0)*Math.max(k-b,0);return $/(f+m-$)}function Iv(n,e,t){const r=Math.exp(e*t*t);return t<=n?r:0}function Zu(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function kv(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY){const o=C(n,"boxes","nonMaxSuppressionAsync"),i=C(e,"scores","nonMaxSuppressionAsync"),a=Tr(o,i,t,r,s);t=a.maxOutputSize,r=a.iouThreshold,s=a.scoreThreshold;const u=await Promise.all([o.data(),i.data()]),l=u[0],h=u[1],{selectedIndices:c}=jp(l,h,t,r,s);return o!==n&&o.dispose(),i!==e&&i.dispose(),Ye(c,"int32")}const Nv=kv;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $v(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=C(n,"boxes","nonMaxSuppression"),a=C(e,"scores","nonMaxSuppression"),u=Tr(i,a,t,r,s,o);t=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,o=u.softNmsSigma;const l={boxes:i,scores:a},h={maxOutputSize:t,iouThreshold:r,scoreThreshold:s,softNmsSigma:o},c=D.runKernel(Ah,l,h);return{selectedIndices:c[0],selectedScores:c[1]}}const Tv=A({nonMaxSuppressionWithScore_:$v});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Ev(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=0){const i=C(n,"boxes","nonMaxSuppressionAsync"),a=C(e,"scores","nonMaxSuppressionAsync"),u=Tr(i,a,t,r,s,o);t=u.maxOutputSize,r=u.iouThreshold,s=u.scoreThreshold,o=u.softNmsSigma;const l=await Promise.all([i.data(),a.data()]),h=l[0],c=l[1],{selectedIndices:d,selectedScores:f}=qp(h,c,t,r,s,o);return i!==n&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:Ye(d,"int32"),selectedScores:Ye(f)}}const _v=Ev;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Av(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=C(n,"boxes","nonMaxSuppression"),a=C(e,"scores","nonMaxSuppression"),u=Tr(i,a,t,r,s,null),l=u.maxOutputSize,h=u.iouThreshold,c=u.scoreThreshold,d={boxes:i,scores:a},f={maxOutputSize:l,iouThreshold:h,scoreThreshold:c,padToMaxOutputSize:o},m=D.runKernel(ig,d,f);return{selectedIndices:m[0],validOutputs:m[1]}}const Rv=A({nonMaxSuppressionPadded_:Av});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Dv(n,e,t,r=.5,s=Number.NEGATIVE_INFINITY,o=!1){const i=C(n,"boxes","nonMaxSuppressionAsync"),a=C(e,"scores","nonMaxSuppressionAsync"),u=Tr(i,a,t,r,s,null),l=u.maxOutputSize,h=u.iouThreshold,c=u.scoreThreshold,[d,f]=await Promise.all([i.data(),a.data()]),{selectedIndices:m,validOutputs:x}=Sv(d,f,l,h,c,o);return i!==n&&i.dispose(),a!==e&&a.dispose(),{selectedIndices:Ye(m,"int32"),validOutputs:we(x,"int32")}}const Pv=Dv;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ov(n,e,t=!1,r=!1){const s=C(n,"images","resizeBilinear");I(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),I(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),I(r===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;s.rank===3&&(i=!0,o=M(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:o},u={alignCorners:t,halfPixelCenters:r,size:e},l=D.runKernel(Hh,a,u);return i?M(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const Fv=A({resizeBilinear_:Ov});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zv(n,e,t=!1,r=!1){const s=C(n,"images","resizeNearestNeighbor");I(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),I(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),I(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),I(r===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,i=!1;s.rank===3&&(i=!0,o=M(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const a={images:o},u={alignCorners:t,halfPixelCenters:r,size:e},l=D.runKernel(Gh,a,u);return i?M(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const Lv=A({resizeNearestNeighbor_:zv});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bv(n,e="binary",t=!1,r=.5){const s=C(n,"image","threshold"),o=.2989,i=.587,a=.114,u=s.shape[0]*s.shape[1];let l=q(Ye([r]),255),h,c,d,f;if(I(s.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${s.rank}.`),I(s.shape[2]===3||s.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${s.shape[2]}.`),I(s.dtype==="int32"||s.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${s.dtype}.`),I(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),s.shape[2]===3){[h,c,d]=rs(s,[1,1,1],-1);const b=q(h,o),v=q(c,i),k=q(d,a);f=ie(ie(b,v),k)}else f=n;if(e==="otsu"){const b=cp(Pe(Fp(f),"int32"),Xt([]),256);l=Mv(b,u)}const m=t?oa(f,l):go(f,l);return Pe(q(m,255),"int32")}function Mv(n,e){let t=Ye([-1]),r=Ye([0]),s=Ye([0]),o,i,a,u,l,h;for(let c=0;c<n.size-1;c++){o=pe(n,0,c+1),i=pe(n,c+1),l=ye(Ne(o),e),h=ye(Ne(i),e);const d=Ne(q(o,ts(0,o.size)));a=ye(d,Ne(o));const f=cs(i.shape,o.size),m=ie(ts(0,i.size),f),x=q(i,m);u=ye(Ne(x),Ne(i));const b=fe(a,u),v=fe(a,u),k=q(l,h);s=q(q(k,b),v);const $=go(s,r);r=bn($,s,r),t=bn($,Ye([c]),t)}return t}const Vv=A({threshold_:Bv});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wv(n,e,t="nearest",r="constant",s=0,o){const i=C(n,"image","transform","float32"),a=C(e,"transforms","transform","float32");I(i.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${i.rank}.`),I(a.rank===2&&(a.shape[0]===i.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),I(o==null||o.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${o}.`);const u={image:i,transforms:a},l={interpolation:t,fillMode:r,fillValue:s,outputShape:o};return D.runKernel(Sd,u,l)}const Uv=A({transform_:Wv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gv(n,e,t){const r=C(n,"a","bandPart");I(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const s=r.shape,[o,i]=r.shape.slice(-2);let a,u;typeof e=="number"?(I(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),I(e<=o,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${o}).`),a=C(e<0?o:e,"numLower","bandPart")):(I(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),a=bn(Ei(e,0),o,Ks(e,o))),typeof t=="number"?(I(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),I(t<=i,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${i}).`),u=C(t<0?i:t,"numUpper","bandPart")):(I(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),u=bn(Ei(t,0),i,Ks(t,i)));const l=M(ts(0,o,1,"int32"),[-1,1]),h=ts(0,i,1,"int32"),c=fe(l,h),d=js(oa(c,a),vp(c,Yt(u))),f=Xn([o,i],r.dtype);return M(cn(tr(M(r,[-1,o,i])).map(m=>bn(d,m,f))),s)}const Hv=A({bandPart_:Gv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jv(n){let e;if(Array.isArray(n)){e=!1,I(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const s=n[0].shape[0];for(let o=1;o<n.length;++o)I(n[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[o].shape[0]} vs. ${s})`)}else e=!0,n=rs(n,n.shape[0],0).map(s=>Ge(s,[0]));I(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],r=n;for(let s=0;s<n.length;++s)t.push(D.tidy(()=>{let o=r[s];if(s>0)for(let i=0;i<s;++i){const a=q(Ne(q(t[i],o)),t[i]);o=fe(o,a)}return ye(o,mo(o,"euclidean"))}));return e?cn(t,0):t}const qv=A({gramSchmidt_:jv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kv(n,e=!1){if(I(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return Ju(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((u,l)=>u*l),r=tr(M(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),s=[],o=[];r.forEach(u=>{const[l,h]=Ju(u,e);s.push(l),o.push(h)});const i=M(cn(s,0),n.shape),a=M(cn(o,0),n.shape);return[i,a]}}function Ju(n,e=!1){return D.tidy(()=>{I(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],r=n.shape[1];let s=bp(t),o=yn(n);const i=Wn([[1]],[1,1]);let a=yn(i);const u=t>=r?r:t;for(let l=0;l<u;++l){const h=o,c=a,d=s;[a,o,s]=D.tidy(()=>{const f=pe(o,[l,l],[t-l,1]),m=mo(f),x=pe(o,[l,l],[1,1]),b=bn(go(x,0),Wn([[-1]]),Wn([[1]])),v=fe(x,q(b,m)),k=ye(f,v);k.shape[0]===1?a=yn(i):a=je([i,pe(k,[1,0],[k.shape[0]-1,k.shape[1]])],0);const $=Yt(ye(Se(b,v),m)),N=pe(o,[l,0],[t-l,r]),R=q($,a),O=_i(a);if(l===0)o=fe(N,Se(R,Se(O,N)));else{const L=fe(N,Se(R,Se(O,N)));o=je([pe(o,[0,0],[l,r]),L],0)}const F=_i(R),B=pe(s,[0,l],[t,s.shape[1]-l]);if(l===0)s=fe(B,Se(Se(B,a),F));else{const L=fe(B,Se(Se(B,a),F));s=je([pe(s,[0,0],[t,l]),L],1)}return[a,o,s]}),De([h,c,d])}return!e&&t>r&&(s=pe(s,[0,0],[t,r]),o=pe(o,[0,0],[r,r])),[s,o]})}const Xv=A({qr_:Kv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var rt;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(rt||(rt={}));function Yv(n,e,t=rt.SUM_BY_NONZERO_WEIGHTS){const r=C(n,"losses","computeWeightedLoss");let s=null;e!=null&&(s=C(e,"weights","computeWeightedLoss"));const o=s==null?r:q(r,s);if(t===rt.NONE)return o;if(t===rt.SUM)return Ne(o);if(t===rt.MEAN){if(s==null)return qs(o);{const i=r.size/s.size,a=ye(Ne(o),Ne(s));return i>1?ye(a,we(i)):a}}if(t===rt.SUM_BY_NONZERO_WEIGHTS){if(s==null)return ye(Ne(o),we(r.size));{const i=q(s,Bn(r.shape)),a=Pe(Ne(_p(i,we(0))),"float32");return ye(Ne(o),a)}}throw Error(`Unknown reduction: ${t}`)}const hn=A({computeWeightedLoss_:Yv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qv(n,e,t,r=rt.SUM_BY_NONZERO_WEIGHTS){const s=C(n,"labels","absoluteDifference"),o=C(e,"predictions","absoluteDifference");let i=null;t!=null&&(i=C(t,"weights","absoluteDifference")),bt(s.shape,o.shape,"Error in absoluteDifference: ");const a=gt(fe(s,o));return hn(a,i,r)}const Zv=A({absoluteDifference_:Qv});function Jv(n,e,t,r,s=rt.SUM_BY_NONZERO_WEIGHTS){const o=C(n,"labels","cosineDistance"),i=C(e,"predictions","cosineDistance");let a=null;r!=null&&(a=C(r,"weights","cosineDistance")),bt(o.shape,i.shape,"Error in cosineDistance: ");const u=we(1),l=fe(u,Ne(q(o,i),t,!0));return hn(l,a,s)}const eS=A({cosineDistance_:Jv});function tS(n,e,t,r=rt.SUM_BY_NONZERO_WEIGHTS){let s=C(n,"labels","hingeLoss");const o=C(e,"predictions","hingeLoss");let i=null;t!=null&&(i=C(t,"weights","hingeLoss")),bt(s.shape,o.shape,"Error in hingeLoss: ");const a=we(1);s=fe(q(we(2),s),a);const u=bo(fe(a,q(s,o)));return hn(u,i,r)}const nS=A({hingeLoss_:tS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rS(n,e,t,r=1,s=rt.SUM_BY_NONZERO_WEIGHTS){const o=C(n,"labels","huberLoss"),i=C(e,"predictions","huberLoss");let a=null;t!=null&&(a=C(t,"weights","huberLoss")),bt(o.shape,i.shape,"Error in huberLoss: ");const u=we(r),l=gt(fe(i,o)),h=Ks(l,u),c=fe(l,h),d=ie(q(we(.5),Pt(h)),q(u,c));return hn(d,a,s)}const sS=A({huberLoss_:rS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oS(n,e,t,r=1e-7,s=rt.SUM_BY_NONZERO_WEIGHTS){const o=C(n,"labels","logLoss"),i=C(e,"predictions","logLoss");let a=null;t!=null&&(a=C(t,"weights","logLoss")),bt(o.shape,i.shape,"Error in logLoss: ");const u=we(1),l=we(r),h=Yt(q(o,es(ie(i,l)))),c=q(fe(u,o),es(ie(fe(u,i),l))),d=fe(h,c);return hn(d,a,s)}const iS=A({logLoss_:oS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aS(n,e,t,r=rt.SUM_BY_NONZERO_WEIGHTS){const s=C(n,"labels","meanSquaredError"),o=C(e,"predictions","meanSquaredError");let i=null;t!=null&&(i=C(t,"weights","meanSquaredError")),bt(s.shape,o.shape,"Error in meanSquaredError: ");const a=Lp(s,o);return hn(a,i,r)}const uS=A({meanSquaredError_:aS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lS(n,e){const t=C(n,"labels","sigmoidCrossEntropyWithLogits"),r=C(e,"logits","sigmoidCrossEntropyWithLogits");bt(t.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const s=bo(r),o=q(r,t),i=Cp(un(Yt(gt(r))));return ie(fe(s,o),i)}function cS(n,e,t,r=0,s=rt.SUM_BY_NONZERO_WEIGHTS){let o=C(n,"multiClassLabels","sigmoidCrossEntropy");const i=C(e,"logits","sigmoidCrossEntropy");let a=null;if(t!=null&&(a=C(t,"weights","sigmoidCrossEntropy")),bt(o.shape,i.shape,"Error in sigmoidCrossEntropy: "),r>0){const l=we(r),h=we(1),c=we(.5);o=ie(q(o,fe(h,l)),q(c,l))}const u=lS(o,i);return hn(u,a,s)}const hS=A({sigmoidCrossEntropy_:cS});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dS(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return ln((s,o,i)=>{const u=kp(o,[t],!0),l=fe(Pe(o,"float32"),u);i([s,l]);const h=Yt(q(l,s));return{value:Ne(h,[t]),gradFunc:(f,m)=>{const[x,b]=m,v=hs(f.shape,[t]);return[q(M(f,v),fe(Pe(x,"float32"),un(b))),q(M(f,v),fe(un(b),Pe(x,"float32")))]}}})(n,e)}function pS(n,e,t,r=0,s=rt.SUM_BY_NONZERO_WEIGHTS){let o=C(n,"onehotLabels","softmaxCrossEntropy");const i=C(e,"logits","softmaxCrossEntropy");let a=null;if(t!=null&&(a=C(t,"weights","softmaxCrossEntropy")),bt(o.shape,i.shape,"Error in softmaxCrossEntropy: "),r>0){const l=we(r),h=we(1),c=we(o.shape[1]);o=ie(q(o,fe(h,l)),ye(l,c))}const u=dS(o,i);return hn(u,a,s)}const fS=A({softmaxCrossEntropy_:pS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mS(n,e,t,r){const s=C(n,"indices","sparseFillEmptyRows","int32"),o=C(e,"values","sparseFillEmptyRows"),i=C(t,"denseShape","sparseFillEmptyRows","int32"),a=C(r,"defaultValue","sparseFillEmptyRows",o.dtype);if(s.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${s.shape}`);if(o.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${o.shape}`);if(i.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${i.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const u={indices:s,values:o,denseShape:i,defaultValue:a},l=D.runKernel(dg,u);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}const gS=A({sparseFillEmptyRows_:mS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yS(n,e,t){const r=C(n,"inputIndices","sparseReshape","int32"),s=C(e,"inputShape","sparseReshape","int32"),o=C(t,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(s.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${s.shape}`);if(o.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${o.shape}`);const i={inputIndices:r,inputShape:s,newShape:o},a=D.runKernel(pg,i);return{outputIndices:a[0],outputShape:a[1]}}const bS=A({sparseReshape_:yS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wS(n,e,t){const r=C(n,"data","sparseSegmentMean"),s=C(e,"indices","sparseSegmentMean","int32"),o=C(t,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${o.shape}`);const i={data:r,indices:s,segmentIds:o};return D.runKernel(dd,i)}const xS=A({sparseSegmentMean_:wS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vS(n,e,t){const r=C(n,"data","sparseSegmentSum"),s=C(e,"indices","sparseSegmentSum","int32"),o=C(t,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(s.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${s.shape}`);if(o.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${o.shape}`);const i={data:r,indices:s,segmentIds:o};return D.runKernel(pd,i)}const SS=A({sparseSegmentSum_:vS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CS(n,e,t,r,s,o,i,a){const u=C(n,"data","stringNGrams","string");if(u.dtype!=="string")throw new Error("Data must be of datatype string");if(u.shape.length!==1)throw new Error(`Data must be a vector, saw: ${u.shape}`);const l=C(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const h={separator:t,nGramWidths:r,leftPad:s,rightPad:o,padWidth:i,preserveShortSequences:a},c={data:u,dataSplits:l},d=D.runKernel(yd,c,h);return{nGrams:d[0],nGramsSplits:d[1]}}const IS=A({stringNGrams_:CS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kS(n,e,t=!0){const r=C(n,"input","stringSplit","string"),s=C(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(s.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${s.shape}`);const o={skipEmpty:t},i={input:r,delimiter:s},a=D.runKernel(gg,i,o);return{indices:a[0],values:a[1],shape:a[2]}}const NS=A({stringSplit_:kS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $S(n,e){const t=C(n,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const s={input:t};return D.runKernel(yg,s,r)}const TS=A({stringToHashBucketFast_:$S});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ES(n,e,t,r=!0){const s=C(n,"input","staticRegexReplace","string"),o={pattern:e,rewrite:t,replaceGlobal:r};return D.runKernel(mg,{x:s},o)}const _S=A({staticRegexReplace_:ES});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AS={fft:ga,ifft:Xs,rfft:ya,irfft:zp},RS={hammingWindow:tv,hannWindow:Gp,frame:Hp,stft:ov},wo={flipLeftRight:lv,grayscaleToRGB:hv,resizeNearestNeighbor:Lv,resizeBilinear:Fv,rgbToGrayscale:pv,rotateWithOffset:mv,cropAndResize:av,nonMaxSuppression:yv,nonMaxSuppressionAsync:Nv,nonMaxSuppressionWithScore:Tv,nonMaxSuppressionWithScoreAsync:_v,nonMaxSuppressionPadded:Rv,nonMaxSuppressionPaddedAsync:Pv,threshold:Vv,transform:Uv},DS={bandPart:Hv,gramSchmidt:qv,qr:Xv},PS={absoluteDifference:Zv,computeWeightedLoss:hn,cosineDistance:eS,hingeLoss:nS,huberLoss:sS,logLoss:iS,meanSquaredError:uS,sigmoidCrossEntropy:hS,softmaxCrossEntropy:fS},OS={sparseFillEmptyRows:gS,sparseReshape:bS,sparseSegmentMean:xS,sparseSegmentSum:SS},FS={stringNGrams:IS,stringSplit:NS,stringToHashBucketFast:TS,staticRegexReplace:_S};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zS=new Map,LS=new Map;class BS{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Pn{constructor(){this.classNameMap={}}static getMap(){return Pn.instance==null&&(Pn.instance=new Pn),Pn.instance}static register(e){Pn.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function MS(n,e,t){I(n.className!=null,()=>"Class being registered does not have the static className property defined."),I(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),I(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const r=t,s=e+">"+r;return Pn.register(n),zS.set(s,n),LS.set(n,s),n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nr extends BS{minimize(e,t=!1,r){const{value:s,grads:o}=this.computeGradients(e,r);if(r!=null){const i=r.map(a=>({name:a.name,tensor:o[a.name]}));this.applyGradients(i)}else this.applyGradients(o);return De(o),t?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return Sw(e,t)}dispose(){this.iterations_!=null&&De(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:we(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(nr,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VS extends nr{static get className(){return"Adadelta"}constructor(e,t,r=null){super(),this.learningRate=e,this.rho=t,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=D.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=D.registeredVariables[r],i=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accum_grad`,variable:be(()=>yt(o).variable(i))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${r}/accum_var`,variable:be(()=>yt(o).variable(i))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const u=this.accumulatedGrads[s].variable,l=this.accumulatedUpdates[s].variable;be(()=>{const h=ie(q(u,this.rho),q(Pt(a),1-this.rho)),c=q(ye(an(ie(l,this.epsilon)),an(ie(u,this.epsilon))),a),d=ie(q(l,this.rho),q(Pt(c),1-this.rho));u.assign(h),l.assign(d);const f=ie(q(c,-this.learningRate),o);o.assign(f)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(De(this.accumulatedGrads.map(e=>e.variable)),De(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedUpdates=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WS extends nr{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=D.registeredVariables[r];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${r}/accumulator`,variable:be(()=>cs(o.shape,this.initialAccumulatorValue).variable(!1))});const i=Array.isArray(e)?e[s].tensor:e[r];if(i==null)return;const a=this.accumulatedGrads[s].variable;be(()=>{const u=ie(a,Pt(i));a.assign(u);const l=ie(q(ye(i,an(ie(u,D.backend.epsilon()))),-this.learningRate),o);o.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&De(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class US extends nr{static get className(){return"Adam"}constructor(e,t,r,s=null){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],be(()=>{this.accBeta1=we(t).variable(),this.accBeta2=we(r).variable()}),s==null&&(this.epsilon=D.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);be(()=>{const r=fe(1,this.accBeta1),s=fe(1,this.accBeta2);t.forEach((o,i)=>{const a=D.registeredVariables[o],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:be(()=>yt(a).variable(u))}),this.accumulatedSecondMoment[i]==null&&(this.accumulatedSecondMoment[i]={originalName:`${o}/v`,variable:be(()=>yt(a).variable(u))});const l=Array.isArray(e)?e[i].tensor:e[o];if(l==null)return;const h=this.accumulatedFirstMoment[i].variable,c=this.accumulatedSecondMoment[i].variable,d=ie(q(h,this.beta1),q(l,1-this.beta1)),f=ie(q(c,this.beta2),q(Pt(l),1-this.beta2)),m=ye(d,r),x=ye(f,s);h.assign(d),c.assign(f);const b=ie(q(ye(m,ie(an(x),this.epsilon)),-this.learningRate),a);a.assign(b)}),this.accBeta1.assign(q(this.accBeta1,this.beta1)),this.accBeta2.assign(q(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&De(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&De(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),be(()=>{this.accBeta1.assign(Jr(this.beta1,this.iterations_+1)),this.accBeta2.assign(Jr(this.beta2,this.iterations_+1))});const t=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GS extends nr{static get className(){return"Adamax"}constructor(e,t,r,s=null,o=0){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=s,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],be(()=>{this.iteration=we(0).variable(),this.accBeta1=we(t).variable()}),s==null&&(this.epsilon=D.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);be(()=>{const r=fe(1,this.accBeta1),s=ye(-this.learningRate,ie(q(this.iteration,this.decay),1));t.forEach((o,i)=>{const a=D.registeredVariables[o],u=!1;this.accumulatedFirstMoment[i]==null&&(this.accumulatedFirstMoment[i]={originalName:`${o}/m`,variable:yt(a).variable(u)}),this.accumulatedWeightedInfNorm[i]==null&&(this.accumulatedWeightedInfNorm[i]={originalName:`${o}/v`,variable:yt(a).variable(u)});const l=Array.isArray(e)?e[i].tensor:e[o];if(l==null)return;const h=this.accumulatedFirstMoment[i].variable,c=this.accumulatedWeightedInfNorm[i].variable,d=ie(q(h,this.beta1),q(l,1-this.beta1)),f=q(c,this.beta2),m=gt(l),x=Ep(f,m);h.assign(d),c.assign(x);const b=ie(q(ye(s,r),ye(d,ie(x,this.epsilon))),a);a.assign(b)}),this.iteration.assign(ie(this.iteration,1)),this.accBeta1.assign(q(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&De(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&De(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Kp extends nr{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=Array.isArray(e)?e[s].tensor:e[r];if(o==null)return;const i=D.registeredVariables[r];be(()=>{const a=ie(q(this.c,o),i);i.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=qt(we(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HS extends Kp{static get className(){return"Momentum"}constructor(e,t,r=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=r,this.accumulations=[],this.m=we(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=D.registeredVariables[r];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${r}/momentum`,variable:be(()=>yt(o).variable(!1))});const i=this.accumulations[s].variable,a=Array.isArray(e)?e[s].tensor:e[r];a!=null&&be(()=>{let u;const l=ie(q(this.m,i),a);this.useNesterov?u=ie(q(this.c,ie(a,q(l,this.m))),o):u=ie(q(this.c,l),o),i.assign(l),o.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&De(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jS extends nr{static get className(){return"RMSProp"}constructor(e,t=.9,r=0,s=null,o=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=r,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,s==null&&(this.epsilon=D.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,s)=>{const o=D.registeredVariables[r],i=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${r}/rms`,variable:be(()=>yt(o).variable(i))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${r}/momentum`,variable:be(()=>yt(o).variable(i))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${r}/mg`,variable:be(()=>yt(o).variable(i))});const a=Array.isArray(e)?e[s].tensor:e[r];if(a==null)return;const u=this.accumulatedMeanSquares[s].variable,l=this.accumulatedMoments[s].variable;be(()=>{const h=ie(q(u,this.decay),q(Pt(a),1-this.decay));if(this.centered){const c=this.accumulatedMeanGrads[s].variable,d=ie(q(c,this.decay),q(a,1-this.decay)),f=ye(q(a,this.learningRate),an(fe(h,ie(Pt(d),this.epsilon)))),m=ie(q(l,this.momentum),f);u.assign(h),c.assign(d),l.assign(m);const x=fe(o,m);o.assign(x)}else{const c=ie(q(u,this.decay),q(Pt(a),1-this.decay)),d=ie(q(l,this.momentum),ye(q(a,this.learningRate),an(ie(c,this.epsilon))));u.assign(c),l.assign(d);const f=fe(o,d);o.assign(f)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&De(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&De(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&De(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,t).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.accumulatedMoments=e.slice(t,t*2).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(s=>({originalName:s.name,variable:s.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qS=[VS,WS,US,GS,HS,jS,Kp];function KS(){for(const n of qS)MS(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XS="model",YS=".json",QS=".weights.bin";function el(n){return new Promise(e=>setTimeout(e)).then(n)}class Qn{constructor(e){if(!oe().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Qn.URL_SCHEME)&&(e=e.slice(Qn.URL_SCHEME.length)),(e==null||e.length===0)&&(e=XS),this.modelJsonFileName=e+YS,this.weightDataFileName=e+QS}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Lt.join(e.weightData),r=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],o=Yd(e,s),i=window.URL.createObjectURL(new Blob([JSON.stringify(o)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=i,await el(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const u=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;u.download=this.weightDataFileName,u.href=r,await el(()=>u.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:ls(e)}}}}Qn.URL_SCHEME="downloads://";class ZS{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const r=new FileReader;r.onload=s=>{const o=JSON.parse(s.target.result),i=o.modelTopology;if(i==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(o.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:i});return}const u=ta(o,l=>this.loadWeights(l));e(u)},r.onerror=s=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){const t=[],r=[];for(const i of e)t.push(...i.weights),r.push(...i.paths);const s=this.checkManifestAndWeightFiles(e),o=r.map(i=>this.loadWeightsFile(i,s[i]));return Promise.all(o).then(i=>[t,i])}loadWeightsFile(e,t){return new Promise((r,s)=>{const o=new FileReader;o.onload=i=>{const a=i.target.result;r(a)},o.onerror=i=>s(`Failed to weights data from file of path '${e}'.`),o.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],r=this.weightsFiles.map(o=>Qu(o.name)),s={};for(const o of e)o.paths.forEach(i=>{const a=Qu(i);if(t.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(t.push(a),r.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);s[i]=this.weightsFiles[r.indexOf(a)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return s}}const JS=n=>oe().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Qn.URL_SCHEME)?eC(n.slice(Qn.URL_SCHEME.length)):null;Re.registerSaveRouter(JS);function eC(n="model"){return new Qn(n)}function tC(n){return new ZS(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tl(n,e,t,r){i(n),t=t??0,r=r??1,a(t,r);let s=0;const o=u=>(u.then(l=>{const h=t+ ++s/n.length*(r-t);return e(h),l}),u);function i(u){I(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function a(u,l){I(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),I(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),I(l>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${l}`)}return Promise.all(n.map(o))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Xp(n,e){e==null&&(e={});const t=e.fetchFunc==null?oe().platform.fetch:e.fetchFunc,r=n.map(c=>t(c,e.requestInit,{isBinary:!0})),a=(e.onProgress==null?await Promise.all(r):await tl(r,e.onProgress,0,.5)).map(c=>c.arrayBuffer());return e.onProgress==null?await Promise.all(a):await tl(a,e.onProgress,.5,1)}function nC(n,e){var t;const r=e.fetchFunc==null?oe().platform.fetch:e.fetchFunc;let s=0,o;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async i=>{for(var a;s<n.length;){o||(o=(await r(n[s],e.requestInit,{isBinary:!0})).body.getReader());const{done:u,value:l}=await o.read();if(u){s++,o=void 0,(a=e.onProgress)===null||a===void 0||a.call(e,s/n.length);continue}i.enqueue(l);return}i.close()}})}async function rC(n,e="",t,r){return Yp(i=>Xp(i,{requestInit:r}))(n,e,t)}function Yp(n){return async(e,t="",r)=>{const s=e.map(()=>!1),o={},i=r!=null?r.map(()=>!1):[],a=[];if(e.forEach((f,m)=>{let x=0;f.weights.forEach(b=>{const v="quantization"in b?b.quantization.dtype:b.dtype,k=jn[v]*H(b.shape),$=()=>{s[m]=!0,o[m]==null&&(o[m]=[]),o[m].push({manifestEntry:b,groupOffset:x,sizeBytes:k})};r!=null?r.forEach((N,R)=>{N===b.name&&($(),i[R]=!0)}):$(),a.push(b.name),x+=k})}),!i.every(f=>f)){const f=r.filter((m,x)=>!i[x]);throw new Error(`Could not find weights in manifest with names: ${f.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const u=s.reduce((f,m,x)=>(m&&f.push(x),f),[]),l=[];u.forEach(f=>{e[f].paths.forEach(m=>{const x=t+(t.endsWith("/")?"":"/")+m;l.push(x)})});const h=await n(l),c={};let d=0;return u.forEach(f=>{const m=e[f].paths.length,x=new Lt(h.slice(d,d+m));o[f].forEach(v=>{const k=x.slice(v.groupOffset,v.groupOffset+v.sizeBytes),$=qd(k,[v.manifestEntry]);for(const N in $)c[N]=$[N]}),d+=m}),c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sC="application/octet-stream",oC="application/json";class ka{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(I(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=oe().platform.fetch,I(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&I(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],s=Yd(e,r);if(t.body.append("model.json",new Blob([JSON.stringify(s)],{type:oC}),"model.json"),e.weightData!=null){const i=Lt.join(e.weightData);t.body.append("model.weights.bin",new Blob([i],{type:sC}),"model.weights.bin")}const o=await this.fetch(this.path,t);if(o.ok)return{modelArtifactsInfo:ls(e),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let i=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?i+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":i+=" Please make sure the server is serving valid JSON for this request.",new Error(i)}const r=t.modelTopology,s=t.weightsManifest;if(r==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return ta(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),r=Si(e.weightsManifest),s=()=>nC(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:r,getWeightStream:s})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[r,s]=iC(t),o=this.weightPathPrefix||r,i=[],a=[];for(const u of e)for(const l of u.paths)this.weightUrlConverter!=null?a.push(this.weightUrlConverter(l)):i.push(o+l+s);return this.weightUrlConverter&&i.push(...await Promise.all(a)),i}async loadWeights(e){const t=await this.getWeightUrls(e),r=Si(e),s=await Xp(t,this.loadOptions);return[r,s]}}ka.URL_SCHEME_REGEX=/^https?:\/\//;function iC(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),r=n.substring(0,e),s=t>e?n.substring(t):"";return[r+"/",s]}function Ai(n){return n.match(ka.URL_SCHEME_REGEX)!=null}const Qp=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(r=>Ai(r)):t=Ai(n),t)return Na(n,e)}return null};Re.registerSaveRouter(Qp);Re.registerLoadRouter(Qp);function Na(n,e){return new ka(n,e)}function aC(n,e){return Na(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zo{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class Zp{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class uC{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function lC(n,e,t,r){const s=arguments;return new uC(Jp(...s))}function Jp(n,e,t,r){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new Zo(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Zo({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new Zo({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:r}))}function cC(n){return new Zp(n)}function hC(n){return new Zp(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ef=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:Lt,browserFiles:tC,browserHTTPRequest:aC,concatenateArrayBuffers:iy,copyModel:Ty,decodeWeights:qd,decodeWeightsStream:Xd,encodeWeights:ey,fromMemory:lC,fromMemorySync:Jp,getLoadHandlers:fy,getModelArtifactsForJSON:ta,getModelArtifactsForJSONSync:Qd,getModelArtifactsInfoForJSON:ls,getSaveHandlers:py,getWeightSpecs:Si,http:Na,isHTTPScheme:Ai,listModels:Ny,loadWeights:rC,moveModel:Ey,registerLoadRouter:dy,registerSaveRouter:hy,removeModel:$y,weightsLoaderFactory:Yp,withSaveHandler:cC,withSaveHandlerSync:hC},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let _n;function dC(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,r=!1,s=!1,o=!1,i=!1,a=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)o=!0;else if(n.getContext!=null)i=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(mi(hi,D.backendName)!=null){const m={pixels:n},x={numChannels:e};return D.runKernel(hi,m,x)}const[l,h]=s?[n.videoWidth,n.videoHeight]:[n.width,n.height];let c;if(i)c=n.getContext("2d").getImageData(0,0,l,h).data;else if(r||t)c=n.data;else if(o||s||a){if(_n==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")_n=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else _n=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});_n.canvas.width=l,_n.canvas.height=h,_n.drawImage(n,0,0,l,h),c=_n.getImageData(0,0,l,h).data}let d;if(e===4)d=new Int32Array(c);else{const m=l*h;d=new Int32Array(m*e);for(let x=0;x<m;x++)for(let b=0;b<e;++b)d[x*e+b]=c[x*4+b]}return Mp(d,[h,l,e],"int32")}function pC(n){if(n.rank!==2&&n.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${n.rank}.`);const e=n.rank===2?1:n.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(n.dtype!=="float32"&&n.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${n.dtype}. Please use float32 or int32 tensors.`)}async function fC(n,e){let t=C(n,"img","toPixels");if(!(n instanceof Be)){const l=t;t=Pe(l,"int32"),l.dispose()}pC(t);const[r,s]=t.shape.slice(0,2),o=t.rank===2?1:t.shape[2],i=await t.data(),a=t.dtype==="float32"?255:1,u=new Uint8ClampedArray(s*r*4);for(let l=0;l<r*s;++l){const h=[0,0,0,255];for(let d=0;d<o;d++){const f=i[l*o+d];if(t.dtype==="float32"){if(f<0||f>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${f}.`)}else if(t.dtype==="int32"&&(f<0||f>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${f}.`);o===1?(h[0]=f*a,h[1]=f*a,h[2]=f*a):h[d]=f*a}const c=l*4;u[c+0]=Math.round(h[0]),u[c+1]=Math.round(h[1]),u[c+2]=Math.round(h[2]),u[c+3]=Math.round(h[3])}return t!==n&&t.dispose(),u}const mC=A({fromPixels_:dC});function gC(n,e){const t=n.shape.length,r=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${t}`);if(H(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const s=e.shape,o=s[s.length-1];let i=1;for(let c=0;c<s.length-1;++c)i*=s[c];const a=n.shape,u=s.slice();u.pop();let l=1;for(let c=o;c<t;++c)l*=a[c],u.push(a[c]);const h=[...Qe(n.shape).map(c=>c/l),1].slice(0,o);return[u,i,l,h]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ri=-2,yC=-1;function bC(n,e,t){const r=n.shape.length;I(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),I(r===t.length,()=>`Error in slice${r}D: Length of size ${t} must match the rank of the array (${r}).`);for(let s=0;s<r;++s)I(e[s]+t[s]<=n.shape[s],()=>`Error in slice${r}D: begin[${s}] + size[${s}] (${e[s]+t[s]}) would overflow input.shape[${s}] (${n.shape[s]})`)}function wC(n,e,t){const r=[];for(let s=0;s<n.length;s++)r[s]=Math.ceil((e[s]-n[s])/t[s]);return r}function xC(n,e,t){let r=t.length;for(let s=0;s<t.length;s++)if(t[s]>1){r=s;break}for(let s=r+1;s<t.length;s++)if(e[s]>0||t[s]!==n[s])return!1;return!0}function vC(n,e){let t=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)t+=n[r]*e[r];return t}function SC(n,e,t){let r;const s=n.shape.length;typeof e=="number"?r=[e,...new Array(s-1).fill(0)]:e.length<s?r=e.concat(new Array(s-e.length).fill(0)):r=e.slice(),r.forEach(i=>{I(i!==-1,()=>"slice() does not support negative begin indexing.")});let o;return t==null?o=new Array(s).fill(-1):typeof t=="number"?o=[t,...new Array(s-1).fill(-1)]:t.length<s?o=t.concat(new Array(s-t.length).fill(-1)):o=t,o=o.map((i,a)=>i>=0?i:(I(i===-1,()=>`Negative size values should be exactly -1 but got ${i} for the slice() size at index ${a}.`),n.shape[a]-r[a])),[r,o]}function CC(n,e,t,r,s,o,i,a,u){let l;if(r==null?(l=new Array(e.length),l.fill(1)):l=r,i!=null&&i&i-1)throw new Error("Multiple ellipses in slice is not allowed.");let h=!1;const c={dims:l.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:l.slice(),beginMask:s,endMask:o,ellipsisMask:i,newAxisMask:a,shrinkAxisMask:u};for(let $=0;$<c.dims;$++)h&&1<<$&a&&c.numAddAxisAfterEllipsis++,1<<$&i&&(h=!0);h||(c.ellipsisMask|=1<<c.dims,c.dims++);const d={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};IC(c,d);let f=!0,m=!0,x=!0;const b=[],v=[];for(let $=0;$<n.length;++$){if(d.strides[$]===0)throw Error(`strides[${$}] must be non-zero`);const N=!!(d.shrinkAxisMask&1<<$),R=n[$];if(R===-1){b.push(N?1:-1);continue}const O=[d.beginMask&1<<$,d.endMask&1<<$],F=[d.strides[$]>0?0:-1,d.strides[$]>0?R:R-1];if(N&&d.strides[$]<=0)throw Error("only stride 1 allowed on non-range indexing.");x=x&&d.strides[$]===1;const B=!!(d.beginMask&1<<$&&d.endMask&1<<$);if(d.beginValid&&d.endValid){if(N){const ee=d.begin[$]<0?R+d.begin[$]:d.begin[$];if(d.begin[$]=ee,d.end[$]=d.begin[$]+1,ee<0||ee>=R)throw Error(`slice index ${d.begin[$]} of dimension ${$} out of bounds.`)}else d.begin[$]=nl(d.begin[$],0,d.strides[$],R,O,F),d.end[$]=nl(d.end[$],1,d.strides[$],R,O,F);const V=d.strides[$]===1&&d.begin[$]===0&&d.end[$]===R;f=f&&V,m=m&&($===0&&d.strides[$]===1||V)}else f=f&&d.strides[$]===1&&B,m=m&&($===0&&d.strides[$]===1||B);let L,W=!1;if(d.beginValid&&d.endValid?(L=d.end[$]-d.begin[$],W=!0):N?(L=1,W=!0):B&&R>=0&&(d.strides[$]<0?L=-R:L=R,W=!0),W){let V;L===0||L<0!=d.strides[$]<0?V=0:V=Math.trunc(L/d.strides[$])+(L%d.strides[$]!==0?1:0),b.push(V)}else b.push(-1)}for(let $=0;$<d.finalShapeGatherIndices.length;++$){const N=d.finalShapeGatherIndices[$];N>=0?v.push(b[N]):N===Ri&&v.push(1)}return{finalShapeSparse:v.filter(($,N)=>d.finalShapeGatherIndices[N]!==Ri),finalShape:v,isIdentity:f,sliceDim0:m,isSimpleSlice:x,begin:d.begin,end:d.end,strides:d.strides}}function IC(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const s=Math.min(e.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<s;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=r}else if(1<<r&n.newAxisMask)e.finalShapeGatherIndices.push(Ri),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[r]),n.end!=null&&(e.end[t]=n.end[r]),e.strides[t]=n.strides[r],n.beginMask&1<<r&&(e.beginMask|=1<<t),n.endMask&1<<r&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(yC),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[t]=r,t++}}function nl(n,e,t,r,s,o){if(s[e])return t>0?o[e]:o[e+1&1];{const i=n<0?r+n:n;return i<o[0]?o[0]:i>o[1]?o[1]:i}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kC(n,e){const t=n[0].length;n.forEach((s,o)=>{I(s.length===t,()=>`Error in concat${t}D: rank of tensors[${o}] must be the same as the rank of the rest (${t})`)}),I(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const r=n[0];n.forEach((s,o)=>{for(let i=0;i<t;i++)I(i===e||s[i]===r[i],()=>`Error in concat${t}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${r}) along the non-concatenated axis ${o}.`)})}function ss(n,e){const t=n[0].slice();for(let r=1;r<n.length;r++)t[e]+=n[r][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var jt;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(jt||(jt={}));function NC(n,e,t){let r=new Array;if(t==null&&e==null)return r;if(e==null)for(;r.length<n+t.length;)r.push(-1);else r=e.slice();if(t==null)return r;if(n+t.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${r.length}`);for(let s=1;s<t.length;++s){const o=t[s],i=r[r.length-t.length+s],a=r[i];if(o>=0)if(a>=0){if(a!==o)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${s+n}] = ${o} but shape[${s+n}] = ${a}`)}else r[i]=o}return r}function $C(n){const e={FIRST_DIM_SIZE:jt.FIRST_DIM_SIZE,VALUE_ROWIDS:jt.VALUE_ROWIDS,ROW_LENGTHS:jt.ROW_LENGTHS,ROW_SPLITS:jt.ROW_SPLITS,ROW_LIMITS:jt.ROW_LIMITS,ROW_STARTS:jt.ROW_STARTS},t=[];for(const r of n)if(r in e)t.push(e[r]);else break;return t}function TC(n){return n.length===0?0:n[0]===jt.FIRST_DIM_SIZE?n.length-1:n.length}function EC(n,e){if(n==null||e==null)return;const t=n.length,r=e.length;if(t>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${r})`);for(let s=0;s<Math.min(t,r-1);++s){const o=n[s],i=e[s+1];if(o>=0&&i>=0&&o!==1&&o!==i)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${s-n.length}] = ${o} but ragged tensor input.flatValues.shape[${s-n.length}] = ${i}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _C(n,e,t){const r=t*(typeof n=="number"?n:n[0]),s=e*(typeof n=="number"?n:n[1]);return[r,s]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tf(n,e,t,r=!0){let s=[];if(r)s=s.concat(e.slice(0)),s.push(n[0]/t),s=s.concat(n.slice(1));else{s=s.concat(n[0]);const o=e.length;for(let i=0;i<o;++i)s=s.concat([n[i+1]/e[i],e[i]]);s=s.concat(n.slice(o+1))}return s}function nf(n,e,t=!0){const r=[];if(t){r.push(e);for(let s=e+1;s<n;++s)s<=2*e?(r.push(s),r.push(s-(e+1))):r.push(s)}else{const s=[],o=[];for(let i=1;i<n;++i)i>=e*2+1||i%2===1?o.push(i):s.push(i);r.push(...s),r.push(0),r.push(...o)}return r}function rf(n,e,t,r=!0){const s=[];r?s.push(n[0]/t):s.push(n[0]*t);for(let o=1;o<n.length;++o)o<=e.length?r?s.push(e[o-1]*n[o]):s.push(n[o]/e[o-1]):s.push(n[o]);return s}function AC(n,e){const t=[0];for(let r=0;r<e;++r)t.push(n[r][0]);return t}function RC(n,e,t){const r=n.slice(0,1);for(let s=0;s<t;++s)r.push(n[s+1]-e[s][0]-e[s][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DC=1.7580993408473768,PC=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OC=.3275911,FC=.254829592,zC=-.284496736,LC=1.421413741,BC=-1.453152027,MC=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rl(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let r=0;r<t.length;r+=2)t[r]=n[r/2],t[r+1]=e[r/2];return t}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jo="->",VC=/->/g,sl=",",ol="...";function WC(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(VC,"").length)/Jo.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${Jo}").`);const[r,s]=n.split(Jo);I(r.indexOf(ol)===-1,()=>`The ellipsis notation ("${ol}") is not supported yet.`);const o=r.split(sl),i=o.length;if(e!==i)throw new Error(`Expected ${i} input tensors, received ${e}`);if(i>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let d=0;d<s.length;++d){const f=s[d];if(!o.some(m=>m.indexOf(f)!==-1))throw new Error(`Output subscripts contain the label ${f} not present in the input subscripts.`);a.indexOf(f)===-1&&a.push(f)}for(let d=0;d<r.length;++d){const f=r[d];a.indexOf(f)===-1&&f!==sl&&a.push(f)}const u=new Array(o.length);for(let d=0;d<i;++d){if(new Set(o[d].split("")).size!==o[d].length)throw new Error(`Found duplicate axes in input component ${o[d]}. Support for duplicate axes in input is not implemented yet.`);u[d]=[];for(let f=0;f<o[d].length;++f)u[d].push(a.indexOf(o[d][f]))}const l=a.length,h=s.length,c=[];for(let d=h;d<l;++d)c.push(d);return{allDims:a,summedDims:c,idDims:u}}function UC(n,e){let t=new Array(n);t.fill(-1);for(let s=0;s<e.length;++s)t[e[s]]=s;const r=[];for(let s=0;s<n;++s)t[s]===-1&&r.push(s);return t=t.filter(s=>s!==-1),{permutationIndices:t,expandDims:r}}function GC(n,e,t){const r=new Array(n);for(let s=0;s<t.length;++s){const o=t[s].shape;for(let i=0;i<e[s].length;++i)r[e[s][i]]===void 0?r[e[s][i]]=o[i]:I(r[e[s][i]]===o[i],()=>`Expected dimension ${r[e[s][i]]} at axis ${i} of input shaped ${JSON.stringify(o)}, but got dimension ${o[i]}`)}}function HC(n,e){const t=n,r=[];let s=0;n.length===0&&t.push(-1),s=n.length+1;for(let i=0;i<s;++i)r.push([]);const o=[];for(let i=0;i<t.length;++i){const a=t[i],u=qC(e,a);for(const l of u)o.indexOf(l)===-1&&(r[i].push(l),o.push(l))}return{path:t,steps:r}}function jC(n){return n.every((e,t)=>e===t)}function qC(n,e){const t=[];for(let r=0;r<n.length;++r)(n[r].length===0||n[r].indexOf(e)!==-1||e===-1)&&t.push(r);return t}function KC(n,e,t=0){let r=[];if(typeof e=="number")I(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(n.shape[t]/e);else{const s=e.reduce((i,a)=>(a===-1&&(i+=1),i),0);I(s<=1,()=>"There should be only one negative value in split array.");const o=e.indexOf(-1);if(o!==-1){const i=e.reduce((a,u)=>u>0?a+u:a);e[o]=n.shape[t]-i}I(n.shape[t]===e.reduce((i,a)=>i+a),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XC(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function YC(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function QC(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZC(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function JC(n,e){return`size ${n} must be non-negative, not ${e}`}function eI(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function tI(n,e){const t=H(n),r=H(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${n} outputShape= ${e}`}function nI(n,e){const t=H(n),r=H(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${r}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function il(){return"segment ids must be >= 0"}function rI(){return"segment ids are not increasing"}function sI(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function oI(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iI(n,e,t){const r=[],s=n.length;for(let o=0;o<s;o++)o!==e?r.push(n[o]):r.push(t);return r}function aI(n,e,t,r){const s=e.shape.length,o=n.shape.length;if(r!==0&&(r<-s||r>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${r}`);if(r<0&&(r+=s),r>o)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${o}).`);if(t<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${t}).`);for(let c=0;c<r;++c)if(n.shape[c]!==e.shape[c])throw new Error(`x.shape[${c}]: ${n.shape[c]} should be equal to indices.shape[${c}]: ${e.shape[c]}.`);const i=n.shape[t],a=[];let u=1,l=1,h=1;for(let c=0;c<r;++c)a.push(n.shape[c]),u*=n.shape[c];for(let c=r;c<t;c++)a.push(n.shape[c]),l*=n.shape[c];for(let c=r;c<s;c++)a.push(e.shape[c]);for(let c=t+1;c<o;c++)a.push(n.shape[c]),h*=n.shape[c];return{batchSize:u,sliceSize:h,outerSize:l,dimSize:i,outputShape:a}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ys(n){try{return n.map(e=>xr(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function uI(n){return n.map(e=>Mn(e))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */KS();/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xt=oe();xt.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",()=>15);xt.registerFlag("WEBGPU_CPU_FORWARD",()=>!0);xt.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",()=>-1);xt.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",()=>!0);xt.registerFlag("WEBGPU_USE_LOW_POWER_GPU",()=>!1);xt.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e3);xt.registerFlag("WEBGPU_USE_PROFILE_TOOL",()=>!1);xt.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",()=>!0);xt.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",()=>!1);xt.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",()=>-1);xt.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",()=>!1);xt.registerFlag("WEBGPU_PRINT_SHADER",()=>"");xt.registerFlag("WEBGPU_ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lI{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return this.vendor==="intel"}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cI{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireBuffer(e,t,r=!1,s=!0){let o;const i=al(e,t);return s?(this.freeBuffers.has(i)||this.freeBuffers.set(i,[]),this.freeBuffers.get(i).length>0?(o=this.freeBuffers.get(i).pop(),this.numFreeBuffers--):(o=this.device.createBuffer({size:e,usage:t,mappedAtCreation:r}),this.numBytesAllocated+=e)):(o=this.device.createBuffer({size:e,usage:t,mappedAtCreation:r}),this.numBytesAllocated+=e),this.usedBuffers.has(i)||this.usedBuffers.set(i,[]),this.usedBuffers.get(i).push(o),this.numUsedBuffers++,this.numBytesUsed+=e,o}releaseBuffer(e,t=!0){if(this.freeBuffers.size===0)return;const r=e.size,s=e.usage,o=al(r,s),i=this.usedBuffers.get(o),a=i.indexOf(e);if(a<0)throw new Error("Cannot find the buffer in buffer manager");i[a]=i[i.length-1],i.pop(),this.numUsedBuffers--,this.numBytesUsed-=r,t?(this.freeBuffers.get(o).push(e),this.numFreeBuffers++):(e.destroy(),this.numBytesAllocated-=r)}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach((e,t)=>{e.forEach(r=>{r.destroy()})}),this.usedBuffers.forEach((e,t)=>{e.forEach(r=>{r.destroy()})}),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function al(n,e){return`${n}_${e}`}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hI{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,r,s){const o=ll(r),i=e*t*o,a=ul(e,t,r,s);if(this.freeTextures.has(a)||this.freeTextures.set(a,[]),this.usedTextures.has(a)||this.usedTextures.set(a,[]),this.numBytesUsed+=i,this.numUsedTextures++,this.freeTextures.get(a).length>0){this.numFreeTextures--;const l=this.freeTextures.get(a).shift();return this.usedTextures.get(a).push(l),l}this.numBytesAllocated+=i;const u=this.device.createTexture({size:[e,t],format:r,usage:s});return this.usedTextures.get(a).push(u),u}releaseTexture(e){if(this.freeTextures.size===0)return;const t=e.width,r=e.height,s=e.format,o=e.usage,i=ul(t,r,s,o);this.freeTextures.has(i)||this.freeTextures.set(i,[]),this.freeTextures.get(i).push(e),this.numFreeTextures++,this.numUsedTextures--;const a=this.usedTextures.get(i),u=a.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");a.splice(u,1);const l=ll(s),h=t*r*l;this.numBytesUsed-=h}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach((e,t)=>{e.forEach(r=>{r.destroy()})}),this.usedTextures.forEach((e,t)=>{e.forEach(r=>{r.destroy()})}),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function ul(n,e,t,r){return`${n}_${e}_${t}_${r}`}function ll(n){if(n==="rgba8unorm")return 16;throw new Error(`${n} is not supported!`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dI(n,e){if(Math.max(...n)>5)throw new Error("Cannot symbolically compute strides for rank > 6 tensor.");const t=n.length,r="xyzwuv",s=n.map(i=>`${e}.${r[i]}`),o=new Array(t-1);o[t-2]=s[t-1];for(let i=t-3;i>=0;--i)o[i]=`(${o[i+1]} * ${s[i+1]})`;return o}const kn=(n,e,t)=>t==="int32"?`atomicAdd(${n}, bitcast<i32>(${e}));`:`
          {
            var oldValue = 0;
            loop {
              let newValueF32 = bitcast<f32>(oldValue) + (${e});
              let newValue = bitcast<i32>(newValueF32);
              let res = atomicCompareExchangeWeak(${n}, oldValue, newValue);
              if res.exchanged {
                break;
              }
              oldValue = res.old_value;
            }
          }`;/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Ir;(function(n){n[n.FROM_PIXELS=0]="FROM_PIXELS",n[n.DRAW=1]="DRAW"})(Ir||(Ir={}));const pI=(n,e,t,r,s)=>{const o={dtype:r.dtype,shape:r.shape},i=mI(t,o,e),a=n.createShaderModule({code:i,label:e.constructor.name});let u=oe().get("WEBGPU_PRINT_SHADER");if(u!==""){u=u.toLowerCase();const l=u.split(",");(u==="all"||l.some(h=>e.shaderKey.toLowerCase().includes(h)))&&(console.group(e.shaderKey),console.debug(i),console.groupEnd())}return s?n.createComputePipelineAsync({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"}):n.createComputePipeline({compute:{module:a,entryPoint:"_start"},label:e.constructor.name,layout:"auto"})},de=(n,e="f32")=>{switch(n){case 1:return`${e}`;case 2:return`vec2<${e}>`;case 3:return`vec3<${e}>`;case 4:return`vec4<${e}>`;default:throw new Error(`${n}-component ${e} is not supported.`)}};function Fe(n){if(n<=1)return"i32";if(n===2)return"vec2<i32>";if(n===3)return"vec3<i32>";if(n===4)return"vec4<i32>";if(n===5)return"vec5";if(n===6)return"vec6";throw Error(`GPU for rank ${n} is not yet supported`)}function sn(n){if(n===0)return"x";if(n===1)return"y";if(n===2)return"z";if(n===3)return"w";if(n===4)return"u";if(n===5)return"v";throw Error(`Index ${n} is not yet supported`)}function j(...n){let e;switch(n.length){case 0:e=`
        fn main()
      `;break;case 1:e=`
        fn main(${n[0]} : i32)
      `;break;default:throw Error("Unreachable")}return e}function cl(n,e){let t;return t=`
     ${fI(e)}
      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,
                @builtin(global_invocation_id) GlobalId : vec3<u32>,
                @builtin(local_invocation_index) LocalIndex: u32,
                @builtin(workgroup_id) WorkgroupId : vec3<u32>,
                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {
        localId = LocalId;
        localIndex = LocalIndex;
        globalId = GlobalId;
        numWorkgroups = NumWorkgroups;
        workgroupId = WorkgroupId;
        ${n?"main(getGlobalIndex());":"main();"};
      }
    `,t}function fI(n){return`
  @compute @workgroup_size(${n.workgroupSize[0]}, ${n.workgroupSize[1]}, ${n.workgroupSize[2]})
`}function mI(n,e,t){const r=[],s=t.workgroupSize[0]*t.workgroupSize[1]*t.workgroupSize[2];if(t.outputComponent=t.outputComponent?t.outputComponent:1,r.push(`

      var<private> localId: vec3<u32>;
      var<private> localIndex: u32;
      var<private> globalId: vec3<u32>;
      var<private> numWorkgroups: vec3<u32>;
      var<private> workgroupId: vec3<u32>;

      // Only used when the y/z dimension of workgroup size is 1.
      fn getGlobalIndex() -> i32 {
        ${sf(t)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +
                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${s}u +
                localIndex);
        `}
      }
    `),t.pixelsOpType!=null){const m=t.pixelsOpType===Ir.FROM_PIXELS?`@group(0) @binding(0) var<storage, read_write> result: array<${On(e.dtype,t.outputComponent)}>;`:`@group(0) @binding(1) var<storage, read> inBuf : array<${On(n[0].dtype,t.outputComponent)}>;`,x=e.shape.length===3?"vec2<i32>":"i32";r.push(`
        struct Uniform {
          outShapeStrides : ${x},
          size            : i32,
          numChannels     : i32,
          alpha           : f32,
        };

        ${m}
        @group(0) @binding(2) var<uniform> uniforms: Uniform;
      `);const b=dl(t);return[hl,r.join(`
`),zs(e.shape),t.getUserCode(),cl(b,t)].join(`
`)}let o,i,a="struct Uniforms { NAN : f32, INFINITY : f32, ";t.variableNames.forEach((m,x)=>{const b=Fe(n[x].shape.length);a+=`${m.charAt(0).toLowerCase()+m.slice(1)}Shape : ${b}, `,o=n[x].shape.length-1,i=Fe(o),a+=`${m.charAt(0).toLowerCase()+m.slice(1)}ShapeStrides: ${i}, `});const u=Fe(e.shape.length);a+=`outShape : ${u}, `,o=e.shape.length-1,i=Fe(o),a+=`
         outShapeStrides: ${i}, `,t.size&&(a+="size : i32, "),t.uniforms&&(a+=t.uniforms),a+="};",a=II(a),r.push(a),t.atomic?r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;
    `):r.push(`
      @group(0) @binding(0) var<storage, read_write> result: array<${On(e.dtype,t.outputComponent)}>;
    `),t.variableNames.forEach((m,x)=>{r.push(`
      @group(0) @binding(${1+x}) var<storage, read> ${m}: array<${t.variableComponents?On(n[x].dtype,t.variableComponents[x]):On(n[x].dtype,t.outputComponent)}>;
        `)}),a!==""&&r.push(`
      @group(0) @binding(${1+t.variableNames.length}) var<uniform> uniforms: Uniforms;
      `);const l=vI(e.shape,t.dispatchLayout),h=[hl,r.join(`
`)+yI,zs(e.shape),l,SI(e.shape.length)];t.atomic||h.push(CI(e.shape,e.dtype,t.outputComponent)),t.variableNames.forEach((m,x)=>{h.push(`${zs(n[x].shape,m)}`)});const c=n.map((m,x)=>xI(m,e.shape,t.variableComponents?t.variableComponents[x]:t.outputComponent,t.dispatchLayout.x.length===e.shape.length)).join(`
`);h.push(c),h.push(t.getUserCode());const d=dl(t);return h.push(cl(d,t)),h.join(`
`)}function gI(n,e,t){let r=n.shaderKey;if(n.pixelsOpType!=null)return r;const s=[],o=[];e.forEach(h=>{s.push(h.shape),o.push(h.dtype)}),s.push(t.shape),o.push(t.dtype);const i=e.map(h=>Hs(h.shape,t.shape)),a=e.map(h=>ot(h.shape,t.shape)).join("_"),u=i.map(h=>h.join("_")).join(";"),l=sf(n)?"flatDispatch":"";return r+="_"+(n.workgroupSize?n.workgroupSize.join(","):"")+s.map(h=>h.length).join(",")+o.join(",")+n.variableNames.join(",")+u+a+l,r}const hl=`
  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};
  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};

  // Checks whether coordinates lie within the bounds of the shape.
  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {
    return all(coord >= vec2<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {
    return all(coord >= vec3<i32>(0)) && all(coord < shape);
  }
  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {
    return all(coord >= vec4<i32>(0)) && all(coord < shape);
  }

  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {
    return coord;
  }
  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {
    return dot(coords, vec2<i32>(shape.y, 1));
  }
  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {
    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));
  }
  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
    return dot(coords, vec4<i32>(
        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
  }
  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {
    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;
  }
  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {
    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);
    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;
  }

  // NaN defination in IEEE 754-1985 is :
  //   - sign = either 0 or 1.
  //   - biased exponent = all 1 bits.
  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).
  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers
  fn isnan(val: f32) -> bool {
    let floatToUint: u32 = bitcast<u32>(val);
    return (floatToUint & 0x7fffffffu) > 0x7f800000u;
  }
  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {
    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);
    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);
  }
`,yI=`
  fn isinf(val: f32) -> bool {
    return abs(val) == uniforms.INFINITY;
  }
`;function zs(n,e=""){const t=n.length,r=e!==""?`get${e.charAt(0).toUpperCase()+e.slice(1)}CoordsFromIndex`:"getCoordsFromIndex",s=e!==""?`${e.charAt(0).toLowerCase()+e.slice(1)}ShapeStrides`:"outShapeStrides";if(t<=1)return`fn ${r}(index : i32) -> i32 { return index; }`;const o=Qe(n),i=Fe(t),a=[];for(let l=0;l<t;l++)a.push(`d${l}`);if(o.length===1)return`    fn ${r}(index : i32) -> vec2<i32> {
      let d0 = index / uniforms.${s}; let d1 = index - d0 * uniforms.${s};
      return vec2<i32>(d0, d1);
    }`;let u;return u="var index2 = index;"+o.map((l,h)=>{const c=`let ${a[h]} = index2 / uniforms.${s}.${sn(h)}`,d=h===o.length-1?`let ${a[h+1]} = index2 - ${a[h]} * uniforms.${s}.${sn(h)}`:`index2 = index2 - ${a[h]} * uniforms.${s}.${sn(h)}`;return`${c}; ${d};`}).join(""),`
    fn ${r}(index : i32) -> ${i} {
      ${u}
      return ${i}(${a.join(",")});
    }
  `}function bI(n,e){const t=n.name,r=n.shape.length,s=Fe(r),o="get"+t.charAt(0).toUpperCase()+t.slice(1),i=["d0","d1","d2","d3","d4","d5"].slice(0,r),a=i.map(h=>`${h} : i32`).join(", ");if(r<1)return`
      fn ${o}() -> ${de(e)} {
        return ${de(e)}(${t}[0]);
      }
    `;const u=`uniforms.${t.charAt(0).toLowerCase()+t.slice(1)}Shape`;let l=`${r}D`;return r===0&&(l="1D"),`
    fn ${o}(${a}) -> ${de(e)} {
      return ${de(e)}(${t}[getIndexFromCoords${l}(${s}(${i.join(",")}),
        ${u})${e===1?"":` / ${e}`}]);
    }
   `}function wI(n,e,t,r){const s=n.name,o=s.charAt(0).toUpperCase()+s.slice(1),i="get"+o+"ByOutput",a=n.shape.length,u=e.length,l=Fe(u);if(ot(n.shape,e)&&r)return`
    fn ${i}Index(globalIndex : i32) -> ${de(t)} {
      return ${de(t)}(${s}[globalIndex]);
    }

    fn ${i}Coords(coords : ${l}) -> ${de(t)} {
      return ${de(t)}(${s}[${u>1?"getOutputIndexFromCoords(coords)":"coords"}${t===1?"":` / ${t}`}]);
    }
    `;const h=Hs(n.shape,e),c=u-a;let d="";if(a===0)return`
    fn ${i}Index(globalIndex : i32) -> ${de(t)}{
      return get${o}();
    }

    fn ${i}Coords(coords : ${l}) -> ${de(t)}{
      return get${o}();
    }
  `;u<2&&h.length>=1?d="coords = 0;":d=h.map(b=>`coords.${sn(b+c)} = 0;`).join(`
`);let f="";if(u<2&&a>0)f="coords";else if(u>1){const b=Fe(a),v=n.shape.map((k,$)=>`coords.${sn($+c)}`).join(", ");f=`${b}(${v})`}else f="coords";const m=`uniforms.${s.charAt(0).toLowerCase()+s.slice(1)}Shape`,x=`${a}D`;return`
  fn ${i}Index(globalIndex : i32) -> ${de(t)} {
    var coords = getCoordsFromIndex(globalIndex);
    ${d}
    return ${de(t)}(${s}[getIndexFromCoords${x}(${f}, ${m})${t===1?"":` / ${t}`}]);
  }

  fn ${i}Coords(coordsIn : ${l}) -> ${de(t)} {
    var coords = coordsIn;
    ${d}
    return ${de(t)}(${s}[getIndexFromCoords${x}(${f}, ${m})${t===1?"":` / ${t}`}]);
  }
`}function xI(n,e,t,r){let s=bI(n,t);return n.shape.length<=e.length&&(s+=wI(n,e,t,r)),s}function vI(n,e){const{x:t,y:r=[],z:s=[]}=e,o=n.length,i=t.length+r.length+s.length;if(i!==o)return"";if(t.length===o)return`fn getOutputCoords() -> ${Fe(o)}{
    let globalIndex = getGlobalIndex();
    return getCoordsFromIndex(globalIndex);
  }
  `;let a="";const u=[t,r,s];for(let d=0;d<u.length;d++){const f=u[d];if(f.length!==0)if(f.length===1)a+=`let d${f[0]} = i32(globalId[${d}]);`;else{const m=dI(f,"uniforms.outShape");a+=`var index${d} = i32(globalId[${d}]);`;for(let x=0;x<m.length;x++)a+=`let d${f[x]} = index${d} / ${m[x]};`,x===m.length-1?a+=`let d${f[x+1]} = index${d} - d${f[x]} * ${m[x]};`:a+=`index${d} = index${d} - d${f[x]} * ${m[x]};`}}const l=[];for(let d=0;d<i;d++)l.push(`d${d}`);const h=Fe(i);let c=`fn getOutputCoords() -> ${h} {
  ${a}
`;return l.length===0?c+=`return ${h}(0); }`:c+=`return ${h}(${l.join(",")}); }`,c}function SI(n){let e="";switch(n){case 0:case 1:e+=`
        fn getOutputIndexFromCoords(coords : i32) -> i32 {
          return coords;
        }
        `;break;case 2:e+=`
        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {
          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));
        }
        `;break;case 3:e+=`
        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {
          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));
        }
        `;break;case 4:e+=`
        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
          return dot(coords, vec4<i32>(
            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));
        }
        `;break;case 5:e+=`
        fn getOutputIndexFromCoords(coords : vec5) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u;
        }
        `;break;case 6:e+=`
        fn getOutputIndexFromCoords(coords : vec6) -> i32 {
          return coords.x * uniforms.outShapeStrides.x +
              coords.y * uniforms.outShapeStrides.y +
              coords.z * uniforms.outShapeStrides.z +
              coords.w * uniforms.outShapeStrides.w +
              coords.u * uniforms.outShapeStrides.u +
              coords.v;
        }
        `;break;default:I(!1,()=>`Unsupported ${n}D shape`);break}return e}function sf(n){return n.dispatch[1]===1&&n.dispatch[2]===1}function On(n,e=1){if(n==="float32")return de(e,"f32");if(n==="int32"||n==="bool")return de(e,"i32");throw new Error(`type ${n} is not supported.`)}function CI(n,e,t){const r=n.length,s=On(e,t);let o=`fn setOutputAtIndex(flatIndex : i32, value : ${de(t)}) {
      result[flatIndex] = ${s}(value);
    }

    fn setOutputAtIndexI32(flatIndex : i32, value : ${de(t,"i32")}) {
      result[flatIndex] = ${s}(value);
    }
    `;if(r>=2){const i=["d0","d1","d2","d3","d4","d5"].slice(0,r),a=Fe(r);o+=`
      fn setOutputAtCoords(${i.map(u=>`${u} : i32`).join(", ")}, value : ${de(t)}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${i.join(", ")}));
        setOutputAtIndex(flatIndex${t===1?"":` / ${t}`}, value);
      }
      fn setOutputAtCoordsI32(${i.map(u=>`${u} : i32`).join(", ")}, value : ${de(t,"i32")}) {
        let flatIndex = getOutputIndexFromCoords(${a}(${i.join(", ")}));
        setOutputAtIndexI32(flatIndex${t===1?"":` / ${t}`}, value);
      }
    `}return o}function II(n){const e=/(\w+)\s*:\s*vec(5|6)/g;n=n.replace(e,r=>"@align(16) "+r);const t=/vec(5|6)\s*,\s*(\w+)/g;return n=n.replace(t,(r,s,o)=>`vec${s}, @align(16) ${o}`),n}function dl(n){return!(n.dispatchLayout.hasOwnProperty("y")&&n.dispatchLayout.y.length!==0||n.dispatchLayout.hasOwnProperty("z")&&n.dispatchLayout.z.length!==0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Un=n=>{let e=1;for(let t=0;t<n.length;t++)e*=n[t];return e};function K(n,e,t=[1,1,1],r=[1,1,1]){const[s,o,i]=[Math.ceil(Un(n.x.map(a=>e[a]))/(t[0]*r[0])),n.y?Math.ceil(Un(n.y.map(a=>e[a]))/(t[1]*r[1])):1,n.z?Math.ceil(Un(n.z.map(a=>e[a]))/(t[2]*r[2])):1];return[s,o,i]}function kI(n,e,t,r=!1){const s=[8,8,1],o=[4,4,1];return r||(n<=8&&(o[1]=1),e<=16&&t<=16&&(s[0]=4)),{workgroupSize:s,elementsPerThread:o}}function of(n,e,t=!1){if(t)return[8,8,1];const r=Un(n.x.map(o=>e[o])),s=Un(n.y.map(o=>e[o]));return r<=4?[4,16,1]:s<=4?[16,4,1]:[16,16,1]}function af(n,e,t=!1){if(t)return[4,4,1];const r=Un(n.x.map(o=>e[o])),s=Un(n.y.map(o=>e[o]));return r<=4?[1,2,1]:s<=4?[2,1,1]:[2,2,1]}function Q(n){return{x:n.map((e,t)=>t)}}function pl(n){if(n==="float32"||n==="int32"||n==="bool"||n==="string")return 4;if(n==="complex64")return 8;throw new Error(`Unknown dtype ${n}`)}function uf(){return!!(typeof globalThis<"u"&&globalThis.navigator&&globalThis.navigator.gpu)}function lf(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&I(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGPU backend.`)})}var Gt;(function(n){n[n.MatMulReduceProgram=0]="MatMulReduceProgram",n[n.MatMulSplitKProgram=1]="MatMulSplitKProgram",n[n.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",n[n.MatMulPackedProgram=3]="MatMulPackedProgram",n[n.MatMulMax=4]="MatMulMax"})(Gt||(Gt={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NI=oe().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD"),$I=(n,e)=>{const t=n.limits.maxComputeWorkgroupsPerDimension,r=e.dispatchLayout,s=e.dispatch;if(s.every(i=>i<=t))return s;I(s[0]>t&&r.y===void 0&&r.z===void 0,()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension.");let o=Math.ceil(Math.sqrt(s[0]));return o>t?(o=Math.ceil(Math.cbrt(s[0])),I(o<=t,()=>"Total dispatch size exceeds WebGPU maximum."),[o,o,o]):[o,o,1]};class xo extends Hl{nextDataId(){return xo.nextDataId++}constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchCountInPass=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.queryResolveBuffer=null,this.querySet=null,this.querySetCount=2,this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,this.hasReadSyncWarned=!1,this.hasTimestampQueryWarned=!1,!uf())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.commandEncoder=null,this.computePassEncoder=null,this.adapterInfo=new lI(t),this.supportTimestampQuery=this.device.features.has("timestamp-query"),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new cI(this.device),this.textureManager=new hI(this.device),this.tensorMap=new Rm(this,Yo()),oe().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}floatPrecision(){return 32}disposeData(e,t=!1){if(!this.tensorMap.has(e))return!0;const r=this.tensorMap.get(e);return t?r.refCount=0:r.refCount--,r.refCount>0?!1:(r.complexTensorInfos!=null&&(this.disposeData(r.complexTensorInfos.real.dataId),this.disposeData(r.complexTensorInfos.imag.dataId)),this.commandQueueOwnedIds.has(e)?(this.tensorDataPendingDisposal.push(e),!0):(this.releaseResource(e),this.tensorMap.delete(e),!0))}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(!(!t||!t.resource)){if(t.external){t.resource=null;return}t.resource instanceof GPUBuffer?this.bufferManager.releaseBuffer(t.resource):t.resource instanceof GPUTexture&&this.textureManager.releaseTexture(t.resource),t.resource=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){const t=this.tensorMap.get(e);t.refCount++}decRef(e){if(this.tensorMap.has(e)){const t=this.tensorMap.get(e);t.refCount--}}write(e,t,r){if(r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.tensorMap.set(s,{dtype:r,shape:t,values:e,refCount:1}),s}move(e,t,r,s,o){if(s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:s,shape:r,values:t,refCount:o})}submitQueue(){this.queue.submit([this.commandEncoder.finish()]),this.commandEncoder=null,this.dispatchCountInPass=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach(e=>{this.releaseResource(e),this.tensorMap.delete(e)}),this.uniformPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e)),this.stagingPendingDisposal.forEach(e=>this.bufferManager.releaseBuffer(e,!1)),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.commandEncoder||(this.commandEncoder=this.device.createCommandEncoder())}endComputePassEncoder(){this.computePassEncoder&&(this.computePassEncoder.end(),this.computePassEncoder=null)}async checkCompileCompletionAsync(){let e;try{e=await Promise.all(Object.values(this.pipelineCache))}catch(t){throw new Error(t.message)}Object.keys(this.pipelineCache).map((t,r)=>{this.pipelineCache[t]=e[r]})}async getBufferData(e){if(oe().getBool("WEBGPU_ENGINE_COMPILE_ONLY"))return console.warn("The data may be invalid since WEBGPU_ENGINE_COMPILE_ONLY is true, this can only be called when WEBGPU_ENGINE_COMPILE_ONLY is false"),null;const t=e.size,r=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,r,0,t),this.submitQueue(),await r.mapAsync(GPUMapMode.READ);const s=r.getMappedRange().slice(0);return r.unmap(),r!=null&&this.bufferManager.releaseBuffer(r),oe().getBool("WEBGPU_USE_PROFILE_TOOL")&&(I(this.dummyContext!==void 0,()=>"Fail to get context for profiling tool"),this.dummyContext.getCurrentTexture()),s}convertAndCacheOnCPU(e,t){const r=this.tensorMap.get(e);return r.values=t,r.values}readSync(e){const t=this.tensorMap.get(e),{values:r,complexTensorInfos:s}=t;if(r!=null||t.dtype==="string")return r;if(t.dtype==="complex64"){const x=this.readSync(s.real.dataId),b=this.readSync(s.imag.dataId),v=jo(rl(x,b).buffer,"float32");return this.convertAndCacheOnCPU(e,v),v}this.hasReadSyncWarned||(this.hasReadSyncWarned=!0,console.warn("The performance of synchronously reading data from GPU to CPU is poor on the webgpu backend, please use asynchronous APIs instead."));const o=["opaque","premultiplied"],i=t.resource,a=i.size;I(a%4===0,()=>"Because there is 4 bytes for one pixel, buffer size must be multiple of 4.");const u=a/4,l=new ArrayBuffer(a),h=256,c=256,d=o.map(x=>new OffscreenCanvas(h,c)),f=new OffscreenCanvas(h,c);this.endComputePassEncoder(),d.map((x,b)=>{const v=x.getContext("webgpu");return v.configure({device:this.device,format:"bgra8unorm",usage:GPUTextureUsage.COPY_DST,alphaMode:o[b]}),v.getCurrentTexture()}).map((x,b)=>{const v=h*4,k=(B,L,W)=>{this.ensureCommandEncoderReady(),this.commandEncoder.copyBufferToTexture({buffer:i,bytesPerRow:v,offset:W},{texture:x},{width:B,height:L}),this.submitQueue();const V=f.getContext("2d",{willReadFrequently:!0});V.clearRect(0,0,B,L),V.drawImage(d[b],0,0);const ee=V.getImageData(0,0,B,L).data,J=o[b],ne=new Uint8ClampedArray(l,W,B*L*4);for(let re=0;re<ne.length;re+=4)if(J==="premultiplied")ne[re+3]=ee[re+3];else{const he=ee[re];ne[re]=ee[re+2],ne[re+1]=ee[re+1],ne[re+2]=he}},$=Math.floor(u/(h*c));let N=h,R=c,O=0;for(let B=0;B<$;B++)k(N,R,O),O+=h*c*4;const F=u%(h*c);R=Math.floor(F/h),R>0&&(k(N,R,O),O+=R*(h*4)),N=F%h,N>0&&k(N,1,O)});const m=jo(l,t.dtype);return this.convertAndCacheOnCPU(e,m),m}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:r}=t;if(r!=null)return r;let s;if(t.dtype==="complex64"){const o=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),i=o[0],a=o[1];s=rl(i,a)}else{const o=await this.getBufferData(t.resource);s=jo(o,t.dtype)}return this.convertAndCacheOnCPU(e,s),s}copyBuffer(e){const t=e.size,r=e.usage,s=this.bufferManager.acquireBuffer(t,r);return this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(e,0,s,0,t),this.submitQueue(),s}createTensorFromGPUData(e,t,r){let s=e.buffer;if(r==="complex64")throw new Error("Cannot write to a complex64 dtype. ");const o={id:this.nextDataId()};this.tensorMap.set(o,{dtype:r,shape:t,values:null,refCount:1,external:e.zeroCopy});const i=this.tensorMap.get(o),a=pl(i.dtype)*H(i.shape);if(e.buffer.size<a)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${a})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!==(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return e.zeroCopy!==!0&&(s=this.copyBuffer(s)),i.resource=s,Yo().makeTensorFromDataId(o,t,r,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:r,dtype:s,shape:o,resource:i}=t;if(s==="complex64")throw new Error("Does not support reading buffer for complex64 dtype.");if(i==null)throw r!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const a=i,u=a.size,l=a.usage,h=this.bufferManager.acquireBuffer(u,l);this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(i,0,h,0,u),this.submitQueue();const c=this.makeTensorInfo(o,s),d=Yo().makeTensorFromTensorInfo(c),f=this.tensorMap.get(c.dataId);return f.resource=h,{tensorRef:d,buffer:h}}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const r=t.map(s=>xr(s));return Ee(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Ee(e.shape,e.dtype,t)}async time(e){!this.supportTimestampQuery&&!this.hasTimestampQueryWarned&&(console.warn("This device doesn't support timestamp-query extension. Start Chrome browser with flag --enable-dawn-features=allow_unsafe_apis to try it again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled."),this.hasTimestampQueryWarned=!0);const t=this.activeTimers,r=[];let s=!1;this.programTimersStack==null?(this.programTimersStack=r,s=!0):this.activeTimers.push(r),this.activeTimers=r,e();const o=Hn(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),i=Hn(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},u=await Promise.all(o);return a.kernelMs=Dm(u),a.getExtraProfileInfo=()=>u.map((l,h)=>({name:i[h],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,a}makeTensorInfo(e,t,r){return t==="string"&&r!=null&&r.length>0&&io(r[0])&&(r=r.map(o=>Mn(o))),{dataId:this.write(r,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const r=this.tensorMap.get(e.dataId).resource;return r instanceof GPUBuffer?{buffer:r}:r instanceof GPUTexture?r.createView():r}uploadToGPU(e){const t=this.tensorMap.get(e);if(t.resource!=null)return;const r=pl(t.dtype)*H(t.shape);let s;const o=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;if(t.values){if(s=this.bufferManager.acquireBuffer(r,o,!0),s.mapState==="unmapped"){const i=this.bufferManager.acquireBuffer(r,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,!0,!1),a=i.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(a).set(t.values):new Float32Array(a).set(t.values),i.unmap(),this.ensureCommandEncoderReady(),this.endComputePassEncoder(),this.commandEncoder.copyBufferToBuffer(i,0,s,0,r),this.stagingPendingDisposal.push(i)}else{const i=s.getMappedRange();t.dtype==="int32"||t.dtype==="bool"?new Int32Array(i).set(t.values):new Float32Array(i).set(t.values),s.unmap()}t.values=null}else s=this.bufferManager.acquireBuffer(r,o);t.resource=s}makeUniforms(e){let t=0,r=0;const s=[];let o=1;e.forEach(u=>{u.data.length===0&&(u.data=[1]);let l;switch(u.data.length){case 1:l=4;break;case 2:l=8;break;case 3:l=16;break;case 4:l=16;break;case 5:l=16;break;case 6:l=16;break;default:I(!1,()=>`Unsupported ${u.data.length}D shape`)}(r===5||r===6)&&(l=16),l>o&&(o=l),t=Math.ceil(t/l)*l,r=u.data.length,s.push(t),t+=u.data.length*4}),t=Math.ceil(t/o)*o;const i=new ArrayBuffer(t);e.forEach((u,l)=>{const h=s[l];u.type==="int32"?new Int32Array(i,h,u.data.length).set(u.data):u.type==="uint32"?new Uint32Array(i,h,u.data.length).set(u.data):new Float32Array(i,h,u.data.length).set(u.data)});const a=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);return this.queue.writeBuffer(a,0,i,0,t),this.uniformPendingDisposal.push(a),{offset:0,size:t,buffer:a}}runWebGPUProgram(e,t,r,s,o){if(o||(o=this.makeTensorInfo(e.outputShape,r)),H(o.shape)===0)return this.tensorMap.get(o.dataId).values=wn(o.dtype,0),o;this.uploadToGPU(o.dataId),e.dispatch=$I(this.device,e);const i=t.map((u,l)=>{if(u.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(u.dataId),{dtype:this.tensorMap.get(u.dataId).dtype,shape:u.shape,name:e.variableNames[l]}});e.shaderKey=gI(e,i,o);const a=oe().getBool("WEBGPU_ENGINE_COMPILE_ONLY");return e.shaderKey in this.pipelineCache||(this.pipelineCache[e.shaderKey]=pI(this.device,e,i,o,a)),e.pipeline=this.pipelineCache[e.shaderKey],a||this.recordAndSubmit(e,o,t,s),o}recordAndSubmit(e,t,r,s){if(e.pipeline instanceof Promise)throw new Error("Please call checkCompileCompletionAsync to ensure parallel compilation is done!");let o=[],i=[];const a="int32";if(e.pixelsOpType==null){o.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),i=r.concat(t).map(f=>f.shape);const d="int32";i.map(f=>{o.push({type:d,data:f});const m=Qe(f);o.push({type:d,data:m})})}else{const d=Qe(t.shape);o.push({type:a,data:d})}if(e.size){const d=H(e.outputShape);o.push({type:a,data:[e.outputComponent?d/e.outputComponent:d]})}s&&(o=[...o,...s]);const u=[this.tensorToBinding(t),...r.map(d=>this.tensorToBinding(d)),this.makeUniforms(o)];r.forEach(d=>{this.commandQueueOwnedIds.add(d.dataId)}),this.commandQueueOwnedIds.add(t.dataId);const l=this.device.createBindGroup({layout:e.pipeline.getBindGroupLayout(0),entries:u.map((d,f)=>({binding:f,resource:d}))}),h=this.activeTimers!=null;this.ensureCommandEncoderReady();const c={};h&&this.supportTimestampQuery?(this.endComputePassEncoder(),this.querySet==null&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:this.querySetCount})),c.timestampWrites={querySet:this.querySet,beginningOfPassWriteIndex:0,endOfPassWriteIndex:1},this.computePassEncoder=this.commandEncoder.beginComputePass(c)):this.computePassEncoder||(this.computePassEncoder=this.commandEncoder.beginComputePass(c)),this.computePassEncoder.setPipeline(e.pipeline),this.computePassEncoder.setBindGroup(0,l),this.computePassEncoder.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),this.dispatchCountInPass++,(h||oe().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchCountInPass||e.pixelsOpType===Ir.DRAW)&&(this.endComputePassEncoder(),h?this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime()}):this.submitQueue())}async getQueryTime(){if(!this.supportTimestampQuery)return 0;this.queryResolveBuffer==null&&(this.queryResolveBuffer=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST|GPUBufferUsage.QUERY_RESOLVE)),this.commandEncoder.resolveQuerySet(this.querySet,0,this.querySetCount,this.queryResolveBuffer,0);const e=this.bufferManager.acquireBuffer(this.querySetCount*8,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.commandEncoder.copyBufferToBuffer(this.queryResolveBuffer,0,e,0,this.querySetCount*8),this.submitQueue(),await e.mapAsync(GPUMapMode.READ);const t=new BigUint64Array(e.getMappedRange()),r=Number(t[1]-t[0])/1e6;return e.unmap(),this.bufferManager.releaseBuffer(e),r}shouldExecuteOnCPU(e,t=NI){return oe().getBool("WEBGPU_CPU_FORWARD")&&e.every(r=>this.tensorMap.get(r.dataId).resource==null&&H(r.shape)<t)}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.querySet!=null&&this.querySet.destroy(),this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}xo.nextDataId=0;/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */uf()&&Zg("webgpu",async()=>{const n={powerPreference:oe().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},e=await navigator.gpu.requestAdapter(n),t={},r=[];e.features.has("timestamp-query")&&r.push("timestamp-query"),e.features.has("bgra8unorm-storage")&&r.push(["bgra8unorm-storage"]),t.requiredFeatures=r;const s=e.limits;t.requiredLimits={maxComputeWorkgroupStorageSize:s.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:s.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:s.maxStorageBufferBindingSize,maxBufferSize:s.maxBufferSize,maxComputeWorkgroupSizeX:s.maxComputeWorkgroupSizeX,maxComputeInvocationsPerWorkgroup:s.maxComputeInvocationsPerWorkgroup};const o=await e.requestDevice(t),i=await e.requestAdapterInfo();return new xo(o,i)},3);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ae;(function(n){n[n.ADD=0]="ADD",n[n.ATAN2=1]="ATAN2",n[n.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",n[n.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",n[n.DIV=4]="DIV",n[n.ELU_DER=5]="ELU_DER",n[n.EQUAL=6]="EQUAL",n[n.FLOOR_DIV=7]="FLOOR_DIV",n[n.GREATER=8]="GREATER",n[n.GREATER_EQUAL=9]="GREATER_EQUAL",n[n.LESS=10]="LESS",n[n.LESS_EQUAL=11]="LESS_EQUAL",n[n.LOGICAL_AND=12]="LOGICAL_AND",n[n.LOGICAL_OR=13]="LOGICAL_OR",n[n.MAX=14]="MAX",n[n.MIN=15]="MIN",n[n.MOD=16]="MOD",n[n.MUL=17]="MUL",n[n.NOT_EQUAL=18]="NOT_EQUAL",n[n.POW=19]="POW",n[n.PRELU=20]="PRELU",n[n.SQUARED_DIFFERENCE=21]="SQUARED_DIFFERENCE",n[n.SUB=22]="SUB"})(ae||(ae={}));const TI="let resultTemp = a + b;",EI="let resultTemp = atan2(a, b);",_I="let resultTemp = areal * breal - aimag * bimag;",AI="let resultTemp = areal * bimag + aimag * breal;",RI="let resultTemp = a / b;",DI="let resultTemp = select(a * (b + 1.0), a, b >= b - b);",PI=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a == b);
`,OI=`
  let remainder =
      select(a % b, round(a % b), (round(a) == a) & (round(b) == b));
  let quotient = (a - remainder) / b;
  let resultTemp =
      round(select(quotient, quotient - 1, sign(remainder) == -sign(b)));
`,FI=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a > b);
`,zI=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a >= b);
`,LI=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a < b);
`,BI=`
  let zero = sign(a) * 0 + 0;
  let one = sign(b) * 0 + 1;
  let resultTemp = select(zero, one, a <= b);
`,MI="return f32(a >= 1.0 && b >= 1.0);",VI=`return (vec4<f32>(a >= vec4<f32>(1.0)) *
  vec4<f32>(b >= vec4<f32>(1.0)));`,WI="return f32(a >= 1.0 || b >= 1.0);",UI=`return min(vec4<f32>(a >= vec4<f32>(1.0)) +
  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));`,GI="let resultTemp = max(a, b);",HI="let resultTemp = min(a, b);",jI=`
  let isNaN = b == 0.;
  var resultTemp = a % b;
  resultTemp = select((resultTemp + b) % b, resultTemp,
      (a < 0. && b < 0.) || (a >= 0. && b > 0.));
`,qI=`
  let isNaN = !vec4<bool>(b);
  var resultTemp = vec4<f32>(a % b);
  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {
    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];
  }
  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {
    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];
  }
  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {
    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];
  }
  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {
    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];
  }
`,KI="let resultTemp = a * b;",XI=`
  var resultTemp = f32(a != b);
  let valueForNaN = 1.0;
`,YI=`
  var resultTemp = vec4<f32>(a != b);
  let valueForNaN = 1.0;
`,QI=`
  let isNaN = a < 0.0 && floor(b) < b;
  if (b == 0.0) {
    return 1.0;
  }
  var resultTemp = select(sign(a) * pow(abs(a), b), pow(abs(a), b),
      round(abs(b) % 2.0) != 1.0);
`,ZI=`
  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);
  let isModRound1 = vec4<f32>(isModRound1Bool);
  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);
  var resultTemp = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  let isExpZero = b == vec4<f32>(0.0);
  if (isExpZero.r) {
    resultTemp.r = 1.0;
  }
  if (isExpZero.g) {
    resultTemp.g = 1.0;
  }
  if (isExpZero.b) {
    resultTemp.b = 1.0;
  }
  if (isExpZero.a) {
    resultTemp.a = 1.0;
  }
  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);
`,JI="if (a < 0.0) { return b * a; }  return a;",e3=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,t3="let resultTemp = (a - b) * (a - b);",n3="let resultTemp = a - b;";function $a(n,e){let t;do{switch(n){case ae.ATAN2:t=EI;break;case ae.MAX:t=GI;break;case ae.MIN:t=HI;break;case ae.MOD:t=e?qI:jI;break;case ae.NOT_EQUAL:t=e?YI:XI;break;case ae.POW:t=e?ZI:QI;break;default:continue}let r,s,o;return e?(r="isnanVec4",s="vec4<f32>",o="vec4<bool>"):(r="isnan",s="f32",o="bool"),`
      let aIsNaN = ${r}(a);
      let aPostLegalization = select(a, ${s}(42), aIsNaN);
      let bIsNaN = ${r}(b);
      let bPostLegalization = select(b, ${s}(42), bIsNaN);
      let isNaN = false;
      let valueForNaN = uniforms.NAN;
      {
        let a = aPostLegalization;
        let b = bPostLegalization;
        ${t}
        return select(
            resultTemp, ${s}(valueForNaN),
            ${o}(isNaN) | aIsNaN | bIsNaN);
      }
    `}while(!1);switch(n){case ae.ADD:t=TI;break;case ae.COMPLEX_MULTIPLY_IMAG:t=AI;break;case ae.COMPLEX_MULTIPLY_REAL:t=_I;break;case ae.DIV:t=RI;break;case ae.ELU_DER:t=DI;break;case ae.EQUAL:t=PI;break;case ae.FLOOR_DIV:t=OI;break;case ae.GREATER:t=FI;break;case ae.GREATER_EQUAL:t=zI;break;case ae.LESS:t=LI;break;case ae.LESS_EQUAL:t=BI;break;case ae.LOGICAL_AND:return e?VI:MI;case ae.LOGICAL_OR:return e?UI:WI;case ae.MUL:t=KI;break;case ae.PRELU:return e?e3:JI;case ae.SQUARED_DIFFERENCE:t=t3;break;case ae.SUB:t=n3;break}return`
    ${t}
    return resultTemp;
  `}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var G;(function(n){n[n.ABS=0]="ABS",n[n.ACOS=1]="ACOS",n[n.ACOSH=2]="ACOSH",n[n.ASIN=3]="ASIN",n[n.ASINH=4]="ASINH",n[n.ATAN=5]="ATAN",n[n.ATANH=6]="ATANH",n[n.CEIL=7]="CEIL",n[n.COS=8]="COS",n[n.COSH=9]="COSH",n[n.ELU=10]="ELU",n[n.ERF=11]="ERF",n[n.EXP=12]="EXP",n[n.EXPM1=13]="EXPM1",n[n.FLOOR=14]="FLOOR",n[n.IS_FINITE=15]="IS_FINITE",n[n.IS_INF=16]="IS_INF",n[n.IS_NAN=17]="IS_NAN",n[n.LINEAR=18]="LINEAR",n[n.LOG=19]="LOG",n[n.LOG1P=20]="LOG1P",n[n.LOGICAL_NOT=21]="LOGICAL_NOT",n[n.NEG=22]="NEG",n[n.RELU=23]="RELU",n[n.RELU6=24]="RELU6",n[n.LEAKYRELU=25]="LEAKYRELU",n[n.RECIPROCAL=26]="RECIPROCAL",n[n.ROUND=27]="ROUND",n[n.RSQRT=28]="RSQRT",n[n.SELU=29]="SELU",n[n.SIGMOID=30]="SIGMOID",n[n.SIGN=31]="SIGN",n[n.SIN=32]="SIN",n[n.SINH=33]="SINH",n[n.SOFTPLUS=34]="SOFTPLUS",n[n.SQRT=35]="SQRT",n[n.SQUARE=36]="SQUARE",n[n.STEP=37]="STEP",n[n.TAN=38]="TAN",n[n.TANH=39]="TANH",n[n.TO_INT=40]="TO_INT"})(G||(G={}));const r3="return abs(a);",s3=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return acos(a);
`,o3=`
  if (a < 1.) {
    return uniforms.NAN;
  }
  return acosh(a);
`,i3=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  return asin(a);
`,a3="return asinh(a);",u3=`
  if (isnan(a)) {
    return uniforms.NAN;
  }
  return atan(a);
`,l3=`
  if (abs(a) > 1.) {
    return uniforms.NAN;
  }
  if (a == 1.) {
    return uniforms.INFINITY;
  }
  if (a == -1.) {
    return -uniforms.INFINITY;
  }
  return atanh(a);
`,c3="return ceil(a);",h3="return cos(a);",d3=`
  let e2x = exp(-a);
  return (e2x + 1.0 / e2x) / 2.0;
`,p3="return exp(a) - 1.0;",f3="if (a >= 0.0) { return a; }  return (exp(a) - 1.0);",m3=`
  var resFloat = exp(a) - vec4<f32>(1.0);
  if (a.r >= 0.0) {
    resFloat.r = a.r;
  }
  if (a.g >= 0.0) {
    resFloat.g = a.g;
  }
  if (a.b >= 0.0) {
    resFloat.b = a.b;
  }
  if (a.a >= 0.0) {
    resFloat.a = a.a;
  }
  return resFloat;
`,g3=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  let p = ${OC};
  let a1 = ${FC};
  let a2 = ${zC};
  let a3 = ${LC};
  let a4 = ${BC};
  let a5 = ${MC};

  let sign = sign(a);
  let absA = abs(a);
  let t = 1.0 / (1.0 + p * absA);
  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));
`,y3="return exp(a);",b3="return floor(a);",w3="return f32(!isnan(a) && !isinf(a));",x3="return f32(isinf(a));",v3="return f32(isnan(a));",S3="return a;",C3=`if (a < 0.0) { return uniforms.NAN; }
  return log(a);`,I3=`
  if (isnan(a)) { return a; }
  return log(1.0 + a);
`,k3="return f32(!(a >= 1.0));",N3="return -a;",$3="if (a < 0.0) { return uniforms.alpha * a; } return a;",T3=`
  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));
  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);
`,E3="return 1.0 / a;",_3="return select(a, 0.0, a < 0.0);",A3="return clamp(a, 0.0, 6.0);",R3="return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));",D3=`
  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));
`,P3="return round(a);",O3="return inverseSqrt(a);",F3=`
  if (a >= 0.0) {
    return ${PC} * a;
  } else {
    return ${DC} * (exp(a) - 1.0);
  }
`,z3="return 1.0 / (1.0 + exp(-1.0 * a));",L3="return sign(a);",B3="return sin(a);",M3=`
  let e2x = exp(a);
  return (e2x - 1.0 / e2x) / 2.0;
`,V3=`
  let epsilon = 1.1920928955078125e-7;
  let threshold = log(epsilon) + 2.0;

  let too_large = a > -threshold;
  let too_small = a < threshold;
  let exp_a = exp(a);

  if (too_large) {
    return a;
  } else if (too_small) {
    return exp_a;
  } else {
    return log(exp_a + 1.0);
  }
`,W3="return sqrt(a);",U3="return a * a;",G3=`
  if (isnan(a)) {
    return a;
  }

  return select(uniforms.stepAlpha, 1.0, a > 0.0);
`,H3="return tan(a);",j3=`
  let e2x = exp(-2.0 * abs(a));
  return sign(a) * (1.0 - e2x) / (1.0 + e2x);
`,q3="return f32(i32((a)));";function Rn(n,e){switch(n){case G.ABS:return r3;case G.ACOS:return s3;case G.ACOSH:return o3;case G.ASIN:return i3;case G.ASINH:return a3;case G.ATAN:return u3;case G.ATANH:return l3;case G.COS:return h3;case G.COSH:return d3;case G.CEIL:return c3;case G.ELU:return e?m3:f3;case G.ERF:return g3;case G.EXP:return y3;case G.EXPM1:return p3;case G.FLOOR:return b3;case G.IS_FINITE:return w3;case G.IS_INF:return x3;case G.IS_NAN:return v3;case G.LINEAR:return S3;case G.LOG:return C3;case G.LOG1P:return I3;case G.LOGICAL_NOT:return k3;case G.NEG:return N3;case G.LEAKYRELU:return e?T3:$3;case G.RECIPROCAL:return E3;case G.RELU:return e?D3:_3;case G.RELU6:return e?R3:A3;case G.ROUND:return P3;case G.RSQRT:return O3;case G.SELU:return F3;case G.SIGMOID:return z3;case G.SIGN:return L3;case G.SIN:return B3;case G.SINH:return M3;case G.SOFTPLUS:return V3;case G.SQRT:return W3;case G.SQUARE:return U3;case G.STEP:return G3;case G.TAN:return H3;case G.TANH:return j3;case G.TO_INT:return q3;default:throw new Error(`BinaryType ${n} is not implemented!`)}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dn(n,e=!1,t=!1,r=3){if(n===null)return"";let s="";if(n==="linear")s=Rn(G.LINEAR);else if(n==="relu")s=Rn(G.RELU,t);else if(n==="elu")s=Rn(G.ELU,t);else if(n==="relu6")s=Rn(G.RELU6,t);else if(n==="prelu")s=$a(ae.PRELU,t);else if(n==="sigmoid")s=Rn(G.SIGMOID,t);else if(n==="leakyrelu")s=Rn(G.LEAKYRELU,t);else throw new Error(`Activation ${n} has not been implemented for the WebGPU backend.`);const i=de(t?4:1);let a="";return e?a=`
      fn activation(a : ${i}, coords : vec${r}<i32>) -> ${i} {
        let b = getPreluActivationWeightsByOutputCoords(coords);
        ${s}
      }`:a=`
      fn activation(a : ${i}, coords : vec${r}<i32>) -> ${i} {
        ${s}
      }`,a}function rr(n,e){return`
      ${n?"value = value + getBiasByOutputCoords(coords);":""}
      ${e?"value = activation(value, coords);":""}
      `}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cf(n,e,t=!1,r=!1,s=!1,o=1){I(n&&o===1||!n,()=>`transposeA ${n} is not compatible with component size ${o}`);const i=`
      ${n?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}

    `,a=e?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`
  fn mm_readA(batch: i32, row: i32, col: i32) -> ${de(o)} {
    var value = ${de(o)}(0.0);
    ${t&&s?i:`
    ${n?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}
    {
      ${i}
    }
    `}
    return value;
  }

  fn mm_readB(batch: i32, row: i32, col: i32) -> ${de(o)} {
    var value = ${de(o)}(0.0);
    ${a}
    return value;
  }
  `}function Ta(n,e,t,r,s=!1,o=!1,i=!1,a=1){return`
  ${cf(t,r,s,o,i,a)}
  fn mm_write(batch: i32, row: i32, col: i32, valueIn: ${de(a)}) {
    ${s&&o?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}
    {
      var value = valueIn;
      let coords = vec3<i32>(batch, row, col);
      ${rr(n,e)}
      setOutputAtCoords(coords[0], coords[1], coords[2], value);
    }
  }
  `}const K3=(n,e)=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol * ${e});
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRow + innerRow,
          kStart + inputCol * ${e});
        `,X3=(n,e,t,r)=>{if(n)return`
      for (var k = 0; k < ${r}; k++) {
        let BCached0 = mm_Bsub[k][tileCol];
        let ACached0 = mm_Asub[k][localRow];
        for (var i = 0; i < ${t}; i++) {
          acc[i] = fma(BCached0, vec4<f32>(ACached0[i]), acc[i]);
        }
      }`;{let s="",o="";for(let i=0;i<e;i++)s+=`let BCached${i} = mm_Bsub[k * ${e} + ${i}][tileCol];`,o+=`acc[i] = fma(BCached${i}, vec4<f32>(ACached[${i}]), acc[i]);`;return`
      for (var k = 0; k < ${r/e}; k++) {
        ${s}
        for (var i = 0; i < ${t}; i++) {
          let ACached = mm_Asub[tileRow + i][k];
          ${o}
        }
      }`}};function vo(n,e,t=!1,r=32,s=!1,o=32,i=!1){const a=e[1]*n[1],u=e[0]*n[0],l=t?a:r,h=t?r:a,c=l/e[0],d=r/e[1],f=n[1],m=n[0];return I((t&&c===4&&n[1]===4||!t&&(c===3||c===4))&&l%e[0]===0&&r%e[1]===0&&n[0]===4,()=>`If transposeA ${t} is true, innerElementSize ${c} and workPerThread[1] ${n[1]} must be 4.
          Otherwise, innerElementSize ${c} must be 3 or 4.
      tileAWidth ${l} must be divisible by workgroupSize[0]${e[0]}. tileInner ${r} must be divisible by workgroupSize[1] ${e[1]}. colPerThread ${n[0]} must be 4.`),`
  var<workgroup> mm_Asub : array<array<vec${c}<f32>, ${l/c}>, ${h}>;
  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${u/n[0]}>, ${r}>;

  ${j()} {
    let localRow = i32(localId.y);
    let tileRow = localRow * ${f};
    let tileCol = i32(localId.x);

    let globalRow = i32(globalId.y) * ${f};
    let globalCol = i32(globalId.x) * ${m};
    let batch = ${s?"0":"i32(globalId.z)"};
    let batchA = ${s||!i?"batch":"batch % uniforms.aShape[0]"};
    let batchB = ${s||!i?"batch":"batch % uniforms.bShape[0]"};
    let globalRowStart = i32(workgroupId.y) * ${a};

    let numTiles = ${s?`${Math.ceil(o/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};
    var kStart = ${s?`i32(globalId.z) * ${o}`:"0"};

    var acc: array<vec4<f32>, ${f}>;

    // Loop over shared dimension.
    let tileRowB = localRow * ${d};
    for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var innerRow = 0; innerRow < ${f}; innerRow++) {
            let inputRow = tileRow + innerRow;
            let inputCol = tileCol;
            ${K3(t,c)}
        }

        // Load one tile of B into local memory.
        for (var innerRow = 0; innerRow < ${d}; innerRow++) {
            let inputRow = tileRowB + innerRow;
            let inputCol = tileCol;
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        ${X3(t,c,f,r)}
        workgroupBarrier();
    }

    for (var innerRow = 0; innerRow < ${f}; innerRow++) {
        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
    }
  }`}const fl=n=>n?`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          kStart + inputRow,
          globalRowStart + inputCol);
        `:`
        mm_Asub[inputRow][inputCol] = mm_readA(batchA,
          globalRowStart + inputRow,
          kStart + inputCol);
        `,Y3=n=>n?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];";function So(n,e,t=!1,r=32,s=!1,o=32,i=!1,a=!1){const u=n[1]*e[1],l=n[0]*e[0],h=t?u:r,c=t?r:u;I(c%e[1]===0&&h%e[0]===0&&r%e[1]===0,()=>`tileAHight ${c} must be divisible by workgroupSize[1]${e[1]}, tileAWidth ${h} must be divisible by workgroupSize[0]${e[0]}, tileInner ${r} must be divisible by workgroupSize[1]${e[1]}`);const d=c/e[1],f=h/e[0],m=r/e[1],x=n[1],b=n[0],v=i?`
      let localRow = i32(localId.y);
      let localCol = i32(localId.x);
      let globalRowStart = i32(workgroupId.y) * ${u};
      let globalColStart = i32(workgroupId.x) * ${l};

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        for (var inputRow = localRow; inputRow < ${c}; inputRow = inputRow + ${e[1]}) {
          for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${e[0]}) {
            ${fl(t)}
          }
        }
        // Load one tile of B into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${e[1]}) {
              for (var inputCol = localCol; inputCol < ${l}; inputCol = inputCol + ${e[0]}) {
            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
              kStart + inputRow,
              globalColStart + inputCol);
          }
        }
        kStart = kStart + ${r};
        workgroupBarrier();

        // Compute acc values for a single thread.
        var BCached : array<f32, ${b}>;
        for (var k = 0; k < ${r}; k++) {
          for (var inner = 0; inner < ${b}; inner++) {
            BCached[inner] = mm_Bsub[k][localCol + inner * ${e[0]}];
          }
          for (var innerRow = 0; innerRow < ${x}; innerRow++) {
            let ACached = ${t?`mm_Asub[k][localRow + innerRow * ${e[1]}];`:`mm_Asub[localRow + innerRow * ${e[1]}][k];`}
            for (var innerCol = 0; innerCol < ${b}; innerCol++) {
              acc[innerRow][innerCol] =
                  fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
            }
          }
        }
        workgroupBarrier();
      }
      for (var innerRow = 0; innerRow < ${x}; innerRow++) {
        let gRow = globalRowStart + localRow + innerRow * ${e[1]};
        for (var innerCol = 0; innerCol < ${b}; innerCol++) {
          let gCol = globalColStart + localCol + innerCol * ${e[0]};
          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
        }
      }
      `:`
  let tileRow = i32(localId.y) * ${x};
  let tileCol = i32(localId.x) * ${b};

  let globalRow = i32(globalId.y) * ${x};
  let globalCol = i32(globalId.x) * ${b};
  let globalRowStart = i32(workgroupId.y) * ${u};

  let tileRowA = i32(localId.y) * ${d};
  let tileColA = i32(localId.x) * ${f};
  let tileRowB = i32(localId.y) * ${m};
  // Loop over shared dimension.
  for (var t = 0; t < numTiles; t++) {
    // Load one tile of A into local memory.
    for (var innerRow = 0; innerRow < ${d}; innerRow++) {
      for (var innerCol = 0; innerCol < ${f}; innerCol++) {
        let inputRow = tileRowA + innerRow;
        let inputCol = tileColA + innerCol;
        ${fl(t)}
      }
    }

    // Load one tile of B into local memory.
    for (var innerRow = 0; innerRow < ${m}; innerRow++) {
      for (var innerCol = 0; innerCol < ${b}; innerCol++) {
        let inputRow = tileRowB + innerRow;
        let inputCol = tileCol + innerCol;
        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,
          kStart + inputRow,
          globalCol + innerCol);
      }
    }
    kStart = kStart + ${r};
    workgroupBarrier();

    // Compute acc values for a single thread.
    var BCached : array<f32, ${b}>;
    for (var k = 0; k < ${r}; k++) {
      for (var inner = 0; inner < ${b}; inner++) {
        BCached[inner] = mm_Bsub[k][tileCol + inner];
      }

      for (var innerRow = 0; innerRow < ${x}; innerRow++) {
        ${Y3(t)}
        for (var innerCol = 0; innerCol < ${b}; innerCol++) {
          acc[innerRow][innerCol] =
              fma(ACached, BCached[innerCol], acc[innerRow][innerCol]);
        }
      }
    }

    workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < ${x}; innerRow++) {
    for (var innerCol = 0; innerCol < ${b}; innerCol++) {
      mm_write(batch, globalRow + innerRow, globalCol + innerCol,
          acc[innerRow][innerCol]);
    }
  }
  `;return`
    var<workgroup> mm_Asub : array<array<f32, ${h}>, ${c}>;
    var<workgroup> mm_Bsub : array<array<f32, ${l}>, ${r}>;

    ${j()} {
      let batch = ${s?"0":"i32(globalId.z)"};
      let batchA = ${s||!a?"batch":"batch % uniforms.aShape[0]"};
      let batchB = ${s||!a?"batch":"batch % uniforms.bShape[0]"};
      let numTiles = ${s?`${Math.ceil(o/r)}`:`(uniforms.dimInner - 1) / ${r} + 1`};
      var kStart = ${s?`i32(globalId.z) * ${o}`:"0"};

      var acc : array<array<f32, ${b}>, ${x}>;

      // Without this initialization strange values show up in acc.
      for (var innerRow = 0; innerRow < ${x}; innerRow++) {
        for (var innerCol = 0; innerCol < ${b}; innerCol++) {
          acc[innerRow][innerCol] = 0.0;
        }
      }
      ${v}
    }
  `}const Q3=n=>n?`
      mm_readA(batchA, colA, globalRow),
      mm_readA(batchA, colA + 1, globalRow),
      mm_readA(batchA, colA + 2, globalRow),
      mm_readA(batchA, colA + 3, globalRow)
  `:`
      mm_readA(batchA, globalRow, colA),
      mm_readA(batchA, globalRow, colA + 1),
      mm_readA(batchA, globalRow, colA + 2),
      mm_readA(batchA, globalRow, colA + 3)
  `;function Z3(n,e=!1){I(n[1]===1&&n[2]===1,()=>`A linear work group size is required. But got ${n}.`);const t=n[0]*4;return`
    var<workgroup> mm_Asub : array<vec4<f32>, ${n[0]}>;

    ${j()} {
      let tileCol = i32(localId.x);
      let globalCol = i32(globalId.x);
      let globalRow = i32(globalId.y);

      let numTiles = (uniforms.dimInner - 1) / ${t} + 1;
      let batch = i32(globalId.z);
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      // Without this initialization strange values show up in acc.
      var acc = 0.0;

      // Loop over shared dimension.
      for (var t = 0; t < numTiles; t++) {
        // Load one tile of A into local memory.
        let colA = t * ${t} + tileCol * 4;
        mm_Asub[tileCol] = vec4<f32>(${Q3(e)});
        workgroupBarrier();

        // Compute acc values for a single thread.
        for (var k = 0; k < ${t/4}; k++) {
          let rowB = t * ${t} + k * 4;
          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),
                              mm_readB(batchB, rowB + 1, globalCol),
                              mm_readB(batchB, rowB + 2, globalCol),
                              mm_readB(batchB, rowB + 3, globalCol));

          let ACached = mm_Asub[k];
          acc = acc + dot(ACached, BCached);
        }

        workgroupBarrier();
      }

      mm_write(batch, globalRow, globalCol, acc);
    }
  `}class J3{constructor(e,t,r=!1,s=!1,o=null,i=null,a=null,u=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const l=r?e[1]:e[2];if(this.isVec4=(l%4===0&&!r||t[1]%4===0&&r)&&t[2]%4===0&&!s,this.outputComponent=this.isVec4?4:1,this.isVectorA=t[1]===1&&!r,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const d=kI(t[1],l,t[2],r);this.workgroupSize=d.workgroupSize,this.elementsPerThread=d.elementsPerThread}this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const h=o!=null,c=a!=null;h&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=u,this.transposeA=r,this.transposeB=s,this.addBias=h,this.activation=i,this.hasPreluActivationWeights=c,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],l),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${r}_${s}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,r){const s=this.workgroupSize[1]*this.elementsPerThread[1],o=this.workgroupSize[0]*this.elementsPerThread[0];!this.isVec4&&this.isVectorA?this.tileInner=this.workgroupSize[0]*4:this.tileInner=o;const i=e%s===0,a=t%o===0,u=r%this.tileInner===0;return[i,a,u]}getUserCode(){return`
      ${dn(this.activation,this.hasPreluActivationWeights,this.isVec4)}
      ${Ta(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}
      ${this.isVec4?vo(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,!0):this.isVectorA?Z3(this.workgroupSize,this.transposeA):So(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ek(n){return`
    var<workgroup> sumValues : array<f32, ${n}>;
    ${j()} {
      let coords = getOutputCoords();
      let batch = coords[0];
      let batchA = batch % uniforms.aShape[0];
      let batchB = batch % uniforms.bShape[0];
      let row = coords[1];
      let col = coords[2];
      var sum = 0.0;
      let Length = uniforms.dimInner;
      for (var k = i32(localId.x); k < Length; k = k + ${n}) {
        let dataA = mm_readA(batchA, row, k);
        let dataB = mm_readB(batchB, k, col);
        sum = sum + dataA * dataB;
      }
      sumValues[localId.x] = sum;
      workgroupBarrier();

      for(var currentSize = ${n/2}u; currentSize > 1u;
          currentSize = currentSize / 2u) {
        if (localId.x < currentSize)
        {
          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];
        }
        workgroupBarrier();
      }

      if (localId.x == 0u) {
        sum = sumValues[0] + sumValues[1];
        mm_write(batch, row, col, sum);
      }
    }
  `}class tk{constructor(e,t=!1,r=!1,s=null,o=null,i=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize);const a=s!=null,u=i!=null;a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=r,this.addBias=a,this.activation=o,this.hasPreluActivationWeights=u,this.shaderKey=`matMulReduce_${this.activation}_${t}_${r}`}getUserCode(){return`
      ${dn(this.activation,this.hasPreluActivationWeights)}
      ${Ta(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${ek(this.workgroupSize[0])}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nk(n){const e=n[1],t=n[0],r=e>t?e:t;return`
  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${e}>;
  var<workgroup> mm_Bsub : array<array<f32, ${t}>, ${r}>;

  // If the output size is small for matrix multiplication, avoid to use vec4
  // and handle some elements per thread to optimally utilize the ALU.
  // Read data from global memory to registers firstly, then store them into
  // shared memory, so it is instruction-Level parallelism for arithmetic
  // operations and others handle IO operations between barrier api, makes ALU
  // and load/store units work simultaneously, could improves the performance.
  ${j()} {
    let tileRow = i32(localId.y);
    let tileCol = i32(localId.x);
    let globalRow = i32(globalId.y);
    let globalCol = i32(globalId.x);
    let batch = i32(globalId.z);
    let batchA = batch % uniforms.aShape[0];
    let batchB = batch % uniforms.bShape[0];

    // uniforms.dimInner should be greater than 0.
    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;
    var acc = 0.0;

    var globalColA = tileCol;
    var globalRowB = 0;
    var regA = mm_readA(batchA, globalRow, globalColA);
    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
    globalColA = globalColA + ${r};
    globalRowB = globalRowB + ${r};

    for (var t = 0; t < numTiles; t = t + 1) {
      mm_Asub[tileRow][tileCol] = regA;
      mm_Bsub[2 * tileRow][tileCol] = regB0;
      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;

      workgroupBarrier();

      regA = mm_readA(batchA, globalRow, globalColA);
      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);
      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);
      globalColA = globalColA + ${r};
      globalRowB = globalRowB + ${r};

      for (var k = 0; k < ${r}; k = k + 1) {
        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];
      }
      workgroupBarrier();
    }

    mm_write(batch, globalRow, globalCol, acc);
  }
  `}class rk{constructor(e,t,r,s=!1,o=!1,i=null,a=null,u=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=r,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(r[2]/this.workgroupSize[0]),Math.ceil(r[1]/this.workgroupSize[1]),r[0]];const l=i!=null;l&&this.variableNames.push("bias");const h=u!=null;h&&this.variableNames.push("preluActivationWeights"),this.transposeA=s,this.transposeB=o,this.addBias=l,this.activation=a,this.hasPreluActivationWeights=h,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${s}_${o}`}getUserCode(){return`
      ${dn(this.activation,this.hasPreluActivationWeights)}
      ${Ta(this.addBias,this.activation,this.transposeA,this.transposeB)}
      ${nk(this.workgroupSize)}
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sk{constructor(e,t,r=!1,s=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.splitedDimInner=128,I(e[0]===1,()=>"MatMulSplitKProgram only supports batch = 1."),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]};const o=(r&&this.outputShape[1]%4===0||!r&&t%4===0)&&this.outputShape[2]%4===0;this.elementsPerThread=[4,4,this.splitedDimInner],this.outputComponent=o?4:1,o||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=K(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=r,this.transposeB=s,this.shaderKey=`matMulSplitK_${r}_${s}_${this.elementsPerThread}_${this.outputComponent}`}getUserCode(){const e=this.outputComponent;return`
      ${cf(!1,this.transposeB,!1,!1,!1,e)}
      fn mm_write(batch: i32, row : i32, col : i32, value : ${de(e)}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
          let coords = vec3<i32>(batch, row, col);
          let flatIndex = getOutputIndexFromCoords(coords);
          // The problem is that we should initialize output to zero before using.
          // Otherwise, the original value will be added to the result.
          for (var i = 0; i < ${e}; i = i + 1) {
            ${kn("&result[flatIndex + i]",`${e>1?"value[i]":"value"}`,"float32")}
          }
        }
      }
      ${e===4?vo(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):So(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}
    `}}class ok{constructor(e,t=null,r=null,s=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t!=null,this.hasPreluActivationWeights=s!=null,this.activation=r,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`biasActivation_${r}`}getUserCode(){return`
    ${dn(this.activation,this.hasPreluActivationWeights)}
    ${j("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        var value = getXByOutputIndex(index);
        ${rr(this.addBias,this.activation)}
        setOutputAtIndex(index, value);
      }
    }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ik{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`
    ${j("index")} {
      if (index < uniforms.size) {
        setOutputAtIndex(index, uniforms.value);
      }
    }
  `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function st(n){const{backend:e,attrs:t}=n,{shape:r,value:s}=t;let{dtype:o}=t;if(o=o||us(s),o==="string"){const i=We(o,H(r));return i.fill(s),e.makeTensorInfo(r,o,i)}else{const i=new ik(r),a=[{type:"float32",data:[s]}];return e.runWebGPUProgram(i,[],o,a)}}const ak={kernelName:jc,backendName:"webgpu",kernelFunc:st};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function te(n){const{inputs:e,attrs:t}=n,{x:r}=e,{shape:s}=t,o=H(r.shape),i=Om(s,o),a=H(i);return I(o===a,()=>`The new shape (${i}) has ${a} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`),n.backend.incRef(r.dataId),{dataId:r.dataId,shape:i,dtype:r.dtype}}const uk={kernelName:Uh,backendName:"webgpu",kernelFunc:te};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Co({a:n,b:e,transposeA:t,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:a=0,activation:u=null}){const l=n.shape.length,h=e.shape.length,c=t?n.shape[l-2]:n.shape[l-1],d=r?e.shape[h-1]:e.shape[h-2],f=t?n.shape[l-1]:n.shape[l-2],m=r?e.shape[h-2]:e.shape[h-1],x=n.shape.slice(0,-2),b=e.shape.slice(0,-2),v=H(x),k=H(b),N=Ce(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([f,m]);I(c===d,()=>`Error in matMul: inner shapes (${c}) and (${d}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${r} must match.`);const R=t?[v,c,f]:[v,f,c],O=r?[k,m,d]:[k,d,m],F=te({inputs:{x:n},backend:s,attrs:{shape:R}}),B=te({inputs:{x:e},backend:s,attrs:{shape:O}}),L=[F,B],W=Math.max(v,k),V=[F,B],ee=[{type:"int32",data:[f]},{type:"int32",data:[m]},{type:"int32",data:[c]}];let J,ne;const re=[W,f,m];let he=oe().get("WEBGPU_MATMUL_PROGRAM_TYPE");if(he<0){const ge=oe().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),ce=ge>0?ge:s.thresholdToIncreaseWorkgroups,Ae=W*Math.ceil(f/32)*Math.ceil(m/32);Ae<=ce||f<=8&&Ae<=ce*2?W*f*m<=128?he=Gt.MatMulReduceProgram:W===1&&d>=2e3?he=Gt.MatMulSplitKProgram:he=Gt.MatMulSmallOutputSizeProgram:he=Gt.MatMulPackedProgram}switch(he){case Gt.MatMulReduceProgram:J=new tk(re,t,r,o,u,i);break;case Gt.MatMulSplitKProgram:{if(ne=st({backend:s,attrs:{shape:re,value:0,dtype:n.dtype}}),J=new sk(re,d,t,r),o||u){ne=s.runWebGPUProgram(J,V,n.dtype,ee,ne);const ce=new ok(ne.shape,o,u,i);let Ae=null;const Ze=[ne];o&&Ze.push(o),i&&Ze.push(i),u==="leakyrelu"&&(Ae=[{type:"float32",data:[a]}],ce.uniforms+=" alpha : f32,");const Jt=s.runWebGPUProgram(ce,Ze,ne.dtype,Ae);L.push(ne);const Ar=te({inputs:{x:Jt},backend:s,attrs:{shape:N}});L.push(Jt);for(const gs of L)s.disposeData(gs.dataId);return Ar}break}case Gt.MatMulSmallOutputSizeProgram:J=new rk(R,O,re,t,r,o,u,i);break;case Gt.MatMulPackedProgram:const ge=s.adapterInfo.isIntel();J=new J3(R,re,t,r,o,u,i,ge);break;default:throw new Error(`Unsupported MatMulProgramType ${he}.`)}o&&V.push(o),i&&V.push(i),u==="leakyrelu"&&(ee.push({type:"float32",data:[a]}),J.uniforms+=" alpha : f32,"),ne=s.runWebGPUProgram(J,V,n.dtype,ee,ne);const Le=te({inputs:{x:ne},backend:s,attrs:{shape:N}});L.push(ne);for(const ge of L)s.disposeData(ge.dataId);return Le}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lk(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:o,bias:i,preluActivationWeights:a}=e,{transposeA:u,transposeB:l,activation:h,leakyreluAlpha:c}=r;return Co({a:s,b:o,transposeA:u,transposeB:l,backend:t,bias:i,preluActivationWeights:a,leakyreluAlpha:c,activation:h})}const ck={kernelName:di,backendName:"webgpu",kernelFunc:lk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ml{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=Ce(t,r),this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`binaryOpComplex_${e}`,this.op=e}getUserCode(){return`
      fn binaryOpComplex(
          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {
        ${$a(this.op,!1)}
      }

      ${j("index")} {
        if(index < uniforms.size) {
          let areal = getARealByOutputIndex(index);
          let aimag = getAImagByOutputIndex(index);
          let breal = getBRealByOutputIndex(index);
          let bimag = getBImagByOutputIndex(index);
          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qs{constructor(e,t,r){if(this.size=!0,this.variableNames=["A","B"],this.outputShape=Ce(t,r),this.dispatchLayout=Q(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&r.length>1&&t[0]<128,this.useSharedMemoryWithB=r.length<=1&&t.length>1&&r[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB)this.outputComponent=1,this.variableComponents=[1,1],this.lastDimensionSize=this.useSharedMemoryWithB?r[0]:t[0],this.shaderKey=`binary_${e}_${this.lastDimensionSize}`,this.type="shared",this.workgroupSize=[256,1,1];else{const s=t.length>0&&t[t.length-1]%4===0,o=r.length>0&&r[r.length-1]%4===0;s&&o?(this.outputComponent=4,this.variableComponents=[4,4]):s&&(Ou(r)||r[r.length-1]===1)||o&&(Ou(t)||t[t.length-1]===1)?(this.outputComponent=4,this.variableComponents=s?[4,1]:[1,4]):(this.outputComponent=1,this.variableComponents=[1,1]),this.type="nonshared",this.shaderKey=`binary_${e}_${this.variableComponents}`,this.workgroupSize=[128,1,1]}this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.outputComponent,1,1])}getUserCode(){let e;const t=this.outputComponent===4?"vec4<f32>":"f32",r=`
    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {
      ${$a(this.op,this.outputComponent===4)}
    };
    `;if(this.type==="shared"){const s=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",o=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);
          let b = sharedBuf[${s}];`:`let a = sharedBuf[${s}];
          let b = getBByOutputIndex(index);`;e=`
        ${r}
        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;
        ${j("index")} {
          // Fill in the shared memory buffer.
          let localIndex = i32(localId.x);
          if(localIndex < ${this.lastDimensionSize}) {
            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);
          }
          workgroupBarrier();

          if(index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            ${o}
            setOutputAtIndex(index, binaryOperation(a, b));
          }
        }
        `}else e=`
       ${r}
       ${j("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index * ${this.outputComponent});
           let a = ${t}(getAByOutputCoords(coords));
           let b = ${t}(getBByOutputCoords(coords));
           setOutputAtIndex(index, binaryOperation(a, b));
         }
       }
       `;return e}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ft(n){const{inputs:e}=n,{x:t}=e;return n.backend.incRef(t.dataId),{dataId:t.dataId,shape:t.shape,dtype:t.dtype}}const hk={kernelName:Qi,backendName:"webgpu",kernelFunc:ft};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sr(n){const{inputs:e,backend:t}=n,{real:r,imag:s}=e,o=t.makeTensorInfo(r.shape,"complex64"),i=t.tensorMap.get(o.dataId),a=ft({inputs:{x:r},backend:t}),u=ft({inputs:{x:s},backend:t});return i.complexTensorInfos={real:a,imag:u},o}const dk={kernelName:yc,backendName:"webgpu",kernelFunc:sr};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Er{constructor(e,t,r=""){this.variableNames=["A"],this.size=!0;const s=128;this.workgroupSize=[s,1,1],this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,r!==""&&(this.uniforms=r),this.shaderKey=`unary_${t}`}getUserCode(){return`
      fn unaryOperation(a : f32) -> f32 {
        ${Rn(this.op,!1)}
      }
      ${j("index")} {
        if (index < uniforms.size) {
          let a = getAByOutputIndex(index);
          setOutputAtIndex(index, unaryOperation(a));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xe({opType:n,cpuKernelImpl:e,dtype:t}){return({inputs:r,backend:s})=>{const{x:o}=r,i=s,a=t||o.dtype;if(i.shouldExecuteOnCPU([o])&&e!=null){const l=i.tensorMap.get(o.dataId),h=e(l.values,a);return i.makeTensorInfo(o.shape,a,h)}const u=new Er(o.shape,n);return i.runWebGPUProgram(u,[o],a)}}function Ue({opType:n,cpuKernelImpl:e,supportsComplex:t=!1,dtype:r}){return({inputs:s,backend:o})=>{const{a:i,b:a}=s,u=o;if(t&&i.dtype==="complex64"){const c=u.tensorMap.get(i.dataId),d=u.tensorMap.get(a.dataId);let f,m;if(n!==ae.MUL)[f,m]=[[c.complexTensorInfos.real,d.complexTensorInfos.real],[c.complexTensorInfos.imag,d.complexTensorInfos.imag]].map(b=>{const[v,k]=b,$={dataId:v.dataId,dtype:v.dtype,shape:i.shape},N={dataId:k.dataId,dtype:k.dtype,shape:a.shape},R=new Qs(n,i.shape,a.shape);return u.runWebGPUProgram(R,[$,N],xn(v.dtype,k.dtype))});else{const b=new ml(ae.COMPLEX_MULTIPLY_REAL,i.shape,a.shape),v=new ml(ae.COMPLEX_MULTIPLY_IMAG,i.shape,a.shape),k=[{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:i.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:i.shape},{dataId:d.complexTensorInfos.real.dataId,dtype:d.complexTensorInfos.real.dtype,shape:a.shape},{dataId:d.complexTensorInfos.imag.dataId,dtype:d.complexTensorInfos.imag.dtype,shape:a.shape}];f=u.runWebGPUProgram(b,k,"float32"),m=u.runWebGPUProgram(v,k,"float32")}const x=sr({inputs:{real:f,imag:m},backend:u});return u.disposeData(f.dataId),u.disposeData(m.dataId),x}const l=r||xn(i.dtype,a.dtype);if((i.dtype==="string"||a.dtype==="string"||u.shouldExecuteOnCPU([i,a]))&&e!=null){const c=u.tensorMap.get(i.dataId).values,d=u.tensorMap.get(a.dataId).values,f=i.dtype==="string"?Ys(c):c,m=i.dtype==="string"?Ys(d):d,[x,b]=e(i.shape,a.shape,f,m,l);return u.makeTensorInfo(b,l,x)}const h=new Qs(n,i.shape,a.shape);return u.runWebGPUProgram(h,[i,a],l)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pk(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function at(n){return(e,t,r,s,o)=>{const i=Ce(e,t),a=i.length,u=Qe(i),l=H(i),h=wn(o,l),c=e.length,d=t.length,f=Qe(e),m=Qe(t),x=Hs(e,i),b=Hs(t,i);if(x.length+b.length===0)for(let v=0;v<h.length;++v)h[v]=n(r[v%r.length],s[v%s.length]);else for(let v=0;v<h.length;++v){const k=qi(v,a,u),$=k.slice(-c);x.forEach(F=>$[F]=0);const N=ci($,c,f),R=k.slice(-d);b.forEach(F=>R[F]=0);const O=ci(R,d,m);h[v]=n(r[N],s[O])}return[h,i]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fk(n,e,t,r){if(r==="int32"){const s=Int32Array.from(n);return[e,"int32",s]}if(r==="bool"){const s=uo([0],t),[o,i]=at((a,u)=>a!==u?1:0)(e,[],n,s,"bool");return[i,"bool",o]}throw new Error(`Error in Cast: failed to cast ${t} to ${r}`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mk=at((n,e)=>n+e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gk(n,e,t,r,s){const o=H(r),i=on(s,t);for(let a=0;a<n.length;a++){const u=n[a];if(u<0)throw new Error("Input x must be non-negative!");u>=s||(o>0?i[u]+=e[a]:i[u]+=1)}return i}function yk(n,e,t,r=!1){const s=n.shape[0],o=n.shape[1],i=Ee([s,t],e.dtype);for(let a=0;a<s;a++)for(let u=0;u<o;u++){const l=n.get(a,u);if(l<0)throw new Error("Input x must be non-negative!");l>=t||(r?i.set(1,a,l):e.size>0?i.set(i.get(a,l)+e.get(a,u),a,l):i.set(i.get(a,l)+1,a,l))}return i}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bk=at((n,e)=>n&e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pn(n){return(e,t,r)=>{const s=We(t,e.length);for(let o=0;o<e.length;++o)s[o]=n(e[o],r);return s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wk=pn(n=>Math.ceil(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xk(n,e,t,r){const s=We(t,H(e));if(r&&t!=="string"){let o=0;n.forEach(i=>{const a=H(i.shape);s.set(i.vals,o),o+=a})}else{let o=0;n.forEach(i=>{const a=t==="string"?Ys(i.vals):i.vals;let u=0;for(let l=0;l<i.shape[0];++l){const h=l*e[1]+o;for(let c=0;c<i.shape[1];++c)s[h+c]=a[u++]}o+=i.shape[1]})}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vk=at((n,e)=>n===e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sk=pn(n=>Math.exp(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ck=pn(n=>Math.expm1(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ik=pn(n=>Math.floor(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kk=at((n,e)=>Math.floor(n/e));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nk(n,e,t,r,s,o,i,a,u){const l=Ee([r,o],t);for(let h=0;h<r;h++){const c=[];let d=0;for(let f=0;f<s;f++){const m=n[h*s+f];d+=m*i[f],c.push(m)}if(d<0||d>=u/o)throw new Error(`Invalid indices: ${c} does not index into ${a}`);for(let f=0;f<o;f++)l.values[h*o+f]=e.get(...e.indexToLoc(d*o+f))}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $k(n,e,t){const r=Ee(t,n.dtype);for(let s=0;s<r.size;++s){const i=r.indexToLoc(s).slice(),a=i[0],u=i[2],l=e.locToIndex([a,u]);i[2]=e.values[l];const h=n.locToIndex(i);0<=h&&h<n.values.length&&(r.values[s]=n.values[h])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tk=at((n,e)=>n>e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ek=at((n,e)=>n>=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _k=at((n,e)=>n<e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ak=at((n,e)=>n<=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rk(n,e,t){const r=(e-n)/(t-1),s=on(t,"float32");s[0]=n;for(let o=1;o<s.length;o++)s[o]=s[o-1]+r;return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dk=pn(n=>Math.log(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pk(n,e,t,r){const s=wn(r,H(t));for(let o=0;o<s.length;++o){const i=o*e;let a=n[i];for(let u=0;u<e;++u){const l=n[i+u];(Number.isNaN(l)||l>a)&&(a=l)}s[o]=a}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ok=at((n,e)=>Math.max(n,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fk=at((n,e)=>Math.min(n,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hf=at((n,e)=>n*e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zk(n,e,t){const r=_g(-1,t);return hf([],e,r,n,t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lk=at((n,e)=>n!==e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bk(n,e,t,r,s){const o=e.length,i=H(e),a=Qe(e),u=Qe(s),l=wn(t,H(s));for(let h=0;h<i;++h){const c=qi(h,o,a),d=new Array(c.length);for(let m=0;m<d.length;m++)d[m]=c[r[m]];const f=ci(d,o,u);l[f]=n[h]}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mk(n,e,t,r){const[s,o]=fo(n,r),i=xn(e,"int32"),a=on(H(s),i),u=H(o);for(let l=0;l<a.length;++l){const h=l*u;let c=1;for(let d=0;d<u;++d)c*=t[h+d];a[l]=c}return{outVals:a,outShape:s,outDtype:i}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vk(n,e,t){n.forEach((r,s)=>{if(r<0||r>=t){const o=qi(s,e.length,Qe(e)).join(",");throw new Error(`indices[${o}] = ${r} is not in [0, ${t})`)}})}function Wk(n,e){for(let t=0;t<n.length;++t){const r=n[t],s=t===n.length-1?e:n[t+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>s)throw new Error("Ragged splits must not point past values");for(let o=1;o<r.length;++o)if(r[o-1]>r[o])throw new Error("Ragged splits must be sorted in ascending order")}}function Uk(n,e,t,r){const s=[];let o=0;const i=e.length-1+t.length,a=new Array(i).fill(null).map(()=>[0]);Wk(t,r);let u=1;for(let l=0;l<e.length-1;++l){u*=e[l];const h=e[l+1];for(let c=1;c<u+1;++c)a[l].push(c*h)}for(let l=0;l<n.length;++l){let h=n[l],c=n[l]+1;for(let d=0;d<t.length;++d){const f=t[d],m=d+e.length-1;if(m>=0){const x=a[m],b=x[x.length-1]-f[h];for(let v=h;v<c;++v)a[m].push(f[v+1]+b)}h=f[h],c=f[c]}c!==h&&(s.push([h,c]),o+=c-h)}return{outSplits:a,valueSlices:s,numValues:o}}function Gk(n){const e=[];for(let t=0;t<n.length;++t){const r=n[t].length,s=We("int32",r);e.push(s),n[t].forEach((o,i)=>s[i]=o)}return e}function gl(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let r=e;r<n.length;r++)t[e-1]*=n[r];return t}function Hk(n,e,t,r,s,o){const i=gl(e,2)[1],a=gl(o,2)[1];let u=0;for(const l of t)for(let h=l[0];h<l[1];++h){for(let c=0;c<r;++c)s[u*a+c]=n[h*i+c];++u}}function jk(n,e,t,r,s){const o=e.slice();o[0]=s;const i=We(t,H(o)),a=n.length,u=a===0?0:a/e[0];return Hk(n,e,r,u,i,o),[i,o]}function qk(n,e,t,r,s,o,i,a){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const u=e[0][0]-1;if(Vk(o,i,u),r.length===0)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:h,valueSlices:c,numValues:d}=Uk(o,i,n,l),f=Gk(h),m=jk(t,r,s,c,d);return[f,m[0],m[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yl=2147483647;function Kk(n,e,t,r,s,o,i){if(e.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(i.length>1)throw new Error("deltas must be a scalar or vector");const a=e.length===0,u=s.length===0,l=i.length===0,h=[];a||h.push(e[0]),u||h.push(s[0]),l||h.push(i[0]);for(let b=1;b<h.length;++b)if(h[b]!==h[b-1])throw new Error("starts, limits, and deltas must have the same shape");const c=h.length===0?1:h[0],d=We("int32",c+1);d[0]=0;for(let b=0;b<c;++b){const v=a?n[0]:n[b],k=u?r[0]:r[b],$=l?o[0]:o[b];if($===0)throw new Error("Requires delta != 0");let N;if($>0&&k<v||$<0&&k>v)N=0;else if(N=Math.ceil(Math.abs((k-v)/$)),N>yl)throw new Error(`Requires ((limit - start) / delta) <= ${yl}`);d[b+1]=d[b]+N}const f=d[c],m=We(t,f);let x=0;for(let b=0;b<c;++b){const v=d[b+1]-d[b];let k=a?n[0]:n[b];const $=l?o[0]:o[b];for(let N=0;N<v;++N)m[x++]=k,k+=$}return[d,m]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var St=jt;class Zs{constructor(e,t,r,s,o,i,a,u,l,h){this.shape=e,this.shapeShape=t,this.values=r,this.valuesShape=s,this.valuesDType=o,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=u,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=$C(h),this.raggedRank=TC(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===St.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===St.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case St.VALUE_ROWIDS:return Zs.getMaxWidthValueRowID(t);case St.ROW_SPLITS:return Zs.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${St[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let r=0;for(let s=0;s<t-1;++s){const o=e[s+1]-e[s];o>r&&(r=o)}return r}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let r=0,s=e[0],o=0;for(let i=1;i<t;++i){const a=e[i];a!==s&&(s=a,o=Math.max(i-r,o),r=i)}return Math.max(t-r,o)}tensorShapeFromTensor(e,t,r=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return wl(e,r)}calculateOutputSize(e){const t=this.valuesShape,r=this.defaultValueShape;EC(r,t);const s=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=NC(this.raggedRank,s,t);i[0]<0&&(i[0]=e);for(let a=1;a<=this.raggedRank;++a)i[a]<0&&(i[a]=this.getMaxWidth(a));return i}calculateFirstParentOutputIndex(e,t,r){const s=Math.min(e,r),o=[];let i=0;for(let a=0;a<s;++a,i+=t)o.push(i);for(let a=s;a<e;++a)o.push(-1);return I(o.length===e,()=>"Final length of result must be equal to firstDimension."),o}calculateOutputIndexRowSplit(e,t,r,s){const o=e.length,i=[];for(let a=0;a<o-1;++a){const u=e[a+1]-e[a];let l=Math.min(s,u),h=t[a];h===-1&&(l=0);for(let c=0;c<l;++c)i.push(h),h+=r;for(let c=0;c<u-l;++c)i.push(-1)}if(o>0&&i.length!==e[o-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,t,r,s){const o=e.length,i=[];if(o===0)return[];let a=0,u=e[0];if(u>=t.length)throw new Error(`Got currentValueRowId=${u}, which is not less than ${t.length}`);let l=t[u];i.push(l);for(let h=1;h<o;++h){const c=e[h];if(c===u)l>=0&&(++a,a<s?l+=r:l=-1);else{if(a=0,u=c,c>=t.length)throw new Error(`Got nextValueRowId=${c} which is not less than ${t.length}`);l=t[c]}i.push(l)}if(i.length!==e.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(e,t,r,s){const o=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case St.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(o,t,r,s);case St.ROW_SPLITS:if(o.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${o.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(o,t,r,s);default:throw new Error(`Unsupported partition type: ${St[i]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case St.FIRST_DIM_SIZE:return e[0];case St.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case St.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${St[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),r=this.calculateOutputSize(t),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let u=s.length-2;u>=0;--u)s[u]=s[u+1]*r[u+1];const o=wl(r,!1),i=We(this.valuesDType,H(o));if(s[0]*r[0]>0){let u=this.calculateFirstParentOutputIndex(t,s[0],r[0]);for(let l=1;l<=this.raggedRank;++l)u=this.calculateOutputIndex(l-1,u,s[l],r[l]);this.setOutput(this.raggedRank,u,i,o)}return[o,i]}setOutput(e,t,r,s){if(r.length===0)return;const o=this.values,i=r;let a=s.slice();a=a.slice(e+1);const u=H(a),l=t.length;let h=this.defaultValue;if(h.length!==u&&h.length!==1){const m=this.defaultValueShape;be(()=>{const x=M(h,m);h=qr(x,a).dataSync()})}let c=0,d=0,f=0;for(let m=0;m<=l;++m){let x=m<l?t[m]:-1;if(x===f){++f;continue}if(d<f){const b=o.subarray(c*u),v=i.subarray(d*u),k=(f-d)*u;bl(v,b,k)}if(m>=l){const b=r.length;x=Math.floor(b/u)}if(x>f)if(this.defaultValue.length===1)i.subarray(f*u,x*u).fill(this.defaultValue[0]),f=x;else for(;x>f;){const b=i.slice(f*u);bl(b,h,u),++f}x<0?(c=m+1,d=f):(c=m,d=f,f=d+1)}}}function bl(n,e,t){for(let r=0;r<t;r++)n[r]=e[r]}function wl(n,e){const t=[];for(let r of n){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}t.push(r)}return t}function Xk(n,e,t,r,s,o,i,a,u,l){return new Zs(n,e,t,r,s,o,i,a,u,l).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yk(n,e,t,r){const s=n===e,o=n<e&&t<0,i=e<n&&t>1;if(s||o||i)return on(0,r);const a=Math.abs(Math.ceil((e-n)/t)),u=on(a,r);e<n&&t===1&&(t=-1),u[0]=n;for(let l=1;l<u.length;l++)u[l]=u[l-1]+t;return u}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qk=pn(n=>1/Math.sqrt(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zk(n,e,t,r,s,o,i,a,u,l){const h=[r/s,s],c=n.values,d=e.values;if(r===0)return Ee(t,e.dtype);const f=u instanceof vr?u:Ee(h,e.dtype);typeof u=="string"||typeof u=="number"?f.values.fill(u):typeof u=="boolean"&&f.values.fill(+u);for(let m=0;m<o;m++){const x=[];let b=0;for(let v=0;v<i;v++){const k=c[m*i+v];x.push(k),b+=k*a[v]}if(b<0||b>=r/s)throw new Error(`Invalid indices: ${x} does not index into ${t}`);for(let v=0;v<s;v++)l?f.values[b*s+v]+=d[m*s+v]:f.values[b*s+v]=e.rank===0?d[0]:d[m*s+v]}return f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jk=pn(n=>1/(1+Math.exp(-n)));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eN(n,e,t,r,s){const o=xC(r,e,t),i=H(t),a=Qe(r);if(o){const c=vC(e,a);return s==="string"?n.slice(c,c+i):n.subarray(c,c+i)}const u=s==="string"?Ys(n):n,l=Ee(r,s,u),h=Ee(t,s);for(let c=0;c<h.size;++c){const d=h.indexToLoc(c),f=d.map((m,x)=>m+e[x]);h.set(l.get(...f),...d)}return s==="string"?uI(h.values):h.values}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tN(n,e,t,r,s,o,i){const a=e[0],u=o[0],l=new Array(u),h=new Array(a),c=e[1];if(u===0){if(a!==0)throw new Error(XC(a));const b=We(t,0),v=We(s,0);return[b,[0,c],v,l,h]}let d=!0,f=0;const m=new Array(u).fill(0);for(let b=0;b<a;++b){const v=n[b*c];if(v<0)throw new Error(YC(b,v));if(v>=u)throw new Error(QC(b,v,u));++m[v],d=d&&v>=f,f=v}let x=!0;for(let b=0;b<u;++b){const v=m[b]===0;l[b]=v,x=x&&!v,m[b]=Math.max(m[b],1),b>0&&(m[b]+=m[b-1])}if(x&&d){const b=n,v=r;for(let k=0;k<a;++k)h[k]=k;return[b,[a,c],v,l,h]}else{const b=m[u-1],v=We(t,b*c),k=We(s,b),$=new Array(u).fill(0);for(let N=0;N<a;++N){const R=n[N*c],O=$[R],F=(R===0?0:m[R-1])+O;$[R]++;for(let B=0;B<c;++B)v[F*c+B]=n[N*c+B];k[F]=r[N],h[N]=F}for(let N=0;N<u;++N)if($[N]===0){const O=N===0?0:m[N-1];v[O*c+0]=N;for(let F=1;F<c;++F)v[O*c+F]=0;k[O]=i}return[v,[b,c],k,l,h]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nN(n,e,t,r,s){const o=H(r),i=e[0],a=s.length,u=[];let l=1,h=-1;for(let b=0;b<a;++b){const v=s[b];if(v===-1){if(h!==-1)throw new Error(ZC(h,b));h=b,u.push(1)}else{if(v<0)throw new Error(JC(b,v));l*=v,u.push(v)}}if(h!==-1){if(l<=0)throw new Error(eI());const b=Math.trunc(o/l);if(l*b!==o)throw new Error(tI(r,u));u[h]=b}if(H(u)!==o)throw new Error(nI(r,u));const d=r.length,f=[];if(d>0){f[d-1]=1;for(let b=d-2;b>=0;--b)f[b]=f[b+1]*r[b+1]}const m=[];if(a>0){m[a-1]=1;for(let b=a-2;b>=0;--b)m[b]=m[b+1]*u[b+1]}const x=We(t,i*a);for(let b=0;b<i;++b){let v=0;for(let k=0;k<d;++k)v+=n[b*d+k]*f[k];for(let k=0;k<a;++k)x[b*a+k]=Math.trunc(v/m[k]),v%=m[k]}return[x,[i,a],u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rN(n,e,t,r,s,o=!1,i=0){const a=r.length,u=[e[0],n.length/e[0]],l=u[1],c=a>0?s[a-1]+1:0;if(c<0)throw new Error(il());const d=e.slice();d[0]=c;const f=d.reduce(($,N)=>$*N,1),m=We(t,f);if(a===0)return c>0&&m.fill(i),[m,d];if(c<=0)throw new Error(il());let x=0,b=1,v=0,k=s[x];for(;;){let $=0;if(b<a){if($=s[b],k===$){++b;continue}if(k>=$)throw new Error(rI())}if(k<0||k>=c)throw new Error(sI(k,c));k>v&&m.fill(i,v*l,k*l);for(let N=x;N<b;++N){const R=r[N];if(R<0||R>=u[0])throw new Error(oI(N,r[N],u[0]));for(let O=0;O<l;O++)m[k*l+O]+=n[R*l+O]}if(o)for(let N=0;N<l;N++)m[k*l+N]/=b-x;if(x=b,++b,v=k+1,k=$,b>a)break}return v<c&&m.fill(i,v*l,c*l),[m,d]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sN=pn(n=>Math.sqrt(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oN=at((n,e)=>{const t=n-e;return t*t});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iN=pn((n,e)=>{const{pattern:t,replaceGlobal:r,rewrite:s}=e;return n.replace(new RegExp(t,r?"g":""),s)});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aN(n,e,t,r){const s=Ee(n,e.dtype);for(let o=0;o<s.size;o++){const i=s.indexToLoc(o),a=new Array(i.length);for(let u=0;u<a.length;u++)a[u]=i[u]*t[u]+r[u];s.set(e.get(...a),...i)}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uN{constructor(e,t,r,s,o,i){this.separator=Mn(e),this.nGramWidths=t,this.leftPad=Mn(r),this.rightPad=Mn(s),this.padWidth=o,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const r=this.getPadWidth(t);return Math.max(0,e+2*r-t+1)}createNGrams(e,t,r,s,o,i){for(let a=0;a<o;++a){const u=this.getPadWidth(i),l=Math.max(0,u-a),h=Math.max(0,u-(o-(a+1))),c=i-(l+h),d=t+(l>0?0:a-u);let f=0;f+=l*this.leftPad.length;for(let k=0;k<c;++k)f+=e[d+k].length;f+=h*this.rightPad.length;const m=l+h+c-1;f+=m*this.separator.length,r[s+a]=new Uint8Array(f);const x=r[s+a];let b=0;const v=k=>k.forEach($=>x[b++]=$);for(let k=0;k<l;++k)v(this.leftPad),v(this.separator);for(let k=0;k<c-1;++k)v(e[d+k]),v(this.separator);if(c>0){v(e[d+c-1]);for(let k=0;k<h;++k)v(this.separator),v(this.rightPad)}else{for(let k=0;k<h-1;++k)v(this.rightPad),v(this.separator);v(this.rightPad)}}}compute(e,t){const r=e.length,s=t.length;if(s>0){let u=t[0];if(u!==0)throw new Error(`First split value must be 0, got ${u}`);for(let l=1;l<s;++l){let h=t[l]>=u;if(h=h&&t[l]<=r,!h)throw new Error(`Invalid split value ${t[l]}, must be in [${u}, ${r}]`);u=t[l]}if(u!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${u}`)}const o=s-1,i=We("int32",s);if(r===0||s===0){const u=new Array(r);for(let l=0;l<=o;++l)i[l]=0;return[u,i]}i[0]=0;for(let u=1;u<=o;++u){const l=t[u]-t[u-1];let h=0;this.nGramWidths.forEach(c=>{h+=this.getNumNGrams(l,c)}),this.preserveShort&&l>0&&h===0&&(h=1),i[u]=i[u-1]+h}const a=new Array(i[o]);for(let u=0;u<o;++u){const l=t[u];let h=i[u];if(this.nGramWidths.forEach(c=>{const d=t[u+1]-t[u],f=this.getNumNGrams(d,c);this.createNGrams(e,l,a,h,f,c),h+=f}),this.preserveShort&&h===i[u]){const c=t[u+1]-t[u];if(c===0)continue;const d=c+2*this.padWidth;this.createNGrams(e,l,a,h,1,d)}}return[a,i]}}function lN(n,e,t,r,s,o,i,a){return new uN(t,r,s,o,i,a).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cN(n,e,t,r){if(!n.length)return;if(e.length===0){for(let o=0;o<n.length;++o)r.push(n.subarray(o,o+1));return}if(e.length===1){const o=e[0];let i=n.indexOf(o);for(;i!==-1;){const a=n.subarray(0,i);(!t||a.length!==0)&&r.push(a),n=n.subarray(i+1),i=n.indexOf(o)}(!t||n.length!==0)&&r.push(n);return}let s=0;for(let o=0;o<n.length+1;o++)if(o===n.length||e.indexOf(n[o])!==-1){const i=n.subarray(s,o);(!t||i.length!==0)&&r.push(i),s=o+1}}function hN(n,e,t){const r=n.length,s=[];let o=0,i=0;const a=new Array(r);for(let d=0;d<r;++d){const f=s.length;cN(n[d],e,t,s);const m=s.length-f;a[d]=m,o+=m,i=Math.max(i,m)}const u=We("int32",o*2),l=new Array(o),h=[r,i];let c=0;for(let d=0;d<r;++d)for(let f=0;f<a[d];++f)u[c*2]=d,u[c*2+1]=f,l[c]=s[c],++c;return[u,l,h]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dN(n,e){const t=We("int32",n.length);for(let r=0;r<n.length;++r)t[r]=Eg(n[r]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pN=at((n,e)=>n-e);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fN(n,e){const t=new Array(n.rank);for(let s=0;s<t.length;s++)t[s]=n.shape[s]*e[s];const r=Ee(t,n.dtype);for(let s=0;s<r.values.length;++s){const o=r.indexToLoc(s),i=new Array(n.rank);for(let u=0;u<i.length;u++)i[u]=o[u]%n.shape[u];const a=n.locToIndex(i);r.values[s]=n.values[a]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hr=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function df(n,e,t=0,r=n.length-1){for(;r>t;){if(r-t>600){const a=r-t+1,u=e-t+1,l=Math.log(a),h=.5*Math.exp(2*l/3),c=.5*Math.sqrt(l*h*(a-h)/a)*Math.sign(u-a/2),d=Math.max(t,Math.floor(e-u*h/a+c)),f=Math.min(r,Math.floor(e+(a-u)*h/a+c));df(n,e,d,f)}const s=n[e];let o=t,i=r;for(Mr(n,t,e),Hr(n[r],s)>0&&Mr(n,t,r);o<i;){for(Mr(n,o,i),o++,i--;Hr(n[o],s)<0;)o=o+1;for(;Hr(n[i],s)>0;)i=i-1}Hr(n[t],s)===0?Mr(n,t,i):(i=i+1,Mr(n,i,r)),i<=e&&(t=i+1),e<=i&&(r=i-1)}}function mN(n,e,t,r,s){const o=e[e.length-1],[i,a]=[n.length/o,o],u=wn(t,i*r),l=wn("int32",i*r);for(let c=0;c<i;c++){const d=c*a,f=n.subarray(d,d+a);let m=new Array(f.length);f.forEach((k,$)=>m[$]={value:k,index:$}),r<m.length&&(df(m,r),m=m.slice(0,r)),s&&m.sort(Hr);const x=c*r,b=u.subarray(x,x+r),v=l.subarray(x,x+r);for(let k=0;k<r;k++)b[k]=m[k].value,v[k]=m[k].index}const h=e.slice();return h[h.length-1]=r,[Ee(h,t,u),Ee(h,"int32",l)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gN(n,e,t,r){const s=Tt(e,t)[0],o=[1,t[0],1];for(let m=0;m<s;m++)o[0]*=t[m];o[1]=t[s];for(let m=s+1;m<t.length;m++)o[2]*=t[m];const i=new Map,a=new Int32Array(t[s]),u=new vr(o,r,n),l=[],h=o[0]===1&&o[2]===1;for(let m=0;m<t[s];m++){let x;if(h)x=n[m].toString();else{const v=[];for(let k=0;k<o[0];k++)for(let $=0;$<o[2];$++)v.push(u.get(k,m,$));x=v.join(",")}const b=i.get(x);if(b!=null)a[m]=b;else{const v=i.size;i.set(x,v),a[m]=v,l.push(m)}}const c=o.slice();c[1]=i.size;const d=new vr(c,r);l.forEach((m,x)=>{for(let b=0;b<o[0];b++)for(let v=0;v<o[2];v++)d.set(u.get(b,m,v),b,x,v)});const f=t.slice();return f[s]=c[1],{outputValues:d.values,outputShape:f,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yN=Object.freeze(Object.defineProperty({__proto__:null,addImpl:mk,bincountImpl:gk,bincountReduceImpl:yk,bitwiseAndImpl:bk,castImpl:fk,ceilImpl:wk,concatImpl:xk,equalImpl:vk,expImpl:Sk,expm1Impl:Ck,floorDivImpl:kk,floorImpl:Ik,gatherNdImpl:Nk,gatherV2Impl:$k,greaterEqualImpl:Ek,greaterImpl:Tk,lessEqualImpl:Ak,lessImpl:_k,linSpaceImpl:Rk,logImpl:Dk,maxImpl:Pk,maximumImpl:Ok,minimumImpl:Fk,multiplyImpl:hf,negImpl:zk,notEqualImpl:Lk,prodImpl:Mk,raggedGatherImpl:qk,raggedRangeImpl:Kk,raggedTensorToTensorImpl:Xk,rangeImpl:Yk,rsqrtImpl:Qk,scatterImpl:Zk,sigmoidImpl:Jk,simpleAbsImpl:pk,sliceImpl:eN,sparseFillEmptyRowsImpl:tN,sparseReshapeImpl:nN,sparseSegmentReductionImpl:rN,sqrtImpl:sN,squaredDifferenceImpl:oN,staticRegexReplaceImpl:iN,stridedSliceImpl:aN,stringNGramsImpl:lN,stringSplitImpl:hN,stringToHashBucketFastImpl:dN,subImpl:pN,tileImpl:fN,topKImpl:mN,transposeImpl:Bk,uniqueImpl:gN},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:bN,castImpl:wN,ceilImpl:xN,concatImpl:vN,equalImpl:SN,expImpl:CN,expm1Impl:IN,floorImpl:kN,floorDivImpl:NN,gatherNdImpl:$N,gatherV2Impl:TN,greaterEqualImpl:EN,greaterImpl:_N,lessEqualImpl:AN,lessImpl:RN,logImpl:DN,maxImpl:PN,maximumImpl:ON,minimumImpl:FN,multiplyImpl:zN,negImpl:LN,notEqualImpl:BN,prodImpl:MN,rangeImpl:VN,rsqrtImpl:WN,scatterImpl:UN,simpleAbsImpl:GN,sliceImpl:HN,stridedSliceImpl:jN,stringNGramsImpl:qN,subImpl:KN,tileImpl:XN,topKImpl:YN,transposeImpl:QN,uniqueImpl:tF}=yN;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZN=xe({opType:G.ABS,cpuKernelImpl:GN}),JN={kernelName:Yl,backendName:"webgpu",kernelFunc:ZN};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e$=xe({opType:G.ACOS}),t$={kernelName:Ql,backendName:"webgpu",kernelFunc:e$};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n$=xe({opType:G.ACOSH}),r$={kernelName:Zl,backendName:"webgpu",kernelFunc:n$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s$=Ue({opType:ae.ADD,cpuKernelImpl:bN,supportsComplex:!0}),o$={kernelName:Xi,backendName:"webgpu",kernelFunc:s$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i${constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map((t,r)=>`T${r}`),this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach(s=>{e.push(`let v${s} = get${s}ByOutputCoords(coords);`)});const t=this.variableNames.map(s=>`v${s}`).join(" + ");return`
      ${j("index")} {
        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if (flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            ${e.join(`
        `)}
            setOutputAtIndex(flatIndex, ${t});
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a$(n){const{inputs:e,backend:t}=n,r=e;if(r.length===1)return ft({inputs:{x:r[0]},backend:t});const s=r.map(a=>a.dtype).reduce((a,u)=>xn(a,u)),o=r.map(a=>a.shape),i=new i$(o);return t.runWebGPUProgram(i,r,s)}const u$={kernelName:Jl,backendName:"webgpu",kernelFunc:a$};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class l${constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[t[s]];this.outputShape=r,this.dispatchLayout={x:[0],y:[1]},this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){I(this.workgroupSize[0]===this.workgroupSize[1],()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`);const e=this.workgroupSize[0];return`
      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;
      ${j()} {
        var x = i32(workgroupId.x) * ${e} + i32(localId.x);
        var y = i32(workgroupId.y) * ${e} + i32(localId.y);
        let width = uniforms.outShape[0];
        let height = uniforms.outShape[1];
        if (x < width && y < height) {
          tile[localId.y][localId.x] = f32(A[y * width + x]);
        }
        workgroupBarrier();

        x = i32(workgroupId.y) * ${e} + i32(localId.x);
        y = i32(workgroupId.x) * ${e} + i32(localId.y);
        if (x < height && y < width) {
          setOutputAtIndex((y * height + x), tile[localId.x]
            [localId.y]);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class c${constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[t[s]];this.outputShape=r,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey=`transpose_${t}`}getUserCode(){const e=Fe(this.outputShape.length),t=pf(this.newDim);return`
      ${j("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(
              ${e}(${t}), uniforms.aShape)]);
          }
        }
      }
    `}}function pf(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=new Array(e);for(let r=0;r<n.length;r++)t[n[r]]=`coords.${sn(r)}`;return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qt(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{perm:o}=r,i=t,a=s.shape.length,u=new Array(a);for(let h=0;h<u.length;h++)u[h]=s.shape[o[h]];if(t.shouldExecuteOnCPU([s])){const c=i.tensorMap.get(s.dataId).values,d=QN(c,s.shape,s.dtype,o,u);return t.makeTensorInfo(u,s.dtype,d)}if(s.shape.length===2&&ot(o,[1,0])){const h=new l$(s.shape,o);return i.runWebGPUProgram(h,[s],s.dtype)}const l=new c$(s.shape,o);return i.runWebGPUProgram(l,[s],s.dtype)}const h$={kernelName:Ps,backendName:"webgpu",kernelFunc:Qt};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class d${constructor(e,t,r){this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[s]=fo(this.inputShape,[1]);this.outputShape=s.length===0?[1]:s,e.inSize>=32768&&r>=512?this.workgroupSize=[512,1,1]:e.inSize>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey=`reduce_${t}`}getUserCode(){let e="",t="0.0";const r=this.workgroupSize[0];this.reduceType==="min"||this.reduceType==="max"?(e=`
         if (isnan(candidate)) {
          bestValue = uniforms.NAN;
         } else if (!isnan(bestValue) && candidate ${this.reduceType==="min"?"<":">"} bestValue)
           {  bestValue = candidate; }`,t="f32(x[offset])"):this.reduceType==="sum"||this.reduceType==="mean"?e=" bestValue = bestValue + candidate; ":this.reduceType==="prod"?(e=" bestValue = bestValue * candidate; ",t="1.0"):this.reduceType==="all"?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):this.reduceType==="any"&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const s=this.reduceType==="mean"?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`
       fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
       }

       ${`
         var<workgroup> xBestValues : array<f32, ${r}>;
       `}
       fn getOffset(outputIndex : i32) -> i32 {
         let outputCoords = getCoordsFromIndex(outputIndex);
         let offset = ${this.outputShape.length===1?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;
          return offset;
       }
       ${j("index")} {
         let outputIndex = index / ${r};
         let offset = getOffset(outputIndex);
         var bestValue = ${t};
         let Length = uniforms.reduceSize;
         let WorkPerThread = DIV_CEIL(u32(Length), ${r}u);
         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;
             k = k + ${r}) {
           let candidate = f32(x[offset + k]);
           ${e}
         }
         xBestValues[localId.x] = bestValue;
         workgroupBarrier();

         var reduceSize = min(u32(Length), ${r}u);
         for (var currentSize = reduceSize / 2u; reduceSize > 1u;
             currentSize = reduceSize / 2u) {
           let interval = DIV_CEIL(reduceSize, 2u);
           if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            ${e}
            xBestValues[localId.x] = bestValue;
           }
           reduceSize = interval;
           workgroupBarrier();
         }

         if (localId.x == 0u && outputIndex < uniforms.size) {
          ${s}
        }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p$={mean:"float32",all:"bool",any:"bool"};function or(n,e,t,r,s){const o=n.shape.length,i=[],a=Tt(e,n.shape);let u=a;const l=ds(u,o);let h=n;l!=null&&(h=Qt({inputs:{x:n},attrs:{perm:l},backend:s}),u=ps(u.length,o),i.push(h)),sa(r,u,o);const[c,d]=fo(h.shape,u);let f=c;t&&(f=hs(c,a));let m;if((r==="max"||r==="prod")&&s.shouldExecuteOnCPU([h])){const x=s.tensorMap.get(h.dataId).values;switch(r){case"max":const b=PN(x,H(d),f,n.dtype);m=s.makeTensorInfo(f,n.dtype,b);break;case"prod":const{outVals:v,outShape:k,outDtype:$}=MN(h.shape,h.dtype,x,u);m=s.makeTensorInfo(k,$,v);break;default:throw new Error(`${r} CPU implementation is not yet supported.`)}}else{const x=H(d),v=H(h.shape)/x,k={windowSize:x,inSize:x,batchSize:v,outSize:1},$=p$[r]||Wg(n.dtype),N=[{type:"int32",data:[x]}],R=new d$(k,r,s.device.limits.maxComputeWorkgroupSizeX),O=s.runWebGPUProgram(R,[h],$,N);i.push(O),m=te({inputs:{x:O},attrs:{shape:f},backend:s})}return i.forEach(x=>s.disposeData(x.dataId)),m}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f$(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{keepDims:o,axis:i}=r;return or(s,i,o,"all",t)}const m$={kernelName:ec,backendName:"webgpu",kernelFunc:f$};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g$(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{keepDims:o,axis:i}=r;return or(s,i,o,"any",t)}const y$={kernelName:tc,backendName:"webgpu",kernelFunc:g$};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ff{constructor(e,t,r){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const s=[t];this.op=r==="min"?"<":">";const[o,i]=fo(e,s);this.outputShape=o.length===0?[1]:o,this.dispatchLayout=Q(this.outputShape),H(i)<32?(this.type="plain",this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=K(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>this.inputShape.length===1?"uniforms.xShape":`uniforms.xShape.${sn(this.inputShape.length-1)}`,r=()=>{let s="";if(this.outputShape.length===1)this.inputShape.length!==1&&(s+="outputCoords,");else for(let o=0;o<this.outputShape.length;o++)s+=`outputCoords.${sn(o)},`;return s};return this.type==="shared"?`
      fn DIV_CEIL(a : u32, b : u32) -> u32 {
        return ((a - 1u) / b + 1u);
      }

      ${`
      var<workgroup> xBestIndices : array<i32, ${e}>;
      var<workgroup> xBestValues : array<f32, ${e}>;
    `}

      ${j("index")} {
        let outputIndex = index / ${e};
        let reduceLength = ${t()};

        var bestIndex = i32(localId.x);
        var bestValue = uniforms.infinityValue;
        let outputCoords = getCoordsFromIndex(outputIndex);
        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;
            k = k + ${e}) {
          let candidate = getX(${r()} k);
          if (!isnan(candidate) && candidate ${this.op} bestValue) {
            bestValue = candidate;
            bestIndex = k;
          }
        }
        xBestValues[localId.x] = bestValue;
        xBestIndices[localId.x] = bestIndex;
        workgroupBarrier();

        var reduceSize = min(u32(reduceLength), ${e}u);
        for (var currentSize = reduceSize / 2u; reduceSize > 1u;
            currentSize = reduceSize / 2u) {
          let interval = DIV_CEIL(reduceSize, 2u);
          if (localId.x < currentSize) {
            let candidate = xBestValues[localId.x + interval];
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              xBestValues[localId.x] = bestValue;
              xBestIndices[localId.x] = xBestIndices[localId.x + interval];
            }
          }
          reduceSize = interval;
          workgroupBarrier();
        }

        if (localId.x == 0u && outputIndex < uniforms.size) {
          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);
        }
      }
    `:`
      ${j("index")} {
        if (index < uniforms.size) {
          let outputCoords = getCoordsFromIndex(index);
          var bestIndex = 0;
          var bestValue = getX(${r()} 0);
          let reduceLength = ${t()};
          for (var i = 1; i < reduceLength; i++) {
            let candidate = getX(${r()} i);
            if (candidate ${this.op} bestValue) {
              bestValue = candidate;
              bestIndex = i;
            }
          }
          setOutputAtIndexI32(index, bestIndex);
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b$(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o}=r;let i=Tt(o,s.shape);const a=ds(i,s.shape.length);let u=s;const l=[];a!=null&&(u=Qt({inputs:{x:s},backend:t,attrs:{perm:a}}),l.push(u),i=ps(i.length,u.shape.length)),sa("argMax",[i[0]],u.shape.length);const h=new ff(u.shape,i[0],"max"),c=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],d=t.runWebGPUProgram(h,[u],"int32",c);return l.forEach(f=>t.disposeData(f.dataId)),d}const w$={kernelName:nc,backendName:"webgpu",kernelFunc:b$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x$(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o}=r;let i=Tt(o,s.shape);const a=ds(i,s.shape.length);let u=s;const l=[];a!=null&&(u=Qt({inputs:{x:s},backend:t,attrs:{perm:a}}),l.push(u),i=ps(i.length,u.shape.length)),sa("argMin",[i[0]],u.shape.length);const h=new ff(u.shape,i[0],"min"),c=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],d=t.runWebGPUProgram(h,[u],"int32",c);return l.forEach(f=>t.disposeData(f.dataId)),d}const v$={kernelName:rc,backendName:"webgpu",kernelFunc:x$};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S$=xe({opType:G.ASIN}),C$={kernelName:sc,backendName:"webgpu",kernelFunc:S$};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I$=xe({opType:G.ASINH}),k$={kernelName:oc,backendName:"webgpu",kernelFunc:I$};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N$=xe({opType:G.ATAN}),$$={kernelName:ic,backendName:"webgpu",kernelFunc:N$};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T$=Ue({opType:ae.ATAN2}),E$={kernelName:uc,backendName:"webgpu",kernelFunc:T$};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _$=xe({opType:G.ATANH}),A$={kernelName:ac,backendName:"webgpu",kernelFunc:_$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R${constructor(e){this.variableNames=["x"],this.uniforms="strides : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`
      ${j("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];

          let xRCCorner = coords.yz * uniforms.strides;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          let value = getX(batch, xRCorner, xCCorner, d);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class os{constructor(e,t,r=!1,s=!1,o=!1){if(this.variableNames=["x"],this.uniforms="strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=r,this.flattenPositions=s,this.includeBatchIndex=o,this.shaderKey=`pool2D_${t}_${r}_${s}_${o}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue = resultValue + value; count = count + 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"((batch * uniforms.xShape[1] + xR) * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"(xR * uniforms.xShape[2] + xC) * uniforms.xShape[3] + d":"wR * uniforms.filterDims.y + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${j("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let batch = coords[0];
          let d = coords[3];
          let xRCCorner = vec2<i32>(coords.yz) * uniforms.strides - uniforms.pads;
          let xRCorner = xRCCorner.x;
          let xCCorner = xRCCorner.y;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilations.x) {
            let xR = xRCorner + wR;

            if (xR < 0 || xR >= uniforms.convDims.x) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilations.y) {
              let xC = xCCorner + wC;
              if (xC < 0 || xC >= uniforms.convDims.y) {
                continue;
              }

              let value = getX(batch, xR, xC, d);
              ${e}
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}}class Ea{constructor(e,t,r=!1,s=!1,o=!1){if(this.variableNames=["x"],this.uniforms="strides : vec3<i32>, pads : vec3<i32>, convDims : vec3<i32>, filterDims : vec3<i32>,",this.workgroupSize=[128,1,1],this.size=!0,t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");this.outputShape=e.outShape,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.poolType=t,this.computePositions=r,this.flattenPositions=s,this.includeBatchIndex=o,this.shaderKey=`pool3D_${t}_${r}_${s}_${o}`}getUserCode(){let e;this.poolType==="avg"?e="resultValue += value; count += 1.0;":this.computePositions?e=`let currMaxValue = mix(value, maxValue, maxValueFound);
      if (value >= currMaxValue) {
        maxValue = value;
        maxValueFound = 1.0;
        maxPosition = ${this.flattenPositions?this.includeBatchIndex?"(((batch * uniforms.xShape.y + xD) * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"((xD * uniforms.xShape.z + xR) * uniforms.xShape.w + xC) * uniforms.xShape.u + ch":"wD * uniforms.filterDims.y * uniforms.filterDims.y + wR * uniforms.filterDims.z + wC"};
      }`:e="resultValue = max(value, resultValue);";let t="resultValue";return this.poolType==="avg"&&(t="resultValue / max(count, 1.0)"),`
      ${j("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let batch = coords.x;
          let ch = coords.u;

          let xCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
          let xDCorner = xCorner.x;
          let xRCorner = xCorner.y;
          let xCCorner = xCorner.z;

          ${this.computePositions?`var maxValue = 0.0;
            var maxValueFound = 0.0;
            var maxPosition = 0;`:`var resultValue = ${this.poolType==="avg"?"0.0":"-1.0 / pow(10.0, -20.0)"};`}

          var count = 0.0;
          for (var wD = 0; wD < uniforms.filterDims.x; wD++) {
            let xD = xDCorner + wD;
            if (xD < 0 || xD >= uniforms.convDims.x) {
              continue;
            }

            for (var wR = 0; wR < uniforms.filterDims.y; wR++) {
              let xR = xRCorner + wR;
              if (xR < 0 || xR >= uniforms.convDims.y) {
                continue;
              }

              for (var wC = 0; wC < uniforms.filterDims.z; wC++) {
                let xC = xCCorner + wC;
                if (xC < 0 || xC >= uniforms.convDims.z) {
                  continue;
                }

                let value = getX(batch, xD, xR, xC, ch);
                ${e}
              }
            }
          }

          ${this.computePositions?"setOutputAtIndexI32(index, maxPosition);":`setOutputAtIndex(index, ${t});`}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mf(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reductionIndices:o,keepDims:i}=r;return or(s,o,i,"max",t)}const D$={kernelName:gh,backendName:"webgpu",kernelFunc:mf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gf(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{keepDims:o,axis:i}=r;return or(s,i,o,"mean",t)}const P$={kernelName:vh,backendName:"webgpu",kernelFunc:gf};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yf(n,e,t,r){if(e.filterWidth===1&&e.filterHeight===1&&ot(e.inShape,e.outShape))return ft({inputs:{x:n},backend:r});if(e.filterWidth===e.inWidth&&e.filterHeight===e.inHeight&&e.batchSize===1&&e.padInfo.type==="VALID"){const i=n.shape.length,a=te({inputs:{x:n},backend:r,attrs:{shape:[n.shape[i-3]*n.shape[i-2],n.shape[i-1]]}});let u;t==="avg"?u=gf({inputs:{x:a},backend:r,attrs:{axis:0,keepDims:!1}}):(I(t==="max",()=>`Invalid pool type ${t}`),u=mf({inputs:{x:a},backend:r,attrs:{reductionIndices:0,keepDims:!1}}));const l=te({inputs:{x:u},backend:r,attrs:{shape:e.outShape}});return r.disposeData(a.dataId),r.disposeData(u.dataId),l}let s;const o=[{type:"int32",data:[e.strideHeight,e.strideWidth]}];return e.filterHeight===1&&e.filterWidth===1?s=new R$(e):(t==="avg"?s=new os(e,"avg"):(I(t==="max",()=>`Invalid pool type ${t}`),s=new os(e,"max")),o.push({type:"int32",data:[e.padInfo.top,e.padInfo.left]},{type:"int32",data:[e.dilationHeight,e.dilationWidth]},{type:"int32",data:[e.inHeight,e.inWidth]},{type:"int32",data:[e.effectiveFilterHeight,e.effectiveFilterWidth]})),r.runWebGPUProgram(s,[n],n.dtype,o)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O$(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=r,h=Nr(s.shape,o,i,1,a,u);return yf(s,h,"avg",t)}const F$={kernelName:lc,backendName:"webgpu",kernelFunc:O$};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z$(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:o,strides:i,pad:a,dataFormat:u,dimRoundingMode:l}=r,h=[1,1,1],c=lo(s.shape,o,i,h,a,l,u),d=new Ea(c,"avg"),f=[{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.padInfo.front,c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.inDepth,c.inHeight,c.inWidth]},{type:"int32",data:[c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth]}];return t.runWebGPUProgram(d,[s],s.dtype,f)}const L$={kernelName:cc,backendName:"webgpu",kernelFunc:z$};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class B${constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool2DBackprop"}getUserCode(){return`
      ${j("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);

            dotProd = dotProd + dyValue * uniforms.avgMultiplier;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class M${constructor(e){this.variableNames=["dy"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
       outDepth : i32, outHeight : i32, outWidth : i32, avgMultiplier : f32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avgPool3DBackprop"}getUserCode(){return`
      ${j("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              dotProd += dyValue * uniforms.avgMultiplier;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V$(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o}=e,i=o,{filterSize:a,strides:u,pad:l,dimRoundingMode:h}=r,c=lo(i.shape,a,u,1,l,h),d=new M$(c),f=1/(c.filterDepth*c.filterHeight*c.filterWidth),m=[{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.effectiveFilterDepth-1-c.padInfo.front,c.effectiveFilterHeight-1-c.padInfo.top,c.effectiveFilterWidth-1-c.padInfo.left]},{type:"int32",data:[c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth]},{type:"int32",data:[c.outDepth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"float32",data:[f]}];return t.runWebGPUProgram(d,[s],i.dtype,m)}const W$={kernelName:Ym,backendName:"webgpu",kernelFunc:V$};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U$(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o}=e,i=o;lf([s,o],"avgPoolGrad");const{filterSize:a,strides:u,pad:l}=r,h=Nr(i.shape,a,u,1,l),c=new B$(h),d=1/(h.filterHeight*h.filterWidth),f=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.effectiveFilterHeight-1-h.padInfo.top,h.effectiveFilterWidth-1-h.padInfo.left]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[h.effectiveFilterHeight,h.effectiveFilterWidth]},{type:"int32",data:[h.outHeight]},{type:"int32",data:[h.outWidth]},{type:"float32",data:[d]}];return t.runWebGPUProgram(c,[s],i.dtype,f)}const G$={kernelName:Xm,backendName:"webgpu",kernelFunc:U$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H$(n){const{inputs:e,backend:t,attrs:r}=n,{a:s,b:o}=e,{transposeA:i,transposeB:a}=r;return Co({a:s,b:o,transposeA:i,transposeB:a,backend:t})}const j$={kernelName:hc,backendName:"webgpu",kernelFunc:H$};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class q${constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${Fe(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=Fe(this.rank),t=K$(this.rank);let r;return this.start.length===1?r=this.outputShape.map((o,i)=>"sourceLoc = uniforms.start + coords;"):r=this.outputShape.map((o,i)=>`sourceLoc.${Di[i]} = uniforms.start.${sn(i)} + coords.${Di[i]};`),`
      ${j("index")} {
        if (index < uniforms.size) {
          var sourceLoc : ${e};
          let coords = getCoordsFromIndex(index);
          ${r.join(`
`)}
          setOutputAtIndex(index, getSource(${t}));
        }
      }
    `}}const Di=["x","y","z","w","u","v"];function K$(n){if(n===1)return"sourceLoc";if(n<=6)return Di.slice(0,n).map(e=>`sourceLoc.${e}`).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _r(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:o,size:i}=r,[a,u]=SC(s,o,i);if(bC(s,a,u),t.shouldExecuteOnCPU([s])||s.dtype==="string"){const c=t.tensorMap.get(s.dataId),d=HN(c.values,a,u,s.shape,s.dtype);return t.makeTensorInfo(u,s.dtype,d)}if(H(u)===0)return t.makeTensorInfo(u,s.dtype,[]);const l=new q$(a,u),h=[{type:"int32",data:a}];return t.runWebGPUProgram(l,[s],s.dtype,h)}const X$={kernelName:td,backendName:"webgpu",kernelFunc:_r};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y$=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:o,crops:i}=r;I(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet");const a=o.reduce((k,$)=>k*$),u=tf(s.shape,o,a),l=nf(u.length,o.length),h=rf(s.shape,o,a),c=AC(i,o.length),d=RC(h,i,o.length),f=[],m=te({inputs:{x:s},backend:t,attrs:{shape:u}}),x=Qt({inputs:{x:m},backend:t,attrs:{perm:l}}),b=te({inputs:{x},backend:t,attrs:{shape:h}}),v=_r({inputs:{x:b},backend:t,attrs:{begin:c,size:d}});return f.push(m),f.push(x),f.push(b),f.forEach(k=>t.disposeData(k.dataId)),v},Q$={kernelName:dc,backendName:"webgpu",kernelFunc:Y$};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z$=`
  fn bincount_write(index: i32, value: f32) {
    ${kn("&result[index]","value","float32")}
  }
`,J$=`
  fn bincount_write(index: i32, value: f32) {
    atomicStore(&result[index], bitcast<i32>(value));
  }
`;class bf{constructor(e,t,r=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=r,r&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`
    ${this.binaryOutput?J$:Z$}
  ${j("index")} {
    ${this.rank===1?`if (index < uniforms.xShape) {
      let indexVal = i32(getX(index));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};
        bincount_write(indexVal, value);
      }
    }`:`let coord = getCoordsFromIndex(index);
    if (coordsInBounds2D(coord, uniforms.xShape)) {
      let indexVal = i32(getX(coord[0], coord[1]));
      if (indexVal < uniforms.binCountSize) {
        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};
        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);
      }
    }`}
  }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eT(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:o}=e,{size:i}=r,a=H(s.shape),l=H(o.shape)>0,h=[i],c=o.dtype,d=st({backend:t,attrs:{shape:h,value:0,dtype:c}}),f=new bf([a],l),m=[{type:"int32",data:[i]}],x=l?[s,o]:[s];return t.runWebGPUProgram(f,x,c,m,d)}const tT={kernelName:pc,backendName:"webgpu",kernelFunc:eT};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nT{constructor(e){this.outputShape=[],this.variableNames=["s0","s1"],this.uniforms="s0Size : i32, s1Size : i32, ",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="broadcastArgs"}getUserCode(){return`
  ${j("index")} {
    if (index < uniforms.size) {
      var s0 = 1.0;
      var s1 = 1.0;
      let indexS0 = index - uniforms.size + uniforms.s0Size;
      let indexS1 = index - uniforms.size + uniforms.s1Size;
      if (indexS0 >= 0) {
        s0 = getS0(indexS0);
      }
      if (indexS1 >= 0) {
        s1 = getS1(indexS1);
      }

      if (s0 == 1.0) {
        setOutputAtIndex(index, s1);
      } else if (s1 == 1.0) {
        setOutputAtIndex(index, s0);
      } else if (s0 != s1) {
        setOutputAtIndex(index, uniforms.NAN);
      } else {
        setOutputAtIndex(index, s0);
      }
    }
  }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rT(n){const{inputs:e,backend:t}=n,{s0:r,s1:s}=e;if(t.shouldExecuteOnCPU([r,s])){const h=t.tensorMap.get(r.dataId),c=t.tensorMap.get(s.dataId),d=h.values,f=c.values,m=Ce(Array.from(d),Array.from(f));return t.makeTensorInfo([m.length],"int32",Int32Array.from(m))}const o=H(r.shape),i=H(s.shape),a=Math.max(o,i),u=new nT(a),l=[{type:"int32",data:[o]},{type:"int32",data:[i]}];return t.runWebGPUProgram(u,[r,s],"int32",l)}const sT={kernelName:fc,backendName:"webgpu",kernelFunc:rT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wf=Ue({opType:ae.NOT_EQUAL,dtype:"bool",cpuKernelImpl:BN}),oT={kernelName:Eh,backendName:"webgpu",kernelFunc:wf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ms(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.tensorMap.get(r.dataId);return ft({inputs:{x:s.complexTensorInfos.real},backend:t})}const iT={kernelName:Mh,backendName:"webgpu",kernelFunc:ms};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aT(n,e){const t=new Er(n.shape,G.TO_INT),r=e.runWebGPUProgram(t,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pi(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dtype:o}=r;if(o==="complex64"){if(s.dtype==="complex64")return ft({inputs:{x:s},backend:t});const i=Xn(s.shape),a=Pi({inputs:{x:s},backend:t,attrs:{dtype:"float32"}}),u=sr({inputs:{real:a,imag:i},backend:t});return i.dispose(),t.disposeData(a.dataId),u}if(s.dtype==="complex64"){const i=ms({inputs:{input:s},backend:t}),a=Pi({inputs:{x:i},backend:t,attrs:{dtype:o}});return t.disposeData(i.dataId),a}if(!Bm(s.dtype,o)){const i=ft({inputs:{x:s},backend:t});return{dataId:i.dataId,shape:i.shape,dtype:o}}if(t.shouldExecuteOnCPU([s])){const i=t.tensorMap.get(s.dataId).values,[a,u,l]=wN(i,s.shape,s.dtype,o);return t.makeTensorInfo(a,u,l)}if(o==="int32")return aT(s,t);if(o==="bool"){const i=t.makeTensorInfo([],"bool",wn("bool",1)),u=wf({inputs:{a:s,b:i},backend:t});return t.disposeData(i.dataId),u}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}const uT={kernelName:Yi,backendName:"webgpu",kernelFunc:Pi};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lT=xe({opType:G.CEIL,cpuKernelImpl:xN}),cT={kernelName:mc,backendName:"webgpu",kernelFunc:lT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hT{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.outputComponent=4,this.size=!0,this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`
      ${j("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          var clampedValue = clamp(
              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));
          clampedValue = select(clampedValue, value, isnanVec4(value));
          setOutputAtIndex(index, clampedValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dT{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`
      ${j("index")} {
        if(index < uniforms.size) {
          let value = getAByOutputIndex(index);
          if (isnan(value)) {
            setOutputAtIndex(index, value);
            return;
          }
          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pT(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{clipValueMin:o,clipValueMax:i}=r;let a;const u=[{type:"float32",data:[o]},{type:"float32",data:[i]}];return H(s.shape)%4===0?a=new hT(s.shape):a=new dT(s.shape),t.runWebGPUProgram(a,[s],s.dtype,u)}const fT={kernelName:gc,backendName:"webgpu",kernelFunc:pT};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mT{constructor(e){this.outputShape=[],this.variableNames=["real","imag"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="complexAbs"}getUserCode(){return`
    ${j("index")} {
      if (index < uniforms.size) {
        let re = abs(getRealByOutputIndex(index));
        let im = abs(getImagByOutputIndex(index));
        let mx = max(re, im);

        // The length function in wgsl may be not underflow-safe on some GPUs.
        // So the safe solution is to ensure underflow-safety in all cases.
        setOutputAtIndex(index, select(mx * length(vec2<f32>(1, min(re, im)/mx)), 0.0, mx == 0.0));
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xl(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function gT(n){const{inputs:e,backend:t}=n,{x:r}=e,s=t.tensorMap.get(r.dataId),o=new mT(r.shape),i=[xl(r,s.complexTensorInfos.real),xl(r,s.complexTensorInfos.imag)];return t.runWebGPUProgram(o,i,i[0].dtype)}const yT={kernelName:bc,backendName:"webgpu",kernelFunc:gT};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bT{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=ss(e,1),this.variableNames=e.map((t,r)=>`T${r}`),this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let t=0;t<this.offsetLength;t++)this.uniforms+=`offset${t} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let o=1;o<this.offsetLength;o++)e.push(`else if (yC < uniforms.offset${[o]}){ setOutputAtCoords(coords.x, coords.y, getT${o}(yR, yC - uniforms.offset${o-1})); }`);const r=this.offsetLength,s=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${r}(yR, yC - uniforms.offset${s})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`
      ${j("index")} {
        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let flatIndex = index * ${this.workPerThread} + i;
          if(flatIndex < uniforms.size) {
            let coords = getCoordsFromIndex(flatIndex);
            let yR = coords.x;
            let yC = coords.y;

            ${e.join(`
        `)}
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Io(n){const{inputs:e,backend:t}=n,{input:r}=e,s=t.tensorMap.get(r.dataId);return ft({inputs:{x:s.complexTensorInfos.imag},backend:t})}const wT={kernelName:nh,backendName:"webgpu",kernelFunc:Io};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jr(n,e,t){const r=n[0].dtype;if(r==="complex64"){const m=n.map($=>ms({inputs:{input:$},backend:t})),x=n.map($=>Io({inputs:{input:$},backend:t})),b=jr(m,e,t),v=jr(x,e,t),k=sr({inputs:{real:b,imag:v},backend:t});return m.forEach($=>t.disposeData($.dataId)),x.forEach($=>t.disposeData($.dataId)),t.disposeData(b.dataId),t.disposeData(v.dataId),k}let s=t.shouldExecuteOnCPU(n);if(r==="string"&&(s=!0),s){const m=n.map(R=>{const F=[-1,H(R.shape.slice(e))];return te({inputs:{x:R},backend:t,attrs:{shape:F}})}),x=m.map(R=>({vals:t.readSync(R.dataId),shape:R.shape})),b=ss(m.map(R=>R.shape),1),v=m[0].shape[0]===1,k=vN(x,b,r,v),$=ss(n.map(R=>R.shape),e),N=t.makeTensorInfo($,r,k);return m.forEach(R=>t.disposeData(R.dataId)),N}const o=t.device.limits.maxStorageBuffersPerShaderStage-1;if(n.length>o){const m=[];for(let b=0;b<n.length;b+=o){const v=n.slice(b,b+o);m.push(jr(v,e,t))}const x=jr(m,e,t);for(const b of m)t.disposeData(b.dataId);return x}const{tensors2D:i,outShape:a}=xT(n,e,t),u=i.map(m=>m.shape),l=new bT(u),h=[],c=new Array(u.length-1);if(c.length>0){c[0]=u[0][1],h.push({type:"int32",data:[c[0]]});for(let m=1;m<c.length;m++)c[m]=c[m-1]+u[m][1],h.push({type:"int32",data:[c[m]]})}const d=t.runWebGPUProgram(l,i,i[0].dtype,h);i.forEach(m=>t.disposeData(m.dataId));const f=te({inputs:{x:d},backend:t,attrs:{shape:a}});return t.disposeData(d.dataId),f}function xT(n,e,t){const r=ss(n.map(o=>o.shape),e);return{tensors2D:n.map(o=>te({inputs:{x:o},backend:t,attrs:{shape:[H(o.shape.slice(0,e)),H(o.shape.slice(e))]}})),outShape:r}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xf(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r,o=Tt(s,e[0].shape)[0],i=e.map(l=>l.shape);kC(i,o);const a=ss(e.map(l=>l.shape),o);if(H(a)===0)return t.makeTensorInfo(a,e[0].dtype,[]);const u=e.filter(l=>H(l.shape)>0);return u.length===1?ft({inputs:{x:u[0]},backend:t}):jr(u,o,t)}const vT={kernelName:wc,backendName:"webgpu",kernelFunc:xf};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ST(n,e,t,r,s=!1,o=null,i=!1,a=4,u=4,l=4){const h=L=>{switch(L){case 1:return"resData = f32(x[xIndex]);";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = vec4<f32>(x[xIndex / 4]);";default:throw new Error(`innerElementSize ${L} is not supported.`)}},c=L=>{switch(L){case 1:return"return f32(W[row * uniforms.wShape[3] + col]);";case 4:return"return vec4<f32>(W[(row * uniforms.wShape[3] + col) / 4]);";default:throw new Error(`innerElementSize ${L} is not supported.`)}},d=n?`
      let coord = vec4<i32>(batch, xRow, xCol, xCh);
      `:`
      let coord = vec4<i32>(batch, xCh, xRow, xCol);
      `,f=n?`
      let coords = vec4<i32>(
        batch,
        row / outWidth,
        row % outWidth,
        col);
      `:`
      let coords = vec4<i32>(
        batch,
        row,
        col / outWidth,
        col % outWidth);
      `,m=n?"uniforms.xShape[1]":"uniforms.xShape[2]",x=n?"uniforms.xShape[2]":"uniforms.xShape[3]",b=n?"row":"col",v=n?"col":"row",k=`
      let inChannels = uniforms.wShape[2];
      let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
      let outRow = ${b} / outWidth;
      let outCol = ${b} % outWidth;

      let WRow = ${v} / (uniforms.filterDims[1] * inChannels);
      let WCol = ${v} / inChannels % uniforms.filterDims[1];
      let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * WRow - uniforms.pads[0];
      let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * WCol - uniforms.pads[1];
      let xCh = ${v} % inChannels;
      var resData = ${de(a)}(0.0);
      // The bounds checking is always needed since we use it to pad zero for
      // the 'same' padding type.
      if (xRow >= 0 && xRow < ${m} && xCol >= 0 && xCol < ${x}) {
        ${d}
        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);
        ${h(a)}
      }
      return resData;`,$=n?e&&r?`
      ${k}`:`
      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${k}
      }
      return ${de(a)}(0.0);`:r&&t?`
      ${k}`:`
      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {
        ${k}
      }
      return ${de(a)}(0.0);`,N=`${c(u)}`,R=de(l),O=de(n?a:u),F=de(n?u:a);return`
      ${dn(o,i,l===4,4)}
      fn mm_readA(batch: i32, row : i32, col : i32) -> ${O} {
        ${n?$:N}
      }

      fn mm_readB(batch: i32, row : i32, col : i32) -> ${F} {
        ${n?N:$}
      }

      fn mm_write(batch: i32, row : i32, col : i32, valueIn : ${R}) {
        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)
        {
        var value = valueIn;
        let outWidth = ${n?"uniforms.outShape[2]":"uniforms.outShape[3]"};
        ${f}
        ${rr(s,o)}
        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }`}class CT{constructor(e,t,r,s,o=!1,i=null,a=!1,u=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=((e.inChannels%4===0||e.inChannels%3===0)&&this.isChannelsLast||e.outWidth%4===0&&!this.isChannelsLast)&&e.outChannels%4===0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=of(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=af(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.outputComponent=4,this.isChannelsLast&&e.inChannels%4!==0?(this.innerElementSize=3,this.variableComponents=[1,4]):(this.innerElementSize=4,this.variableComponents=[4,4]),o&&(this.variableNames.push("bias"),this.variableComponents.push(4)),a&&(this.variableNames.push("preluActivationWeights"),this.variableComponents.push(4))):(this.innerElementSize=this.elementsPerThread[0],o&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=u,this.addBias=o,this.activation=i,this.hasPreluActivationWeights=a,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter===0,this.fitBOuter=r%this.tileBOuter===0,this.fitInner=s%this.tileInner===0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?vo(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):So(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`
    ${ST(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}
    ${e}
  `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IT{constructor(e,t=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=r,this.hasPreluActivationWeights=s,t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`
       ${dn(this.activation,this.hasPreluActivationWeights,!1,4)}
       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{
         let coords = vec4<i32>(batch, row, col, chan);
         if (coordsInBounds4D(coords, uniforms.xShape)) {
           return  getX(batch, row, col, chan);
         } else {
          return 0.0;
         }
       }
       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{
         let coords = vec4<i32>(row, col, xChannel, outChannel);
         if(coordsInBounds4D(coords, uniforms.wShape)) {
           return getW(row, col, xChannel, outChannel);
          } else {
            return 0.0;
          }
       }
       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {
         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}
         if (coordsInBounds4D(coords, uniforms.outShape)) {
           var value = valueIn;
           ${rr(this.addBias,this.activation)}
           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);
         }
       }
       ${j("index")} {
         let coords = getOutputCoords();
         let batch = coords[0];
         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}
         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}
         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}
         var acc : f32 = 0.0;
         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {
           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {
             let xRow = outRow * uniforms.strides[0] + uniforms.dilations[0] * row - uniforms.pads[0];
             let xCol = outCol * uniforms.strides[1] + uniforms.dilations[1] * col - uniforms.pads[1];
             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {
               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}
               let f = readFilt(row, col, xChannel, outChannel);
               acc = acc + v * f;
             }
           }
         }
         writeResult(batch, outRow, outCol, outChannel, acc);
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kT{constructor(e,t){this.variableNames=["x"],this.uniforms=`pads : vec2<i32>, strides : vec2<i32>, dilations : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,
       inChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey=`im2col_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,r=this.isChannelsLast?"coords[1]":"coords[2]",s=this.isChannelsLast?"coords[2]":"coords[1]",o=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`
    ${j("index")} {
      let coords = getCoordsFromIndex(index);
      if(index < uniforms.size) {
        let batch = coords[0];
        let row = ${r};
        let col = ${s};
        let offsetY = (row / uniforms.outWidth) * uniforms.strides[0] - uniforms.pads[0];
        let xRow = offsetY + uniforms.dilations[0] * (col / uniforms.itemsPerBlockRow);
        var value = 0.0;
        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {
          let offsetX = (row % uniforms.outWidth) * uniforms.strides[1] -
              uniforms.pads[1];
          let xCol = offsetX + uniforms.dilations[1] * ((col %
              uniforms.itemsPerBlockRow) / uniforms.inChannels);
          let ch = col % uniforms.inChannels;
          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {
            value = ${o};
          }
        }
        setOutputAtIndex(index, value);
      }
    }
   `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Js(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function NT({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const u=t.dataFormat==="channelsLast",l=!u,h=!1,c=u&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",d=[];let f,m;if(c){const v=t.inHeight*t.inWidth*t.inChannels;f=te({inputs:{x:n},backend:r,attrs:{shape:[1,t.batchSize,v]}}),m=te({inputs:{x:e},backend:r,attrs:{shape:[1,v,t.outChannels]}})}else f=te({inputs:{x:n},backend:r,attrs:{shape:u?[t.batchSize,t.inHeight*t.inWidth,t.inChannels]:[t.batchSize,t.inChannels,t.inHeight*t.inWidth]}}),m=te({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}});if(d.push(f),d.push(m),o!=null){const v=Js(o.shape,u);v!=null&&(o=te({inputs:{x:o},backend:r,attrs:{shape:v}}),d.push(o))}if(s!=null){const v=Js(s.shape,u);v!=null&&(s=te({inputs:{x:s},backend:r,attrs:{shape:v}}),d.push(s))}const x=Co({a:u?f:m,b:u?m:f,transposeA:l,transposeB:h,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),b=te({inputs:{x},backend:r,attrs:{shape:t.outShape}});d.push(x);for(const v of d)r.disposeData(v.dataId);return b}function $T({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const{filterWidth:u,filterHeight:l,inChannels:h,strideWidth:c,strideHeight:d,padInfo:f,outWidth:m,outHeight:x,dilationWidth:b,dilationHeight:v,dataFormat:k}=t,$=k==="channelsLast",N=u*l*h,R=x*m,O=$?[t.batchSize,R,N]:[t.batchSize,N,R],F=new kT(O,$),B=[{type:"int32",data:[f.top,f.left]},{type:"int32",data:[d,c]},{type:"int32",data:[v,b]},{type:"int32",data:[m]},{type:"int32",data:[h*u]},{type:"int32",data:[h]}],L=r.runWebGPUProgram(F,[n],n.dtype,B),W=[];W.push(L);const V=te({inputs:{x:e},backend:r,attrs:{shape:[1,N,-1]}});if(W.push(V),o!=null){const he=Js(o.shape,$);he!=null&&(o=te({inputs:{x:o},backend:r,attrs:{shape:he}}),W.push(o))}if(s!=null){const he=Js(s.shape,$);he!=null&&(s=te({inputs:{x:s},backend:r,attrs:{shape:he}}),W.push(s))}const ne=Co({a:$?L:V,b:$?V:L,transposeA:!$,transposeB:!1,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i}),re=te({inputs:{x:ne},backend:r,attrs:{shape:t.outShape}});W.push(ne);for(const he of W)r.disposeData(he.dataId);return re}function vf({x:n,filter:e,convInfo:t,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:a=null}){const u=s!=null,l=o!=null,h=t.dataFormat==="channelsLast",c=h&&t.filterHeight===t.inHeight&&t.filterWidth===t.inWidth&&t.padInfo.type==="VALID",d=oe().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!d&&(c||t.filterHeight===1&&t.filterWidth===1&&t.dilationHeight===1&&t.dilationWidth===1&&t.strideHeight===1&&t.strideWidth===1&&(t.padInfo.type==="SAME"||t.padInfo.type==="VALID")))return NT({x:n,filter:e,convInfo:t,backend:r,bias:s,activation:a,preluActivationWeights:o,leakyreluAlpha:i});const f=oe().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),m=f>-1?f:r.thresholdToIncreaseWorkgroups,x=t.batchSize*Math.ceil(t.outHeight*t.outWidth/32)*Math.ceil(t.outChannels/32);if(oe().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||x<=m)return $T({x:n,filter:e,convInfo:t,backend:r,bias:s,preluActivationWeights:o,leakyreluAlpha:i,activation:a});let b;const v=[t.padInfo.top,t.padInfo.left],k=[{type:"int32",data:[t.filterHeight,t.filterWidth]},{type:"int32",data:[...v]},{type:"int32",data:[t.strideHeight,t.strideWidth]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]}];if(d)b=new IT(t,u,a,l);else{const O=h?t.outHeight*t.outWidth:t.outChannels,F=h?t.outChannels:t.outHeight*t.outWidth,B=t.filterHeight*t.filterWidth*t.inChannels;k.push({type:"int32",data:[O]},{type:"int32",data:[F]},{type:"int32",data:[B]});const L=r.adapterInfo.isIntel();b=new CT(t,O,F,B,u,a,l,L)}const $=[],N=[n,e];u&&(!h&&s.shape.length===1&&(s=te({inputs:{x:s},backend:r,attrs:{shape:[s.shape[0],1,1]}}),$.push(s)),N.push(s)),l&&(!h&&o.shape.length===1&&(o=te({inputs:{x:o},backend:r,attrs:{shape:[o.shape[0],1,1]}}),$.push(o)),N.push(o)),a==="leakyrelu"&&(k.push({type:"float32",data:[i]}),b.uniforms+=" alpha : f32,");const R=r.runWebGPUProgram(b,N,n.dtype,k);for(const O of $)r.disposeData(O.dataId);return R}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TT(n){const{inputs:e,attrs:t,backend:r}=n,{x:s,filter:o}=e,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:h}=t,c=$r(u),d=Et(s.shape,o.shape,i,l,a,h,!1,c);return vf({x:s,filter:o,convInfo:d,backend:r})}const ET={kernelName:xc,backendName:"webgpu",kernelFunc:TT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _T{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!1,this.isVec4=!1,this.workPerThread=1,this.outputShape=e.inShape,this.isChannelsLast=e.dataFormat==="channelsLast",this.isVec4=this.isChannelsLast&&e.outChannels%4===0&&e.inChannels%4===0,this.isVec4?(this.workPerThread=2,this.outputComponent=4,this.workgroupSize=[4,4,4],this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1])):(this.size=!0,this.workPerThread=1,this.workgroupSize=[64,1,1],this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize)),this.shaderKey=`conv2DDerInput_${this.isChannelsLast}_${this.isVec4}_${this.workPerThread}`}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,r=this.isChannelsLast?3:1,s=`
    ${j()} {
      let batch = i32(globalId.z) / uniforms.outShape[1];
      let r = i32(globalId.z) % uniforms.outShape[1];
      let c = i32(globalId.y) * ${this.workPerThread};
      let d1 = i32(globalId.x) * 4;

      let dyCorner = vec2<i32>(r, c) - uniforms.pads;

      // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
      // ? = to be determined. : = across all values in that axis.
      var dotProd: array<vec4<f32>, ${this.workPerThread}>;
      for (var i = 0; i < ${this.workPerThread}; i++) {
        dotProd[i] = vec4<f32>(0.0);
      }
      for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
        let dyR = f32(dyCorner.x + wR) / f32(uniforms.strides.x);
        let wRPerm = uniforms.filterDims.x - 1 - wR;
        if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) ||
            fract(dyR) > 0.0) {
          continue;
        }
        let idyR = i32(dyR);

        for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
          let dyC = f32(dyCorner.y + wC) / f32(uniforms.strides.y);
          let dyC2 = f32(dyCorner.y + 1 + wC) / f32(uniforms.strides.y);
          let wCPerm = uniforms.filterDims.y - 1 - wC;
          var bDyCVal = true;
          var bDyCVal2 = true;
          if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
              fract(dyC) > 0.0) {
            bDyCVal = false;
          }
          if (dyC2 < 0.0 || dyC2 >= f32(uniforms.outBackprop[2]) ||
              fract(dyC2) > 0.0) {
            bDyCVal2 = false;
          }

          let idyC = i32(dyC);
          let idyC2 = i32(dyC2);
          if (bDyCVal && bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
              xValue = getDy(batch, idyR, idyC2, d2);
              dotProd[1] = dotProd[1] + vec4<f32>(dot(xValue, wValue0),
                                                  dot(xValue, wValue1),
                                                  dot(xValue, wValue2),
                                                  dot(xValue, wValue3));
            }
          } else if (bDyCVal) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[0] = dotProd[0] + tmpval;
            }
          } else if (bDyCVal2) {
            let d2Length = uniforms.outBackprop[3];
            for (var d2 = 0; d2 < d2Length; d2 = d2 + 4) {
              let wValue0 = getW(wRPerm, wCPerm, d1, d2);
              let wValue1 = getW(wRPerm, wCPerm, d1 + 1, d2);
              let wValue2 = getW(wRPerm, wCPerm, d1 + 2, d2);
              let wValue3 = getW(wRPerm, wCPerm, d1 + 3, d2);
              var xValue =  getDy(batch, idyR, idyC2, d2);
              let tmpval = vec4<f32>(dot(xValue, wValue0),
                                     dot(xValue, wValue1),
                                     dot(xValue, wValue2),
                                     dot(xValue, wValue3));
              dotProd[1] = dotProd[1] + tmpval;
            }
          }
        }
      }

      for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
        let coords = vec4<i32>(batch, r, c + i, d1);
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], dotProd[i]);
        }
      }
    }
    `;return this.isVec4?`
    ${s}
    `:`
    ${j("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[${r}];

        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {
          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.strides.x);
          let wRPerm = uniforms.filterDims.x - 1 - wR;
          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||
              wRPerm < 0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {
            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.strides.y);
            let wCPerm = uniforms.filterDims.y - 1 - wC;
            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||
                fract(dyC) > 0.0 || wCPerm < 0) {
              continue;
            }
            let idyC = i32(dyC);

            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {
              let xValue = ${this.isChannelsLast?"getDy(batch, idyR, idyC, d2)":"getDy(batch, d2, idyR, idyC)"};
              let wValue = getW(wRPerm, wCPerm, d1, d2);
              dotProd = dotProd + xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class AT{constructor(e){this.variableNames=["x","dy"],this.uniforms="pads : vec2<i32>, strides : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",this.shaderKey=`conv2DDerFilter_${this.isChannelsLast}`}getUserCode(){return`
    ${j("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let d2 = coords[3];

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b = b + 1) {
          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];
            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              if (${this.isChannelsLast}) {
                let dyValue = getDy(b, yR, yC, d2);
                let xValue = getX(b, xR, xC, d1);
                dotProd = dotProd + xValue * dyValue;
              } else {
                let dyValue = getDy(b, d2, yR, yC);
                let xValue = getX(b, d1, xR, xC);
                dotProd = dotProd + xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class RT{constructor(e){this.variableNames=["x","dy"],this.uniforms=`pads : vec3<i32>, strides : vec3<i32>, batchSize : i32, outDepth : i32,
       outHeight : i32, outWidth : i32, inDepth : i32, inHeight : i32, inWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerFilter"}getUserCode(){return`
    ${j("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wF = coords.x;
        let wR = coords.y;
        let wC = coords.z;
        let d1 = coords.w;
        let d2 = coords.u;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yF = 0; yF < uniforms.outDepth; yF++) {
            let xF = wF + yF * uniforms.strides[0] - uniforms.pads[0];
            if (xF < 0 || xF >= uniforms.inDepth) {
              continue;
            }

            for (var yR = 0; yR < uniforms.outHeight; yR++) {
              let xR = wR + yR * uniforms.strides[1] - uniforms.pads[1];
              if (xR < 0 || xR >= uniforms.inHeight) {
                continue;
              }

              for (var yC = 0; yC < uniforms.outWidth; yC++) {
                let xC = wC + yC * uniforms.strides[2] - uniforms.pads[2];
                if (xC < 0 || xC >= uniforms.inWidth) {
                  continue;
                }

                let dyValue = getDy(b, yF, yR, yC, d2);
                let xValue = getX(b, xF, xR, xC, d1);
                dotProd += xValue * dyValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}class DT{constructor(e){this.variableNames=["dy","W"],this.uniforms=`filterDims : vec3<i32>, pads : vec3<i32>, strides : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32, outChannels : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3DDerInput"}getUserCode(){return`
    ${j("index")} {
      if(index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let d1 = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyFCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let dyF = f32(dyFCorner + wF) / f32(uniforms.strides[0]);
          if (dyF < 0.0 || dyF >= f32(uniforms.outDepth) || fract(dyF) > 0.0) {
            continue;
          }
          let idyF = i32(dyF);

          let wFPerm = uniforms.filterDims[0] - 1 - wF;

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            let wRPerm = uniforms.filterDims[1] - 1 - wR;

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let wCPerm = uniforms.filterDims[2] - 1 - wC;

              for (var d2 = 0; d2 < uniforms.outChannels; d2++) {
                let xValue = getDy(batch, idyF, idyR, idyC, d2);
                let wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PT(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:o}=e,{strides:i,pad:a,dataFormat:u,dimRoundingMode:l,filterShape:h}=r,c=$r(u),d=Et(s.shape,h,i,1,a,l,!1,c),f=new AT(d),m=[{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]},{type:"int32",data:[d.inHeight]},{type:"int32",data:[d.inWidth]}];return t.runWebGPUProgram(f,[s,o],s.dtype,m)}const OT={kernelName:vc,backendName:"webgpu",kernelFunc:PT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FT(n=4){const e=o=>{switch(o){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return`
            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);
            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);
            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);
            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];
            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];
            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];
            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];
            return vec4<f32>(v0, v1, v2, v3);
            `;default:throw new Error(`innerElementSize ${o} is not supported.`)}},r=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {
        ${`
      let outRow = row / uniforms.outShape[2];
      let outCol = row % uniforms.outShape[2];

      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];
      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.strides[0]);
      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.strides[1]);
      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {
        return ${de(n)}(0.0);
      }
      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {
        return ${de(n)}(0.0);
      }
      let coord = vec4<i32>(
          batch,
          i32(xR),
          i32(xC),
          col % uniforms.outBackprop[3]);
      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${n}];`}
      }
      return ${de(n)}(0.0);`;return`
  fn mm_readA(batch: i32, row : i32, col : i32) -> ${de(n)} {
    ${r}
  }

  fn mm_readB(batch: i32, row : i32, col : i32) -> ${de(n)} {
    let coordX = uniforms.filterDims.x - 1 -
        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);
    let coordY = uniforms.filterDims.y - 1 -
        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];
    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&
        coordX >= 0 && coordY >= 0) {
      let rowInner = row % uniforms.outBackprop[3];
      let coord = vec4<i32>(coordX, coordY, col, rowInner);
      ${e(n)}
    }
    return ${de(n)}(0.0);
  }

  fn mm_write(batch: i32, row : i32, col : i32, valueInput : ${de(n)}) {
    if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {
      var value = valueInput;
      let outCoord = vec4<i32>(
          batch,
          row / uniforms.outShape[2],
          row % uniforms.outShape[2],
          col);
      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${n}] = value;
    }
  }`}class zT{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, strides : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,I(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),this.isVec4=e.inChannels%4===0&&e.outChannels%4===0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=of(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=af(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.outputComponent=4,this.variableComponents=[4,1]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?vo(this.elementsPerThread,this.workgroupSize):So(this.elementsPerThread,this.workgroupSize);return`
    ${FT(this.isVec4?4:1)}
    ${e}
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LT(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:o}=e,{inputShape:i,strides:a,pad:u,dataFormat:l,dimRoundingMode:h}=r,c=$r(l),d=Et(i,o.shape,a,1,u,h,!1,c),f=[{type:"int32",data:[d.filterHeight,d.filterWidth]},{type:"int32",data:[d.filterHeight-1-d.padInfo.top,d.filterWidth-1-d.padInfo.left]},{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.batchSize,d.outHeight,d.outWidth,d.outChannels]}];let m;if(oe().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||d.dataFormat!=="channelsLast")m=new _T(d);else{m=new zT(d);const x=d.inHeight*d.inWidth,b=d.inChannels,v=d.filterHeight*d.filterWidth*d.outChannels;f.push({type:"uint32",data:[x]},{type:"uint32",data:[b]},{type:"uint32",data:[v]})}return t.runWebGPUProgram(m,[s,o],"float32",f)}const BT={kernelName:Sc,backendName:"webgpu",kernelFunc:LT};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MT{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims: vec3<i32>, pads: vec3<i32>, strides: vec3<i32>, dilations: vec3<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="conv3dnaive"}getUserCode(){return`
    ${j("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords.x;
        let d2 = coords.u;

        let xFRCCorner = vec3<i32>(coords.y, coords.z, coords.w) * uniforms.strides - uniforms.pads;
        let xFCorner = xFRCCorner.x;
        let xRCorner = xFRCCorner.y;
        let xCCorner = xFRCCorner.z;

        let inputDepthNearestVec4 = (uniforms.xShape.u / 4) * 4;
        let inputDepthVec4Remainder = uniforms.xShape.u % 4;

        var dotProd = 0.0;
        for (var wF = 0; wF < uniforms.filterDims[0]; wF++) {
          let xF = xFCorner + wF * uniforms.dilations[0];
          if (xF < 0 || xF >= uniforms.xShape.y) {
            continue;
          }

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let xR = xRCorner + wR * uniforms.dilations[1];
            if (xR < 0 || xR >= uniforms.xShape.z) {
              continue;
            }

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let xC = xCCorner + wC * uniforms.dilations[2];
              if (xC < 0 || xC >= uniforms.xShape.w) {
                continue;
              }

              for (var d1 = 0; d1 < inputDepthNearestVec4; d1 += 4) {
                let xValues = vec4<f32>(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                let wValues = vec4<f32>(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (inputDepthVec4Remainder == 1) {
                dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4) *
                  getW(wF, wR, wC, inputDepthNearestVec4, d2);
              } else if (inputDepthVec4Remainder == 2) {
                let xValues = vec2<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1)
                );
                let wValues = vec2<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (inputDepthVec4Remainder == 3) {
                let xValues = vec3<f32>(
                  getX(batch, xF, xR, xC, inputDepthNearestVec4),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                  getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2)
                );
                let wValues = vec3<f32>(
                  getW(wF, wR, wC, inputDepthNearestVec4, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
                  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }`}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VT(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:i,pad:a,dilations:u}=r,l=co(s.shape,o.shape,i,u,a),h=[l.padInfo.front,l.padInfo.top,l.padInfo.left],c=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[...h]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationDepth,l.dilationHeight,l.dilationWidth]}],d=new MT(l),f=xn(s.dtype,o.dtype);return t.runWebGPUProgram(d,[s,o],f,c)}const WT={kernelName:Cc,backendName:"webgpu",kernelFunc:VT};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UT(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:o}=e,{strides:i,pad:a,filterShape:u}=r,l=co(s.shape,u,i,1,a),h=new RT(l),c=[{type:"int32",data:[l.padInfo.front,l.padInfo.top,l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.batchSize]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.inDepth]},{type:"int32",data:[l.inHeight]},{type:"int32",data:[l.inWidth]}];return t.runWebGPUProgram(h,[s,o],o.dtype,c)}const GT={kernelName:Zm,backendName:"webgpu",kernelFunc:UT};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HT(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:o}=e,{strides:i,pad:a,inputShape:u}=r,l=co(u,o.shape,i,1,a),h=new DT(l),c=[{type:"int32",data:[l.filterDepth,l.filterHeight,l.filterWidth]},{type:"int32",data:[l.filterDepth-1-l.padInfo.front,l.filterHeight-1-l.padInfo.top,l.filterWidth-1-l.padInfo.left]},{type:"int32",data:[l.strideDepth,l.strideHeight,l.strideWidth]},{type:"int32",data:[l.outDepth]},{type:"int32",data:[l.outHeight]},{type:"int32",data:[l.outWidth]},{type:"int32",data:[l.outChannels]}];return t.runWebGPUProgram(h,[s,o],s.dtype,c)}const jT={kernelName:Ic,backendName:"webgpu",kernelFunc:HT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qT=xe({opType:G.COS}),KT={kernelName:kc,backendName:"webgpu",kernelFunc:qT};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XT=xe({opType:G.COSH}),YT={kernelName:Nc,backendName:"webgpu",kernelFunc:XT};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QT{constructor(e,t,r,s){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[o]=t;this.outputShape=[o,r[0],r[1],e],this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId=s==="bilinear"?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[r,s,o]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${e}`],[i,a,u]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${t}`];return`
    ${j("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let height_ratio = f32(${r});
        let width_ratio = f32(${i});
        let b = coords[0];
        let y = coords[1];
        let x = coords[2];
        let d = coords[3];
        // get box vals
        let y1 = getBoxes(b, 0);
        let x1 = getBoxes(b, 1);
        let y2 = getBoxes(b, 2);
        let x2 = getBoxes(b, 3);
        // get image in batch index
        let bInd = i32(round(getBoxInd(b)));
        if(bInd < 0 || bInd >= uniforms.outShape[0]) {
          return;
        }
        let height_scale = ${s};
        let width_scale = ${a};
        let in_y = ${o};
        if( in_y < 0.0 || in_y > ${e} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let in_x = ${u};
        if( in_x < 0.0 || in_x > ${t} ) {
          setOutputAtIndex(index, uniforms.extrapolationValue);
          return;
        }
        let sourceFracIndexCR = vec2<f32>(in_x,in_y);
        if(${this.methodId} == 1) {
          // Compute the four integer indices.
          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);
          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));
          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);
          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);
          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);
          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);
          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);
          let top = topLeft + (topRight - topLeft) * fracCR.x;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          let newValue = top + (bottom - top) * fracCR.y;
          setOutputAtIndex(index, newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          let sourceNearestCR = vec2<i32>(floor(
            sourceFracIndexCR + vec2<f32>(0.5,0.5)));
          let newValue = getImage(
            bInd, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutputAtIndex(index, newValue);
        }
      }
    }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZT=n=>{const{inputs:e,backend:t,attrs:r}=n,{image:s,boxes:o,boxInd:i}=e,{cropSize:a,method:u,extrapolationValue:l}=r,h=new QT(s.shape[3],o.shape,a,u),c=[{type:"float32",data:[l]}];return t.runWebGPUProgram(h,[s,o,i],"float32",c)},JT={kernelName:Ec,backendName:"webgpu",kernelFunc:ZT};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var is;(function(n){n.Prod="*",n.Sum="+"})(is||(is={}));class vl{constructor(e,t,r,s){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=r,this.reverse=s,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===is.Prod?"1.0":"0.0",r=this.exclusive?t:`getX(${Sl(e,"coords",this.op)})`,s=this.outputShape[this.outputShape.length-1];let o="",i="";return this.exclusive?(o=this.reverse?`end != ${s-1}`:"end != 0",i=this.reverse?"end + 1":"end - 1"):(o=this.reverse?`end + pow2 < ${s}`:"end >= pow2",i=this.reverse?"end + pow2":"end - pow2"),`
      ${j("index")} {
       if (index < uniforms.size) {
         var coords = getCoordsFromIndex(index);

         let end = ${Cl(e,"coords",this.op)};
         var val = ${r};
         let pow2 = i32(pow(2.0, uniforms.index));
         if (${o}) {
           let idx = ${i};
           ${Cl(e,"coords",this.op)} = idx;
           val ${this.op}= getX(${Sl(e,"coords",this.op)});
         }
         setOutputAtIndex(index, val);
       }
      }
    `}}function Sl(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function Cl(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sf(n,e,t,r,s,o){const i=e.shape.length,a=ds([r],i);let u=e;a!=null&&(u=Qt({inputs:{x:e},backend:t,attrs:{perm:a}}));const l=ps(1,i)[0];if(l!==i-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const h=u.shape[l];let c=ft({inputs:{x:u},backend:t});for(let d=0;d<=Math.ceil(Math.log2(h))-1;d++){const f=new vl(n,u.shape,!1,o),m=c,x=[{type:"float32",data:[d]}];c=t.runWebGPUProgram(f,[c],c.dtype,x),t.disposeData(m.dataId)}if(s){const d=new vl(n,u.shape,s,o),f=c,m=[{type:"float32",data:[0]}];c=t.runWebGPUProgram(d,[c],c.dtype,m),t.disposeData(f.dataId)}if(a!=null){const d=gp(a),f=Qt({inputs:{x:c},backend:t,attrs:{perm:d}});return t.disposeData(c.dataId),t.disposeData(u.dataId),f}return c}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,exclusive:i,reverse:a}=r;return Sf(is.Prod,s,t,o,i,a)}const tE={kernelName:$c,backendName:"webgpu",kernelFunc:eE};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,exclusive:i,reverse:a}=r;return Sf(is.Sum,s,t,o,i,a)}const rE={kernelName:Tc,backendName:"webgpu",kernelFunc:nE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,weights:o}=e,{size:i,binaryOutput:a}=r,u=s.shape.length===1,h=H(o.shape)>0,c=o.dtype,d=u?[s.shape[0]]:[s.shape[0],s.shape[1]],f=u?[i]:[s.shape[0],i],m=st({backend:t,attrs:{shape:f,value:0,dtype:c}}),x=new bf(d,h,a),b=[{type:"int32",data:[i]}],v=h?[s,o]:[s];return t.runWebGPUProgram(x,v,c,b,m)}const oE={kernelName:_c,backendName:"webgpu",kernelFunc:sE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iE{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`depthToSpace_${t}`,this.dataFormat=t}getUserCode(){return`
      ${j("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let h = ${this.getHeightCoordString()};
          let w = ${this.getWidthCoordString()};
          let d = ${this.getDepthCoordString()};

          let in_h = h / uniforms.blockSize;
          let offset_h = h % uniforms.blockSize;
          let in_w = w / uniforms.blockSize;
          let offset_w = w % uniforms.blockSize;
          let offset_d = (offset_h * uniforms.blockSize + offset_w) *
            ${this.getOutputDepthSize()};
          let in_d = d + offset_d;

          let rlt = ${this.getInputSamplingString()};
          setOutputAtIndex(index, rlt);
        }
      }`}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockSize:o,dataFormat:i}=r,a=s.shape[0],u=i==="NHWC"?s.shape[1]:s.shape[2],l=i==="NHWC"?s.shape[2]:s.shape[3],h=i==="NHWC"?s.shape[3]:s.shape[1],c=u*o,d=l*o,f=h/(o*o),m=i==="NHWC"?[a,c,d,f]:[a,f,c,d],x=[{type:"int32",data:[o]}],b=new iE(m,i);return t.runWebGPUProgram(b,[s],s.dtype,x)}const uE={kernelName:Ac,backendName:"webgpu",kernelFunc:aE};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lE{constructor(e,t,r,s=!1,o=null,i=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.addBias=s,this.activation=o,this.hasPreluActivation=i,this.filterHeight=t,this.filterWidth=r,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],r=this.workgroupSize[1]+this.filterHeight-1,s=this.workgroupSize[0]+this.filterWidth-1;return`
      ${dn(this.activation,this.hasPreluActivation,!1,4)}

      var<workgroup> mm_Asub : array<array<f32, ${s}>, ${r}>;
      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;
      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {
        var value = 0.0;
        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])
        {
          value = getX(batch, channel, row, col);
        }
        return value;
      }

      ${j()} {
        let coords = getOutputCoords();
        let batch = coords[0];
        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pads;
        let channelMul = uniforms.wShape[3];
        let d1 = coords[1] / channelMul;
        let q = coords[1] % channelMul;

        let inputRowStart = xRCCorner.x;
        let inputColStart = xRCCorner.y;

        let localRow = i32(localId.y);
        let localCol = i32(localId.x);

        // Load one tile of X into local memory.
        for (var inputRow = localRow; inputRow < ${r}; inputRow = inputRow + ${this.workgroupSize[1]}) {
          for (var inputCol = localCol; inputCol < ${s}; inputCol = inputCol + ${this.workgroupSize[0]}) {
            let rowOffset = inputRow - localRow;
            let colOffset = inputCol - localCol;
            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);
          }
        }

        // Load one tile of W into local memory.
        var wIndex = i32(localIndex);
        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}

        {
          let wRow = wIndex / ${this.filterWidth};
          let wCol = wIndex % ${this.filterWidth};
          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);
        }

        workgroupBarrier();

        var value = 0.0;
        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {
          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {
            let xVal = mm_Asub[localRow + wR][localCol + wC];
            let wVal = mm_Bsub[wR][wC];
            value = fma(xVal, wVal, value);
          }
        }
        ${rr(this.addBias,this.activation)}
        if (coordsInBounds4D(coords, uniforms.outShape)) {
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cf{constructor(e,t=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms="pads : vec2<i32>, inDims : vec2<i32>, virtualWidth : i32,",this.workgroupSize=[64,1,1],this.workPerThread=4,this.outputComponent=4,this.outputShape=e.outShape,this.virtualWidth=Math.ceil(this.outputShape[2]/this.workPerThread)*this.workPerThread;const o=[this.outputShape[0],this.outputShape[1],this.virtualWidth,this.outputShape[3]];this.dispatchLayout=Q(o),this.dispatch=K(this.dispatchLayout,o,this.workgroupSize,[this.outputComponent*this.workPerThread,1,1]),I(e.dataFormat==="channelsLast",()=>"TODO: NCHW is unimplemented"),t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=r,this.hasPreluActivation=s,this.shaderKey=`depthwiseVec4_${r}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,r=this.convInfo.strideWidth;return`
      ${dn(this.activation,this.hasPreluActivation,!0,4)}
      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {
        var value = vec4<f32>(0.0);
        if (col >=0 && col < uniforms.inDims[1]) {
          value = getX(batch, row, col, channel);
        }
        return value;
      }

      ${j("index")} {
        let width0 = uniforms.outShape[3] / ${this.outputComponent};
        let d1 = (index % width0) * ${this.outputComponent};
        var index1 = index / width0;
        let width1 = uniforms.virtualWidth / ${this.workPerThread};
        let c = (index1 % width1) * ${this.workPerThread};
        index1 = index1 / width1;
        let r = index1 % uniforms.outShape[1];
        let batch = index1 / uniforms.outShape[1];

        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${r}) - uniforms.pads;

        let xRCorner = xRCCorner.x;
        let xCCorner = xRCCorner.y;
        var xVals : array<vec4<f32>, ${e}>;
        var dotProd : array<vec4<f32>, ${this.workPerThread}>;
        for (var i = 0; i < ${this.workPerThread}; i++) {
          dotProd[i] = vec4<f32>(0.0);
        }

        // Use constant instead of uniform can give better performance.
        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {
          let xR = xRCorner + wR;
          if (xR >=0 && xR < uniforms.inDims[0]) {
            for (var i = 0; i < ${e}; i++) {
              xVals[i] = readX(batch, xR, xCCorner + i, d1);
            }
            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {
              let wValue = getW(wR, wC, d1, 0);
              for (var i = 0; i < ${this.workPerThread}; i++) {
                dotProd[i] = fma(xVals[i * ${r} + wC], wValue, dotProd[i]);
              }
            }
          }
        }

        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {
          let coords = vec4<i32>(batch, r, c + i, d1);
          if (coordsInBounds4D(coords, uniforms.outShape)) {
            var value = dotProd[i];
            ${rr(this.addBias,this.activation)}
            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class If{constructor(e,t=!1,r=null,s=!1){this.variableNames=["x","W"],this.uniforms=`pads : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,
      filterWidth : i32, strides : vec2<i32>, dilations : vec2<i32>,`,this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=e.dataFormat==="channelsLast",t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=r,this.hasPreluActivation=s,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`
      ${dn(this.activation,this.hasPreluActivation,!1,4)}

      ${j("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let batch = coords[0];
          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.strides - uniforms.pads;
          let d2 = coords[${this.isChannelsLast?3:1}];
          let channelMul = uniforms.wShape[3];
          let d1 = d2 / channelMul;
          let q = d2 % channelMul;

          let inputRowStart = xRCCorner.x;
          let inputColStart = xRCCorner.y;
          let inputRowEnd = inputRowStart + uniforms.filterHeight *
              uniforms.dilations[0];
          let inputColEnd = inputColStart + uniforms.filterWidth *
              uniforms.dilations[1];

          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get
          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all
          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.
          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.
          var value = 0.0;

          // Extract if checking out of for loop for performance.
          if (inputRowStart >= 0 && inputColStart >= 0 &&
            inputRowEnd < uniforms.inDims[0] &&
                inputColEnd < uniforms.inDims[1]) {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            } else {
              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {
                let xR = inputRowStart + wR * uniforms.dilations[0];

                if (xR < 0 || xR >= uniforms.inDims[0]) {
                  continue;
                }

                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {
                  let xC = inputColStart + wC * uniforms.dilations[1];

                  if (xC < 0 || xC >= uniforms.inDims[1]) {
                    continue;
                  }

                  let xVal = ${e};
                  let wVal = getW(wR, wC, d1, q);
                  value = value + xVal * wVal;
                }
              }
            }
            ${rr(this.addBias,this.activation)}
          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:i,pad:a,dataFormat:u,dilations:l,dimRoundingMode:h}=r,c=$r(u);let d=l;d==null&&(d=[1,1]);const f=Et(s.shape,o.shape,i,d,a,h,!0,c),m=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.inHeight,f.inWidth]}],x=f.dataFormat==="channelsLast";let b;return!x&&f.inHeight>16&&f.inWidth>16&&f.strideHeight===1&&f.strideWidth===1&&f.dilationWidth===1&&f.dilationHeight===1&&f.inChannels===f.outChannels?b=new lE(f.outShape,f.filterHeight,f.filterWidth):x&&f.outHeight>4&&f.outWidth>4&&f.strideWidth<=2&&f.inChannels===f.outChannels&&f.dilationHeight===1&&f.dilationWidth===1&&f.inChannels%4===0?(b=new Cf(f),m.push({type:"int32",data:[b.virtualWidth]})):(b=new If(f),m.push({type:"int32",data:[f.filterHeight]},{type:"int32",data:[f.filterWidth]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.dilationHeight,f.dilationWidth]})),t.runWebGPUProgram(b,[s,o],s.dtype,m)}const hE={kernelName:Rc,backendName:"webgpu",kernelFunc:cE};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dE{constructor(e){this.variableNames=["x","dy"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>, outHeight : i32,
      outWidth : i32, inHeight : i32, inWidth : i32, batchSize : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_filter"}getUserCode(){return`
      ${j("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let wR = coords[0];
        let wC = coords[1];
        let d1 = coords[2];
        let dm = coords[3];
        let d2 = d1 * uniforms.channelMul + dm;

        var dotProd = 0.0;
        for (var b = 0; b < uniforms.batchSize; b++) {
          for (var yR = 0; yR < uniforms.outHeight; yR++) {
            let xR = wR + yR * uniforms.strides[0] - uniforms.pads[0];

            if (xR < 0 || xR >= uniforms.inHeight) {
              continue;
            }

            for (var yC = 0; yC < uniforms.outWidth; yC++) {
              let xC = wC + yC * uniforms.strides[1] - uniforms.pads[1];

              if (xC < 0 || xC >= uniforms.inWidth) {
                continue;
              }

              let dyValue = getDy(b, yR, yC, d2);
              let xValue = getX(b, xR, xC, d1);
              dotProd += xValue * dyValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class pE{constructor(e){this.variableNames=["dy","W"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32, channelMul : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthwise_conv2d_backprop_input"}getUserCode(){return`
      ${j("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d1 = coords[3];
        let dyCorner = coords.yz - uniforms.pads;
        let dyRCorner = dyCorner.x;
        let dyCCorner = dyCorner.y;

        var dotProd = 0.0;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }

          let idyR = i32(dyR);
          let wRPerm = uniforms.filterDims[0] - 1 - wR;

          for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }

            let idyC = i32(dyC);
            let wCPerm = uniforms.filterDims[1] - 1 - wC;

            for (var dm = 0; dm < uniforms.channelMul; dm++) {
              let d2 = d1 * uniforms.channelMul + dm;
              let xValue = getDy(batch, idyR, idyC, d2);
              let wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,dy:o}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:l,filterShape:h}=r,c=Et(s.shape,h,i,a,u,l,!0),d=new dE(c),f=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.inHeight]},{type:"int32",data:[c.inWidth]},{type:"int32",data:[c.batchSize]},{type:"int32",data:[c.outChannels/c.inChannels]}];return t.runWebGPUProgram(d,[s,o],"float32",f)}const mE={kernelName:Dc,backendName:"webgpu",kernelFunc:fE};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gE(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,filter:o}=e,{strides:i,dilations:a,pad:u,dimRoundingMode:l,inputShape:h}=r,c=Et(h,o.shape,i,a,u,l,!0),d=new pE(c),f=[{type:"int32",data:[c.strideHeight,c.strideWidth]},{type:"int32",data:[c.filterHeight-1-c.padInfo.top,c.filterWidth-1-c.padInfo.left]},{type:"int32",data:[c.filterHeight,c.filterWidth]},{type:"int32",data:[c.outHeight]},{type:"int32",data:[c.outWidth]},{type:"int32",data:[c.outChannels/c.inChannels]}];return t.runWebGPUProgram(d,[s,o],s.dtype,f)}const yE={kernelName:Pc,backendName:"webgpu",kernelFunc:gE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bE{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`
      ${j("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);
          setOutputAtIndex(index, value);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wE(n){const{inputs:e,backend:t}=n,{x:r}=e,s=[...r.shape,...r.shape],o=H(r.shape),i=te({inputs:{x:r},backend:t,attrs:{shape:[o]}}),a=new bE(o),u=t.runWebGPUProgram(a,[i],i.dtype),l=te({inputs:{x:u},backend:t,attrs:{shape:s}});return t.disposeData(i.dataId),t.disposeData(u.dataId),l}const xE={kernelName:Oc,backendName:"webgpu",kernelFunc:wE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vE{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`
       ${j("index")} {
         if (index < uniforms.size) {
           let neg_infinity = -3.4e38;
           let coords = getOutputCoords();
           let batch = coords.x;
           let d1 = coords.w;
           let outTopLeftCorner = coords.yz * uniforms.strides - uniforms.pads;
           let hBeg = outTopLeftCorner.x;
           let wBeg = outTopLeftCorner.y;

           var curVal = neg_infinity;
           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {
             let hIn = hBeg + h * uniforms.dilations[0];

             if (hIn >= 0 && hIn < uniforms.xShape[1]) {
               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {
                 let wIn = wBeg + w * uniforms.dilations[1];

                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {
                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);
                   if (val > curVal) {
                     curVal = val;
                   }
                 }
               }
             }
           }

           setOutputAtIndex(index, curVal);
         }
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o}=e,{strides:i,pad:a,dilations:u}=r,l=na(s.shape,o.shape,i,a,"NHWC",u),h=[l.padInfo.top,l.padInfo.left],c=[{type:"int32",data:[l.filterHeight,l.filterWidth]},{type:"int32",data:[...h]},{type:"int32",data:[l.strideHeight,l.strideWidth]},{type:"int32",data:[l.dilationHeight,l.dilationWidth]}],d=new vE(l);return t.runWebGPUProgram(d,[s,o],s.dtype,c)}const CE={kernelName:Fc,backendName:"webgpu",kernelFunc:SE};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class IE{constructor(e,t){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.inShape,this.dispatchLayout=Q(e.outShape),this.dispatch=K(this.dispatchLayout,e.outShape,this.workgroupSize),t!=="float32"&&t!=="int32")throw new Error(`Dilation2DBackpropInput only supports float32 and int32
          types, does not support ${t} type.`);this.type=t,this.shaderKey="dilation2DBackpropInput"}getUserCode(){return`
       ${j("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var xRMax = 0;
           var xCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     xRMax = xR;
                     xCMax = xC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.xShape[3] *
               (xCMax + uniforms.xShape[2] * (xRMax + uniforms.xShape[1] * b));
           let value = getDy(b, r, c, d);
           ${kn("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}class kE{constructor(e,t,r){if(this.variableNames=["x","w","dy"],this.uniforms="filterDims: vec2<i32>, pads: vec2<i32>, strides: vec2<i32>, dilations: vec2<i32>, dySize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e.filterShape,this.dispatchLayout=Q(e.outShape),this.dispatch=K(this.dispatchLayout,e.outShape,this.workgroupSize),r!=="float32"&&r!=="int32")throw new Error(`Dilation2DBackpropFilter only supports float32 and int32
          types, does not support ${r} type.`);this.type=r,this.shaderKey="dilation2DBackpropFilter"}getUserCode(){return`
       ${j("index")} {
         if (index < uniforms.dySize) {
           let coords = getDyCoordsFromIndex(index);
           let b = coords[0];
           let r = coords[1];
           let c = coords[2];
           let d = coords[3];

           let dyCorner = vec2<i32>(r, c) * uniforms.strides - uniforms.pads;
           var curVal = -3.4e38;  // neg_infinity
           var wRMax = 0;
           var wCMax = 0;

           // In the case of multiple argmax branches, we only back-propagate
           // along the last branch, i.e., the one with largest value of
           // 'wR * uniforms.filterDims[1] + wC', similarly to the max-pooling
           // backward routines.
           for (var wR = 0; wR < uniforms.filterDims[0]; wR++) {
             let xR = dyCorner.x + wR * uniforms.dilations[0];

             if (xR >= 0 && xR < uniforms.xShape[1]) {
               for (var wC = 0; wC < uniforms.filterDims[1]; wC++) {
                 let xC = dyCorner.y + wC * uniforms.dilations[1];

                 if (xC >= 0 && xC < uniforms.xShape[2]) {
                   let val = getX(b, xR, xC, d) + getW(wR, wC, d);
                   if (val > curVal) {
                     curVal = val;
                     wRMax = wR;
                     wCMax = wC;
                   }
                 }
               }
             }
           }

           let flatIndexIn = d + uniforms.wShape[2] * (wCMax + wRMax * uniforms.wShape[1]);
           let value = getDy(b, r, c, d);
           ${kn("&result[flatIndexIn]","value",this.type)}
         }
       }
     `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o,dy:i}=e,{strides:a,pad:u,dilations:l}=r,h=na(s.shape,o.shape,a,u,"NHWC",l),c=o.dtype,d=new kE(h,o.shape,c),f=[{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[H(h.outShape)]}],m=st({backend:t,attrs:{shape:o.shape,value:0,dtype:c}});return t.runWebGPUProgram(d,[s,o,i],c,f,m)}const $E={kernelName:eg,backendName:"webgpu",kernelFunc:NE};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TE(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o,dy:i}=e,{strides:a,pad:u,dilations:l}=r,h=na(s.shape,o.shape,a,u,"NHWC",l),c=s.dtype,d=new IE(h,c),f=[{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[H(h.outShape)]}],m=st({backend:t,attrs:{shape:h.inShape,value:0,dtype:c}});return t.runWebGPUProgram(d,[s,o,i],c,f,m)}const EE={kernelName:Jm,backendName:"webgpu",kernelFunc:TE};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _E{constructor(e,t,r){this.variableNames=["Image"],this.uniforms="alpha: f32,",this.workgroupSize=[64,1,1],this.pixelsOpType=Ir.DRAW,this.size=!0,this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.type=t,this.textureFormat=r,this.shaderKey=`draw_${t}_${r}`}getUserCode(){let e;const t=this.type==="float32"?"value":"value / 255.0";return e=`
      if (uniforms.numChannels == 1) {
        rgba[0] = ${t};
        rgba[1] = ${t};
        rgba[2] = ${t};
      } else {
        rgba[d] = ${t};
      }`,`
       @group(0) @binding(0) var outImage : texture_storage_2d<${this.textureFormat}, write>;
       ${j("index")} {
         if (index < uniforms.size) {
           var rgba = vec4<f32>(0.0, 0.0, 0.0, uniforms.alpha);
           for (var d = 0; d < uniforms.numChannels; d = d + 1) {
             let value = f32(inBuf[index * uniforms.numChannels + d]);
             ${e}
           }
           rgba.x = rgba.x * rgba.w;
           rgba.y = rgba.y * rgba.w;
           rgba.z = rgba.z * rgba.w;
           let coords = getCoordsFromIndex(index);
           textureStore(outImage, vec2<i32>(coords.yx), rgba);
         }
       }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AE(n){const{inputs:e,backend:t,attrs:r}=n,{image:s}=e,{canvas:o,options:i}=r,[a,u]=s.shape.slice(0,2),{imageOptions:l}=i||{},h=(l==null?void 0:l.alpha)||1,c=t.device.features.has("bgra8unorm-storage")?"bgra8unorm":"rgba8unorm",d=[a,u],f=new _E(d,s.dtype,c);o.width=u,o.height=a;const m="webgpu";let x=o.getContext(m),b;x||(b=new OffscreenCanvas(u,a),x=b.getContext(m));const v=s.shape.length===3?s.shape[2]:1;x.configure({device:t.device,format:c,usage:GPUTextureUsage.STORAGE_BINDING,alphaMode:"premultiplied"});const k="int32",$=t.makeTensorInfo(d,k),N=t.tensorMap.get($.dataId);N.resource=x.getCurrentTexture(),N.external=!0;const R=[{type:"uint32",data:[v]},{type:"float32",data:[h]}];if(t.runWebGPUProgram(f,[s],k,R,$),b){const O=o.getContext("2d");if(!O)throw new Error("Please make sure this canvas has only been used for 2d or webgpu context!");O.drawImage(b,0,0)}return t.disposeData($.dataId),s}const RE={kernelName:tg,backendName:"webgpu",kernelFunc:AE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kf=Ue({opType:ae.MUL,cpuKernelImpl:zN,supportsComplex:!0}),DE={kernelName:$h,backendName:"webgpu",kernelFunc:kf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nf(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:i}=r;return or(s,o,i,"sum",t)}const PE={kernelName:ud,backendName:"webgpu",kernelFunc:Nf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OE(n){const{inputs:e,backend:t,attrs:r}=n,{equation:s}=r,o=e,{allDims:i,summedDims:a,idDims:u}=WC(s,o.length);GC(i.length,u,o);const{path:l,steps:h}=HC(a,u),c=h.length;let d=null,f=i.length;const m=[];for(let x=0;x<c;++x){for(const b of h[x]){const{permutationIndices:v,expandDims:k}=UC(f,u[b]);let $;jC(v)?$=o[b]:($=Qt({inputs:{x:o[b]},backend:t,attrs:{perm:v}}),m.push($));const N=$.shape.slice();for(let R=0;R<k.length;++R)N.splice(k[R],0,1);ot($.shape,N)||($=te({inputs:{x:$},backend:t,attrs:{shape:N}}),m.push($)),d===null?d=$:(d=kf({inputs:{a:$,b:d},backend:t}),m.push(d))}x<c-1&&(l[x]>=0&&(d=Nf({inputs:{x:d},backend:t,attrs:{axis:l[x]-(i.length-f),keepDims:!1}}),m.push(d)),f--)}for(const x of m)x!==d&&t.disposeData(x.dataId);return d}const FE={kernelName:Lc,backendName:"webgpu",kernelFunc:OE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zE=xe({opType:G.ELU}),LE={kernelName:Bc,backendName:"webgpu",kernelFunc:zE};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BE=n=>{const{inputs:e,backend:t}=n,{dy:r,y:s}=e,o=new Qs(ae.ELU_DER,r.shape,s.shape);return t.runWebGPUProgram(o,[r,s],r.dtype)},ME={kernelName:ng,backendName:"webgpu",kernelFunc:BE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VE=Ue({opType:ae.EQUAL,dtype:"bool",cpuKernelImpl:SN}),WE={kernelName:Vc,backendName:"webgpu",kernelFunc:VE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UE=xe({opType:G.ERF}),GE={kernelName:Mc,backendName:"webgpu",kernelFunc:UE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HE=xe({opType:G.EXP,cpuKernelImpl:CN,dtype:"float32"}),jE={kernelName:Wc,backendName:"webgpu",kernelFunc:HE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oi(n){const{inputs:e,attrs:t,backend:r}=n,{dim:s}=t,{input:o}=e,i=o.shape.length,a=o.shape.slice();let u=s;return s<0&&(I(-(i+1)<=s,()=>`Axis must be in the interval [${-(i+1)}, ${i}]`),u=i+s+1),a.splice(u,0,1),te({inputs:{x:o},backend:r,attrs:{shape:a}})}const qE={kernelName:Uc,backendName:"webgpu",kernelFunc:Oi};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KE=xe({opType:G.EXPM1,cpuKernelImpl:IN}),XE={kernelName:Gc,backendName:"webgpu",kernelFunc:KE};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Il{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey=`fft_${e}`}getUserCode(){return`
    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {
      ${this.component==="real"?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}
    }

    fn mulMatDFT(batch: i32, index: i32) -> f32 {
      let indexRatio = f32(index) / f32(uniforms.realShape[1]);
      let exponentMultiplierTimesIndexRatio =
          uniforms.exponentMultiplier * indexRatio;

      var result = 0.0;

      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {
        // x = (-2|2 * PI / N) * index * i;
        let x = exponentMultiplierTimesIndexRatio * f32(i);
        let expR = cos(x);
        let expI = sin(x);
        let real = getReal(batch, i);
        let imag = getImag(batch, i);

        result = result +
            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;
      }

      return result;
    }

    ${j("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));
      }
    }
  `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $f(n,e,t){const r=t.tensorMap.get(n.dataId),s=H(n.shape),o=n.shape[n.shape.length-1],i=s/o,a=[],u=te({inputs:{x:n},backend:t,attrs:{shape:[i,o]}});a.push(u);const l=u.shape,h=new Il("real",l),c=new Il("imag",l),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],f=e?2*Math.PI:-2*Math.PI,m=e?l[1]:1,x=[{type:"float32",data:[f]},{type:"float32",data:[m]}],b=t.runWebGPUProgram(h,d,"float32",x);a.push(b);const v=t.runWebGPUProgram(c,d,"float32",x);a.push(v);const k=sr({inputs:{real:b,imag:v},backend:t});a.push(k);const $=te({inputs:{x:k},backend:t,attrs:{shape:n.shape}});return a.forEach(N=>t.disposeData(N.dataId)),$}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YE(n){const{inputs:e,backend:t}=n,{input:r}=e;return $f(r,!1,t)}const QE={kernelName:Hc,backendName:"webgpu",kernelFunc:YE};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZE{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`
      ${j("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let coordX = uniforms.xShape[2] - coords[2] - 1;
          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);
          setOutputAtIndex(index, outputValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JE={kernelName:qc,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,r=e,s=new ZE(t.shape);return r.runWebGPUProgram(s,[t],t.dtype)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e_=xe({opType:G.FLOOR,cpuKernelImpl:kN}),t_={kernelName:Kc,backendName:"webgpu",kernelFunc:e_};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n_=Ue({opType:ae.FLOOR_DIV,cpuKernelImpl:NN,dtype:"int32"}),r_={kernelName:Xc,backendName:"webgpu",kernelFunc:n_};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class s_{constructor(e,t,r=!1){this.pixelsOpType=Ir.FROM_PIXELS,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=r,this.shaderKey=`fromPixels_${this.importVideo}`}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`
      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};
      ${j("index")} {
        let flatIndex = index * uniforms.numChannels;
        if (flatIndex < uniforms.size) {
          let coords = getCoordsFromIndex(flatIndex);
          let values = ${e};
          for (var i = 0; i < uniforms.numChannels; i = i + 1) {
            result[flatIndex + i] = i32(floor(255.0 * values[i]));
          }
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use backend file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o_={kernelName:hi,backendName:"webgpu",kernelFunc:i_};let lr,ei=oe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function i_(n){const{inputs:e,backend:t,attrs:r}=n;let{pixels:s}=e;const{numChannels:o}=r;if(s==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const i=typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement,u=typeof HTMLCanvasElement<"u"&&s instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&s instanceof OffscreenCanvas,l=typeof ImageBitmap<"u"&&s instanceof ImageBitmap,[h,c]=i?[s.videoWidth,s.videoHeight]:[s.width,s.height],d=[c,h,o],f=oe().getBool("WEBGPU_IMPORT_EXTERNAL_TEXTURE")&&i,m=i||a;if(l||u||m){let k;if(f)k=t.device.importExternalTexture({source:s});else{if(m){const J=oe().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(lr==null||J!==ei)&&(ei=J,lr=document.createElement("canvas").getContext("2d",{willReadFrequently:ei})),lr.canvas.width=h,lr.canvas.height=c,lr.drawImage(s,0,0,h,c),s=lr.canvas}const W=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,ee=t.textureManager.acquireTexture(d[1],d[0],"rgba8unorm",W);t.queue.copyExternalImageToTexture({source:s},{texture:ee},[d[1],d[0]]),k=ee}const $=H(d),N=Qe(d),R=new s_(d,o,f),O=[{type:"uint32",data:[$]},{type:"uint32",data:[o]},{type:"uint32",data:[...N]}],F=t.makeTensorInfo([c,h],"int32"),B=t.tensorMap.get(F.dataId);B.resource=k;const L=t.runWebGPUProgram(R,[F],"int32",O);return t.disposeData(F.dataId),L}const x=s.data;let b=x;if(o!=null&&o!==4){b=new Uint8Array(s.width*s.height*o);const k=x.length;let $=0;for(let N=0;N<k;N++)N%4<o&&(b[$++]=x[N])}const v=t.makeTensorInfo(d,"int32",new Int32Array(b));return t.uploadToGPU(v.dataId),v}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class a_{constructor(e,t,r,s,o){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],Ce(e,t),Ce(e,r),this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),s!=null&&(Ce(e,s),this.variableNames.push("offset")),o!=null&&(Ce(e,o),this.variableNames.push("scale")),this.offsetShape=s,this.scaleShape=o,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";this.offsetShape!=null&&(e="getOffsetByOutputIndex(index)");let t="1.0";return this.scaleShape!=null&&(t="getScaleByOutputIndex(index)"),`
      ${j("index")} {
        if (index < uniforms.size)
        {
          let xValue = getXByOutputIndex(index);
          let meanValue = getMeanByOutputIndex(index);
          let varianValue = getVarianceByOutputIndex(index);
          let offsetValue = ${e};
          let scaleValue = ${t};
          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));
          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));
        }
      }
  `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u_={kernelName:Yc,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r,scale:s,offset:o,mean:i,variance:a}=n,{varianceEpsilon:u}=e,l=t,h=[r,i,a];let c=null;o!=null&&(c=o.shape,h.push(o));let d=null;s!=null&&(d=s.shape,h.push(s));const f=new a_(r.shape,i.shape,a.shape,c,d),m=[{type:"float32",data:[u]}];return l.runWebGPUProgram(f,h,r.dtype,m)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l_(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dataFormat:h,dilations:c,dimRoundingMode:d,activation:f,leakyreluAlpha:m}=r,x=$r(h),b=Et(s.shape,o.shape,u,c,l,d,!1,x);return vf({x:s,filter:o,convInfo:b,backend:t,bias:i,preluActivationWeights:a,leakyreluAlpha:m,activation:f})}const c_={kernelName:pi,backendName:"webgpu",kernelFunc:l_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h_(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,filter:o,bias:i,preluActivationWeights:a}=e,{strides:u,pad:l,dilations:h,dimRoundingMode:c,activation:d,leakyreluAlpha:f}=r;let m=h;m==null&&(m=[1,1]),I(Zt(u,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${m}'`);const x=Et(s.shape,o.shape,u,m,l,c,!0),b=[s,o],v=i!=null,k=a!=null;v&&b.push(i),k&&b.push(a);const $=[{type:"int32",data:[x.padInfo.top,x.padInfo.left]},{type:"int32",data:[x.inHeight,x.inWidth]}];let N;return x.outHeight>4&&x.outWidth>4&&x.strideWidth<=2&&x.inChannels===x.outChannels&&x.dilationHeight===1&&x.dilationWidth===1&&x.inChannels%4===0?(N=new Cf(x,v,d,k),$.push({type:"int32",data:[N.virtualWidth]})):(N=new If(x,v,d,k),$.push({type:"int32",data:[x.filterHeight]},{type:"int32",data:[x.filterWidth]},{type:"int32",data:[x.strideHeight,x.strideWidth]},{type:"int32",data:[x.dilationHeight,x.dilationWidth]})),d==="leakyrelu"&&($.push({type:"float32",data:[f]}),N.uniforms+=" alpha : f32,"),t.runWebGPUProgram(N,b,"float32",$)}const d_={kernelName:fi,backendName:"webgpu",kernelFunc:h_};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class p_{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey=`gathernd_${e}`,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${Fe(e)},`}getUserCode(){let e;return this.sliceDim>1?e="uniforms.strides[j]":e="uniforms.strides",`
      ${j("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          var flattenIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexTemp = i32(round(getIndices(coords[0], j)));
            let strideNum = ${e};
            flattenIndex = flattenIndex + indexTemp * strideNum;
          }

          setOutputAtIndex(index, getA(flattenIndex, coords[1]));
        }
      }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f_(n){const{inputs:e,backend:t}=n,{params:r,indices:s}=e,o=s.shape,i=o[o.length-1],a=H(r.shape),[u,l,h,c]=gC(r,s),d=te({inputs:{x:s},backend:t,attrs:{shape:[l,i]}}),f=te({inputs:{x:r},backend:t,attrs:{shape:[H(r.shape)/h,h]}});if(t.shouldExecuteOnCPU([r,s])||r.dtype==="string"){const k=t.readSync(s.dataId),$=t.bufferSync(r),N=$N(k,$,r.dtype,l,i,h,c,r.shape,a);return t.makeTensorInfo(u,r.dtype,N.values)}const m=new p_(i,[l,h]),x=[{type:"int32",data:[i]},{type:"int32",data:c}],b=t.runWebGPUProgram(m,[f,d],f.dtype,x),v=te({inputs:{x:b},backend:t,attrs:{shape:u}});return t.disposeData(d.dataId),t.disposeData(f.dataId),t.disposeData(b.dataId),v}const m_={kernelName:Zc,backendName:"webgpu",kernelFunc:f_};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class g_{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=y_(this.aShape);return`
      ${j("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let indexZ = i32(getIndices(resRC.x, resRC.z));
          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);
          setOutputAtIndex(index, inBounds * getA(${e}));
        }
      }
    `}}function y_(n){const e=["resRC.x","resRC.y","resRC.z","resRC.w"],t=[];for(let r=0;r<n.length;r++)r===2?t.push("indexZ"):t.push(`${e[r]}`);return t.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tf(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,indices:o}=e,{axis:i,batchDims:a}=r,u=Tt(i,s.shape)[0],l=aI(s,o,u,a),h=H(o.shape),c=[],d=te({inputs:{x:s},backend:t,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),f=te({inputs:{x:o},backend:t,attrs:{shape:[l.batchSize,h/l.batchSize]}});c.push(d),c.push(f);const m=[l.batchSize,l.outerSize,h/l.batchSize,l.sliceSize];if(t.shouldExecuteOnCPU([s,o])){const $=t.tensorMap.get(f.dataId).values,N=Ee(f.shape,f.dtype,$),O=t.tensorMap.get(d.dataId).values,F=Ee(d.shape,d.dtype,O),B=TN(F,N,m);return c.forEach(L=>t.disposeData(L.dataId)),t.makeTensorInfo(l.outputShape,B.dtype,B.values)}const x=new g_(d.shape,m),b=t.runWebGPUProgram(x,[d,f],d.dtype);c.push(b);const v=te({inputs:{x:b},backend:t,attrs:{shape:l.outputShape}});return c.forEach(k=>t.disposeData(k.dataId)),v}const b_={kernelName:Qc,backendName:"webgpu",kernelFunc:Tf};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w_=Ue({opType:ae.GREATER,cpuKernelImpl:_N,dtype:"bool"}),x_={kernelName:Jc,backendName:"webgpu",kernelFunc:w_};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v_=Ue({opType:ae.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:EN}),S_={kernelName:eh,backendName:"webgpu",kernelFunc:v_};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C_(n){const{inputs:e,backend:t}=n,{input:r}=e;return $f(r,!0,t)}const I_={kernelName:th,backendName:"webgpu",kernelFunc:C_};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k_=xe({opType:G.IS_FINITE,dtype:"bool"}),N_={kernelName:rh,backendName:"webgpu",kernelFunc:k_};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $_=xe({opType:G.IS_INF,dtype:"bool"}),T_={kernelName:sh,backendName:"webgpu",kernelFunc:$_};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E_=xe({opType:G.IS_NAN,dtype:"bool"}),__={kernelName:oh,backendName:"webgpu",kernelFunc:E_};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A_(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{alpha:o}=r,i=[{type:"float32",data:[o]}],a=new Er(s.shape,G.LEAKYRELU,"alpha : f32,");return t.runWebGPUProgram(a,[s],"float32",i)}const R_={kernelName:ih,backendName:"webgpu",kernelFunc:A_};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D_=Ue({opType:ae.LESS,dtype:"bool",cpuKernelImpl:RN}),P_={kernelName:ah,backendName:"webgpu",kernelFunc:D_};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O_=Ue({opType:ae.LESS_EQUAL,dtype:"bool",cpuKernelImpl:AN}),F_={kernelName:uh,backendName:"webgpu",kernelFunc:O_};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class z_{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`
      ${j("index")} {
        if (index < uniforms.size) {
          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L_(n){const{backend:e,attrs:t}=n,{start:r,stop:s,num:o}=t,i=(s-r)/(o-1),a=new z_(o),u=[{type:"float32",data:[r]},{type:"float32",data:[i]}];return e.runWebGPUProgram(a,[],"float32",u)}const B_={kernelName:lh,backendName:"webgpu",kernelFunc:L_};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M_=xe({opType:G.LOG,cpuKernelImpl:DN}),V_={kernelName:ch,backendName:"webgpu",kernelFunc:M_};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W_=xe({opType:G.LOG1P}),U_={kernelName:hh,backendName:"webgpu",kernelFunc:W_};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G_=Ue({opType:ae.LOGICAL_AND,dtype:"bool"}),H_={kernelName:dh,backendName:"webgpu",kernelFunc:G_};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j_=xe({opType:G.LOGICAL_NOT}),q_={kernelName:ph,backendName:"webgpu",kernelFunc:j_};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K_=Ue({opType:ae.LOGICAL_OR}),X_={kernelName:fh,backendName:"webgpu",kernelFunc:K_};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ef=`
  var powValue = 0.0;
  let basis = uniforms.bias + uniforms.alpha * sum;
  if (uniforms.beta == 0.5) {
    powValue = inverseSqrt(basis);
  } else if (uniforms.beta == 1.0) {
    powValue = 1.0 / basis;
  } else {
    powValue = exp(log(basis) * (-uniforms.beta));
  }
`;class Y_{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`
    ${j("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];
        let d = coords[3];

        let x = getX(b, r, c, d);
        var sum = 0.0;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let idx = d + i;
          if (idx >= 0 && idx < uniforms.xShape[3]) {
            let z = getX(b, r, c, idx);
            sum = sum + z * z;
          }
        }
        ${Ef}

        setOutputAtIndex(index, x * powValue);
      }
    }
  `}}class Q_{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,I(t<=this.maxAllowRadius,()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=K(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`
    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;
    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};
    const maxAllowRadius = ${this.maxAllowRadius};

    ${j()} {
      let localDepth = i32(localId.x);
      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;
      let xDepth = workgroupDepth + localDepth - maxAllowRadius;
      let b = i32(globalId.z) / uniforms.xShape[1];
      let r = i32(globalId.z) - b * uniforms.xShape[1];
      let c = i32(globalId.y);
      let d = workgroupDepth + localDepth;

      var x = 0.0;
      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {
        x = getX(b, r, c, xDepth);
      }
      lrnSub[localDepth] = x;
      workgroupBarrier();

      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {
        var sum = 0.0;
        let index = localDepth + maxAllowRadius;
        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {
          let z = lrnSub[index + i];
          sum = sum + z * z;
        }
        ${Ef}

        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);
      }
    } `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z_(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{depthRadius:o,bias:i,alpha:a,beta:u}=r;let l;o>16?l=new Y_(s.shape):l=new Q_(s.shape,o);const h=[{type:"int32",data:[o]},{type:"float32",data:[i]},{type:"float32",data:[a]},{type:"float32",data:[u]}];return t.runWebGPUProgram(l,[s],s.dtype,h)}const J_={kernelName:mh,backendName:"webgpu",kernelFunc:Z_};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eA{constructor(e){this.outputShape=[],this.variableNames=["inputImage","outputImage","dy"],this.uniforms="depthRadius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn_grad"}getUserCode(){return`
    ${j("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let b = coords[0];
        let r = coords[1];
        let c = coords[2];

        let MIN_DEPTH_BEGIN = 0;
        let MAX_DEPTH_END = uniforms.outShape[3];
        var result = 0.0;
        for (var d = MIN_DEPTH_BEGIN; d < MAX_DEPTH_END; d++) {
          let depthBegin = max(MIN_DEPTH_BEGIN, d - uniforms.depthRadius);
          let depthEnd = min(MAX_DEPTH_END, d + uniforms.depthRadius + 1);

          var norm = 0.0;
          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            } else {
              break;
            }
          }

          norm = uniforms.alpha * norm + uniforms.bias;

          for (var k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; k++) {
            if (k < depthBegin) {
              continue;
            } else if (k >= depthBegin && k < depthEnd) {
              var dyi = -2.0 * uniforms.alpha * uniforms.beta
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d) / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * uniforms.beta);
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            } else {
              break;
            }
          }
        }

        setOutputAtIndex(index, result);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tA(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,y:o,dy:i}=e,{depthRadius:a,bias:u,alpha:l,beta:h}=r,c=new eA(s.shape),d=[{type:"int32",data:[a]},{type:"float32",data:[u]},{type:"float32",data:[l]},{type:"float32",data:[h]}];return t.runWebGPUProgram(c,[s,o,i],s.dtype,d)}const nA={kernelName:rg,backendName:"webgpu",kernelFunc:tA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rA=Ue({opType:ae.MAX,cpuKernelImpl:ON}),sA={kernelName:yh,backendName:"webgpu",kernelFunc:rA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oA(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:o,strides:i,pad:a,dimRoundingMode:u}=r,h=Nr(s.shape,o,i,1,a,u);return yf(s,h,"max",t)}const iA={kernelName:bh,backendName:"webgpu",kernelFunc:oA};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aA(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{filterSize:o,strides:i,pad:a,dataFormat:u,dimRoundingMode:l}=r,h=[1,1,1],c=lo(s.shape,o,i,h,a,l,u),d=new Ea(c,"max"),f=[{type:"int32",data:[c.strideDepth,c.strideHeight,c.strideWidth]},{type:"int32",data:[c.padInfo.front,c.padInfo.top,c.padInfo.left]},{type:"int32",data:[c.inDepth,c.inHeight,c.inWidth]},{type:"int32",data:[c.effectiveFilterDepth,c.effectiveFilterHeight,c.effectiveFilterWidth]}];return t.runWebGPUProgram(d,[s],s.dtype,f)}const uA={kernelName:wh,backendName:"webgpu",kernelFunc:aA};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lA{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec2<i32>, pads : vec2<i32>, dilations : vec2<i32>, filterDims : vec2<i32>,
       outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool2DBackprop"}getUserCode(){return`
      ${j("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords[0];
        let d = coords[3];

        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;
        let dyRCorner = dyRCCorner.x;
        let dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] - 1;
        for (var wR = 0; wR < uniforms.filterDims[0]; wR += uniforms.dilations[0]) {
          let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[0]);

          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
            continue;
          }
          let idyR = i32(dyR);

          for (var wC = 0; wC < uniforms.filterDims[1]; wC += uniforms.dilations[1]) {
            let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[1]);

            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
              continue;
            }
            let idyC = i32(dyC);

            let dyValue = getDy(batch, idyR, idyC, d);
            let maxPosValue = lastIndex - i32(getMaxPos(batch, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            let curPosValue = wR * uniforms.filterDims[1] + wC;
            let mask = select(0.0, 1.0, maxPosValue == curPosValue);
            dotProd += dyValue * mask;
          }
        }
        setOutputAtIndex(index, dotProd);
      }
    }
    `}}class cA{constructor(e){this.variableNames=["dy","maxPos"],this.uniforms=`strides : vec3<i32>, pads : vec3<i32>, filterDims : vec3<i32>,
      outDepth : i32, outHeight : i32, outWidth : i32`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="maxPool3DBackprop"}getUserCode(){return`
      ${j("index")} {
      if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
        let batch = coords.x;
        let ch = coords.u;

        let dyCorner = vec3<i32>(coords.y, coords.z, coords.w) - uniforms.pads;
        let dyDCorner = dyCorner.x;
        let dyRCorner = dyCorner.y;
        let dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        var dotProd = 0.0;
        let lastIndex = uniforms.filterDims[0] * uniforms.filterDims[1] * uniforms.filterDims[2] - 1;

        for (var wD = 0; wD < uniforms.filterDims[0]; wD++) {
          let dyD = f32(dyDCorner + wD) / f32(uniforms.strides[0]);

          if (dyD < 0.0 || dyD >= f32(uniforms.outDepth) || fract(dyD) > 0.0) {
            continue;
          }
          let idyD = i32(dyD);

          for (var wR = 0; wR < uniforms.filterDims[1]; wR++) {
            let dyR = f32(dyRCorner + wR) / f32(uniforms.strides[1]);

            if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {
              continue;
            }
            let idyR = i32(dyR);

            for (var wC = 0; wC < uniforms.filterDims[2]; wC++) {
              let dyC = f32(dyCCorner + wC) / f32(uniforms.strides[2]);

              if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {
                continue;
              }
              let idyC = i32(dyC);

              let dyValue = getDy(batch, idyD, idyR, idyC, ch);
              let maxPosValue = lastIndex - i32(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              let curPosValue = wD * uniforms.filterDims[1] * uniforms.filterDims[2] + wR * uniforms.filterDims[2] + wC;
              let mask = select(0.0, 1.0, maxPosValue == curPosValue);
              dotProd += dyValue * mask;
            }
          }
        }

        setOutputAtIndex(index, dotProd);
      }
    }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hA(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o}=e,i=o,{filterSize:a,strides:u,pad:l,dimRoundingMode:h}=r,c=[1,1,1],d=lo(i.shape,a,u,c,l,h),f=new Ea(d,"max",!0);let m=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.front,d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.inDepth,d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]}];const x=t.runWebGPUProgram(f,[i],"int32",m),b=new cA(d);m=[{type:"int32",data:[d.strideDepth,d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterDepth-1-d.padInfo.front,d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.effectiveFilterDepth,d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outDepth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];const v=t.runWebGPUProgram(b,[s,x],i.dtype,m);return t.disposeData(x.dataId),v}const dA={kernelName:og,backendName:"webgpu",kernelFunc:hA};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pA(n){const{inputs:e,backend:t,attrs:r}=n,{dy:s,input:o,output:i}=e,a=o;lf([o,i],"maxPoolGrad");const{filterSize:u,strides:l,pad:h,dimRoundingMode:c}=r,d=Nr(a.shape,u,l,1,h,c),f=new os(d,"max",!0);let m=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.padInfo.top,d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.inHeight,d.inWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]}];const x=t.runWebGPUProgram(f,[a],"int32",m),b=new lA(d);m=[{type:"int32",data:[d.strideHeight,d.strideWidth]},{type:"int32",data:[d.effectiveFilterHeight-1-d.padInfo.top,d.effectiveFilterWidth-1-d.padInfo.left]},{type:"int32",data:[d.dilationHeight,d.dilationWidth]},{type:"int32",data:[d.effectiveFilterHeight,d.effectiveFilterWidth]},{type:"int32",data:[d.outHeight]},{type:"int32",data:[d.outWidth]}];const v=t.runWebGPUProgram(b,[s,x],a.dtype,m);return t.disposeData(x.dataId),v}const fA={kernelName:sg,backendName:"webgpu",kernelFunc:pA};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mA(n){const{inputs:e,backend:t,attrs:r}=n,{filterSize:s,strides:o,pad:i,includeBatchInIndex:a}=r,{x:u}=e;I(u.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${u.shape.length}.`);const l=[1,1];I(Zt(o,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${l}'`);const h=Nr(u.shape,s,o,l,i),c=[{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.padInfo.top,h.padInfo.left]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]},{type:"int32",data:[h.inHeight,h.inWidth]},{type:"int32",data:[h.effectiveFilterHeight,h.effectiveFilterWidth]}];let d=new os(h,"max",!1);const f=t.runWebGPUProgram(d,[u],u.dtype,c);d=new os(h,"max",!0,!0,a);const m=t.runWebGPUProgram(d,[u],"int32",c);return[f,m]}const gA={kernelName:xh,backendName:"webgpu",kernelFunc:mA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yA(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:i}=r;return or(s,o,i,"min",t)}const bA={kernelName:Sh,backendName:"webgpu",kernelFunc:yA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wA=Ue({opType:ae.MIN,cpuKernelImpl:FN}),xA={kernelName:Ch,backendName:"webgpu",kernelFunc:wA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vA{constructor(e,t,r){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((s,o)=>s[0]+e[o]+s[1]),this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map((s,o)=>{this.uniforms+=` pad${o} : vec2<i32>,`}),this.offset=r==="reflect"?0:1,this.shaderKey=`mirrorPad_${r}`}getUserCode(){const e=this.xShape.length,t=this.xShape.map((l,h)=>`uniforms.pad${h}[0]`).join(","),r=this.xShape.map((l,h)=>`uniforms.pad${h}[0] + uniforms.xShape${e>1?`[${h}]`:""}`).join(","),s=e===1?"start":"start[i]",o=e===1?"end":"end[i]",i=e===1?"outC":"outC[i]",a=Fe(e),u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`
      ${j("index")} {
        if (index < uniforms.size) {
          let start = ${a}(${t});
          let end = ${a}(${r});
          var outC = getCoordsFromIndex(index);
          for (var i = 0; i < ${e}; i = i + 1) {
            if (${i} < ${s}) {
              ${i} = ${s} * 2 - ${i} - ${this.offset};
            } else if(${i} >= ${o}) {
              ${i} = (${o} - 1) * 2 - ${i} + ${this.offset};
            }
          }
          let coords = outC - start;
          setOutputAtIndex(index, getX(${u}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SA={kernelName:Ih,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{paddings:s,mode:o}=e,i=t,a=s.map(h=>({type:"int32",data:[h[0],h[1]]})),u=new vA(r.shape,s,o);return i.runWebGPUProgram(u,[r],r.dtype,a)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CA=Ue({opType:ae.MOD}),IA={kernelName:kh,backendName:"webgpu",kernelFunc:CA};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kA{constructor(e,t){this.variableNames=["probs"],this.outputShape=[],this.uniforms="seed : f32, numOutcomes: i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="multinomial"}getUserCode(){return`
    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    fn random (seed : f32, resultUV : vec2<f32>) -> f32 {
      let HASHSCALE1 = 443.8975;
      let p = resultUV * seed;
      var p3  = fract(vec3<f32>(p.xyx) * HASHSCALE1);
      p3 = p3 + dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${j("index")} {
      if (index < uniforms.size) {
        let coords = getOutputCoords();
        let batch = coords[0];

        let resUV = vec2<f32>(f32(coords[1]) / f32(uniforms.outShape[1]),
            f32(coords[0]) / f32(uniforms.outShape[0]));
        let r = random(uniforms.seed, resUV);
        var cdf = 0.0;
        for (var i = 0; i < uniforms.numOutcomes - 1; i = i + 1) {
          cdf = cdf + getProbs(batch, i);

          if (r < cdf) {
            setOutputAtIndexI32(index, i);
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutputAtIndexI32(index, uniforms.numOutcomes - 1);
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NA{constructor(e){this.variableNames=["logits"],this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=[this.outputShape[0],1,1],this.outputShape[1]>=4096?this.workgroupSize=[256,1,1]:this.workgroupSize=[64,1,1],this.shaderKey="softmax"}getUserCode(){return`
    var<workgroup> buf : array<f32, ${this.workgroupSize[0]}>;
    var<workgroup> rowMaxShared : f32;
    var<workgroup> rowSumShared : f32;
    const blockSize = ${this.workgroupSize[0]};
    ${j("index")} {
      let row = index / blockSize;
      let tid = i32(localId.x);
      let cols = uniforms.outShape[1];

      var threadMax = -3.402823e+38f;
      for (var col = tid; col < cols; col += blockSize) {
        let value = getLogits(row, col);
        threadMax = max(threadMax, value);
      }
      if (tid < cols) {
        buf[tid] = threadMax;
      }
      workgroupBarrier();

      var reduceSize = min(cols, blockSize);
      for (var currSize = reduceSize >> 1;  currSize > 0; currSize = reduceSize >> 1) {
        reduceSize = currSize + (reduceSize & 1);
        if (tid < currSize) {
          buf[tid] = max(buf[tid], buf[tid + reduceSize]);
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowMaxShared = buf[0];
      }
      workgroupBarrier();

      var threadSum = 0.0;
      for (var col = tid; col < cols; col += blockSize) {
        let subExp = exp(getLogits(row, col) - rowMaxShared);
        threadSum += subExp;
      }
      buf[tid] = threadSum;
      workgroupBarrier();

      for (var currSize = blockSize >> 1;  currSize > 0; currSize = currSize >> 1) {
        if (tid < currSize) {
          buf[tid] = buf[tid] + buf[tid + currSize];
        }
        workgroupBarrier();
      }

      if (tid == 0) {
        rowSumShared = buf[0];
      }
      workgroupBarrier();

      for (var col = tid; col < cols; col += blockSize) {
        let value = exp(getLogits(row, col) - rowMaxShared) / rowSumShared;
        setOutputAtCoords(row, col, value);
      }
  }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _f(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{dim:o}=r,i=te({inputs:{x:s},backend:t,attrs:{shape:[H(s.shape)/s.shape[o],s.shape[o]]}}),a=new NA(i.shape),u=t.runWebGPUProgram(a,[i],s.dtype),l=te({inputs:{x:u},backend:t,attrs:{shape:s.shape}});return t.disposeData(i.dataId),t.disposeData(u.dataId),l}const $A={kernelName:hd,backendName:"webgpu",kernelFunc:_f};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TA(n){const{inputs:e,backend:t,attrs:r}=n,{logits:s}=e,{numSamples:o,seed:i,normalized:a}=r,u=a?s:_f({inputs:{logits:s},backend:t,attrs:{dim:s.shape.length-1}}),l=u.shape[0],h=u.shape[1],c=new kA(l,o),d=[{type:"float32",data:[i]},{type:"int32",data:[h]}],f=t.runWebGPUProgram(c,[u],"int32",d);return a||t.disposeData(u.dataId),f}const EA={kernelName:Nh,backendName:"webgpu",kernelFunc:TA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _A(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])){const o=t.tensorMap.get(r.dataId),[i,a]=LN(o.values,r.shape,r.dtype);return t.makeTensorInfo(a,r.dtype,i)}const s=new Er(r.shape,G.NEG);return t.runWebGPUProgram(s,[r],r.dtype)}const AA={kernelName:Th,backendName:"webgpu",kernelFunc:_A};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RA(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u}=r,l=t.readSync(s.dataId),h=t.readSync(o.dataId),{selectedIndices:c}=jp(l,h,i,a,u);return t.makeTensorInfo([c.length],"int32",new Int32Array(c))}const DA={kernelName:_h,backendName:"webgpu",kernelFunc:RA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PA(n){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:s,scores:o}=e,{maxOutputSize:i,iouThreshold:a,scoreThreshold:u,softNmsSigma:l}=r,h=t.readSync(s.dataId),c=t.readSync(o.dataId),d=i,f=a,m=u,x=l,{selectedIndices:b,selectedScores:v}=qp(h,c,d,f,m,x);return[t.makeTensorInfo([b.length],"int32",new Int32Array(b)),t.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const OA={kernelName:Ah,backendName:"webgpu",kernelFunc:PA};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FA{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`
      ${j("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,
                                      f32(i32(round(getX(coords.x))) == coords.y)));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zA(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s}=e,{dtype:o,depth:i,onValue:a,offValue:u}=r,l=H(s.shape),h=new FA(l,i),c=te({inputs:{x:s},backend:t,attrs:{shape:[l]}}),d=[{type:"float32",data:[a]},{type:"float32",data:[u]}],f=t.runWebGPUProgram(h,[c],o,d);t.disposeData(c.dataId);const m=[...s.shape,i],x=te({inputs:{x:f},backend:t,attrs:{shape:m}});return t.disposeData(f.dataId),x}const LA={kernelName:Dh,backendName:"webgpu",kernelFunc:zA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eo(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="complex64"){const s=ms({inputs:{input:r},backend:t}),o=eo({inputs:{x:s},backend:t}),i=Io({inputs:{input:r},backend:t}),a=eo({inputs:{x:i},backend:t}),u=sr({inputs:{real:o,imag:a},backend:t});return t.disposeData(s.dataId),t.disposeData(o.dataId),t.disposeData(i.dataId),t.disposeData(a.dataId),u}else return st({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:t})}const BA={kernelName:kd,backendName:"webgpu",kernelFunc:eo};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Af(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const s=ms({inputs:{input:r},backend:t}),o=Af({inputs:{x:s},backend:t}),i=Io({inputs:{input:r},backend:t}),a=eo({inputs:{x:i},backend:t}),u=sr({inputs:{real:o,imag:a},backend:t});return t.disposeData(s.dataId),t.disposeData(o.dataId),t.disposeData(i.dataId),t.disposeData(a.dataId),u}else return st({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:t})}const MA={kernelName:Rh,backendName:"webgpu",kernelFunc:Af};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VA(n){const{inputs:e,backend:t,attrs:r}=n,{axis:s}=r;if(e.length===1)return Oi({inputs:{input:e[0]},backend:t,attrs:{dim:s}});const o=e[0].shape,i=e[0].dtype;e.forEach(h=>{bt(o,h.shape,"All tensors passed to stack must have matching shapes"),I(i===h.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],u=e.map(h=>{const c=Oi({inputs:{input:h},backend:t,attrs:{dim:s}});return a.push(c),c}),l=xf({inputs:u,backend:t,attrs:{axis:s}});return a.forEach(h=>t.disposeData(h.dataId)),l}const WA={kernelName:Ph,backendName:"webgpu",kernelFunc:VA};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rf(n,e=!1){const t=n.length,r=Fe(t),s=n.map((c,d)=>`uniforms.pad${d}[0]`).join(","),o=n.map((c,d)=>`uniforms.pad${d}[0] + uniforms.xShape${t>1?`[${d}]`:""}`).join(","),i=t>1?`${r}(${s})`:`${s}`,a=t>1?`${r}(${o})`:`${o}`,u=t>1?"any(paddedCoords < start)":"paddedCoords < start",l=t>1?"any(paddedCoords >= end)":"paddedCoords >= end",h=t>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,t):"coords";return`
        let start = ${i};
        let end = ${a};
        if (${u} || ${l}) {
          setOutputAtIndex(index, ${e?0:"uniforms.constantValue"});
        } else {
          let coords = paddedCoords - start;
          setOutputAtIndex(index, getX(${h}));
        }
  `}class UA{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map((r,s)=>r[0]+e[s]+r[1]),this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map((r,s)=>{this.uniforms+=` pad${s} : vec2<i32>,`}),this.xShape=e,this.shaderKey="pad"}getUserCode(){return`
      ${j("index")} {
        if (index < uniforms.size) {
          let paddedCoords = getCoordsFromIndex(index);
          ${Rf(this.xShape)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GA=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{paddings:o,constantValue:i}=r;if(o.every(l=>ot(l,[0,0])))return ft({inputs:{x:s},backend:t});if(H(s.shape)===0){const l=o.map((h,c)=>h[0]+s.shape[c]+h[1]);return st({backend:t,attrs:{shape:l,value:i,dtype:s.dtype}})}const a=[{type:"float32",data:[i]}];o.map(l=>a.push({type:"int32",data:[l[0],l[1]]}));const u=new UA(s.shape,o);return t.runWebGPUProgram(u,[s],s.dtype,a)},HA={kernelName:Oh,backendName:"webgpu",kernelFunc:GA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jA=Ue({opType:ae.POW}),qA={kernelName:Fh,backendName:"webgpu",kernelFunc:jA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KA(n){const{inputs:e,backend:t}=n,{x:r,alpha:s}=e,o=new Qs(ae.PRELU,r.shape,s.shape);return t.runWebGPUProgram(o,[r,s],"float32")}const XA={kernelName:zh,backendName:"webgpu",kernelFunc:KA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YA(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{axis:o,keepDims:i}=r;return or(s,o,i,"prod",t)}const QA={kernelName:Lh,backendName:"webgpu",kernelFunc:YA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZA=n=>{const{backend:e,attrs:t}=n,{start:r,stop:s,step:o,dtype:i}=t,a=VN(r,s,o,i);return e.makeTensorInfo([a.length],i,a)},JA={kernelName:Bh,backendName:"webgpu",kernelFunc:ZA};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eR=Ue({opType:ae.DIV}),tR={kernelName:zc,backendName:"webgpu",kernelFunc:eR};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nR=xe({opType:G.RECIPROCAL}),rR={kernelName:Vh,backendName:"webgpu",kernelFunc:nR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sR=xe({opType:G.RELU}),oR={kernelName:Wh,backendName:"webgpu",kernelFunc:sR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iR=xe({opType:G.RELU6}),aR={kernelName:jh,backendName:"webgpu",kernelFunc:iR};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uR{constructor(e,t,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,r,e[3]],this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`
      ${j("index")} {
        if (index < uniforms.size) {
        let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC =
            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *
            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);

          // Compute the four integer indices.
          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);
          let sourceCeilRC = vec2<i32>(
            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));

          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);
          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);
          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);
          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);

          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);

          let top = topLeft + (topRight - topLeft) * fracRC.y;
          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
          let newValue = top + (bottom - top) * fracRC.x;

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lR(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:o,size:i,halfPixelCenters:a}=r,[u,l]=i,h=o&&u>1?1:0,c=o&&l>1?1:0,f=[{type:"float32",data:[h,c]},{type:"float32",data:[a?.5:0]}],m=new uR(s.shape,u,l);return t.runWebGPUProgram(m,[s],"float32",f)}const cR={kernelName:Hh,backendName:"webgpu",kernelFunc:lR};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hR{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, heightScale : f32, widthScale : f32,
       invHeightScale : f32, invWidthScale : f32, winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeBilinearBackprop_${t}`}getUserCode(){return`
      ${j("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(startRLerp - f32(uniforms.winHeight / 2));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(startCLerp - f32(uniforms.winWidth / 2));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let dxR = f32(dyR) * uniforms.heightScale;
              let topDxRIndex = i32(floor(dxR));
              let bottomDxRIndex = i32(min(ceil(dxR), f32(uniforms.outShape[1] - 1)));
              let dxRLerp = dxR - f32(topDxRIndex);
              let inverseDxRLerp = 1.0 - dxRLerp;

              let dxC = f32(dyC) * uniforms.widthScale;
              let leftDxCIndex = i32(floor(dxC));
              let rightDxCIndex = i32(min(ceil(dxC), f32(uniforms.outShape[2] - 1)));
              let dxCLerp = dxC - f32(leftDxCIndex);
              let inverseDxCLerp = 1.0 - dxCLerp;

              if (r == topDxRIndex && c == leftDxCIndex) {
                // topLeft
                accumulator +=
                  getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
              }

              if (r == topDxRIndex && c == rightDxCIndex) {
                // topRight
                accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
              }

              if (r == bottomDxRIndex && c == leftDxCIndex) {
                // bottomLeft
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
              }

              if (r == bottomDxRIndex && c == rightDxCIndex) {
                // bottomRight
                accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dR(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:o}=e,{alignCorners:i}=r,[,a,u]=s.shape,[,l,h]=o.shape,c=[i&&l>1?a-1:a,i&&h>1?u-1:u],d=[i&&l>1?l-1:l,i&&h>1?h-1:h],f=c[0]/d[0],m=c[1]/d[1],x=1/f,b=1/m,v=Math.ceil(x)*2+2,k=Math.ceil(b)*2+2,$=new hR(s.shape,i),N=[{type:"int32",data:c},{type:"int32",data:d},{type:"float32",data:[f]},{type:"float32",data:[m]},{type:"float32",data:[x]},{type:"float32",data:[b]},{type:"int32",data:[v]},{type:"int32",data:[k]}];return t.runWebGPUProgram($,[o],o.dtype,N)}const pR={kernelName:hg,backendName:"webgpu",kernelFunc:dR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fR{constructor(e,t,r,s){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,r,e[3]],this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=s,this.shaderKey=`resizeNearest_${s}`}getUserCode(){let e;return this.halfPixelCenters?e="max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":e="vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`
      ${j("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let b = coords[0];
          let d = coords[3];
          let rc = coords.yz;

          let effectiveInSize = vec2<f32>(
            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveOutSize = vec2<f32>(
            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],
            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);

          let effectiveInputOverOutputRatioRC =
              effectiveInSize / effectiveOutSize;

          // Fractional source index
          let sourceFracIndexRC = ${e};

          // Compute the coordinators of nearest neighbor point.
          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));
          let sourceNearestRC = vec2<i32>(
            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));
          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);

          setOutputAtIndex(index, newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mR(n){const{inputs:e,backend:t,attrs:r}=n,{images:s}=e,{alignCorners:o,halfPixelCenters:i,size:a}=r,[u,l]=a,h=o&&u>1?1:0,c=o&&l>1?1:0,f=[{type:"float32",data:[h,c]},{type:"float32",data:[o?.5:0]}],m=new fR(s.shape,u,l,i);return t.runWebGPUProgram(m,[s],s.dtype,f)}const gR={kernelName:Gh,backendName:"webgpu",kernelFunc:mR};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yR{constructor(e,t){this.variableNames=["dy"],this.uniforms=`effectiveXSize : vec2<i32>, effectiveYSize : vec2<i32>, invHeightScale : f32, invWidthScale : f32,
       winHeight : i32, winWidth : i32,`,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.alignCorners=t,this.shaderKey=`resizeNearestNeigborBackprop_${t}`}getUserCode(){return`
      ${j("index")} {
        if (index < uniforms.size) {
          let coords = getOutputCoords();
          let b = coords[0];
          let d = coords[3];
          let r = coords[1];
          let c = coords[2];

          var accumulator = 0.0;

          // Compute bounds for where in dy we will look
          let startRLerp = floor(f32(r) * uniforms.invHeightScale);
          let startDyR = i32(floor(startRLerp - f32(uniforms.winHeight / 2)));

          let startCLerp = floor(f32(c) * uniforms.invWidthScale);
          let startDyC = i32(floor(startCLerp - f32(uniforms.winWidth / 2)));

          // Loop over dy
          for (var dyROffset = 0; dyROffset < uniforms.winHeight; dyROffset++) {
            let dyR = startDyR + dyROffset;

            // Guard against the window exceeding the bounds of dy
            if (dyR < 0 || dyR >= uniforms.dyShape[1]) {
              continue;
            }

            for (var dyCOffset = 0; dyCOffset < uniforms.winWidth; dyCOffset++) {
              let dyC = startDyC + dyCOffset;

              // Guard against the window exceeding the bounds of dy
              if (dyC < 0 || dyC >= uniforms.dyShape[2]) {
                continue;
              }

              let sourceFracRow = f32(uniforms.effectiveXSize[0]) *
                  (f32(dyR) / f32(uniforms.effectiveYSize[0]));

              let sourceFracCol = f32(uniforms.effectiveXSize[1]) *
                  (f32(dyC) / f32(uniforms.effectiveYSize[1]));

              let sourceNearestRow =
                  i32(min(f32(uniforms.outShape[1] - 1),
                  ${this.alignCorners?"floor(sourceFracRow + 0.5)":"floor(sourceFracRow)"}));

              let sourceNearestCol =
                  i32(min(f32(uniforms.outShape[2] - 1),
                  ${this.alignCorners?"floor(sourceFracCol + 0.5)":"floor(sourceFracCol)"}));

              if (r == sourceNearestRow && c == sourceNearestCol) {
                accumulator += getDy(b, dyR, dyC, d);
              }
            }
          }
          // End loop over dy

          setOutputAtIndex(index, accumulator);
        }
      }
    `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bR(n){const{inputs:e,backend:t,attrs:r}=n,{images:s,dy:o}=e,{alignCorners:i}=r,[,a,u]=s.shape,[,l,h]=o.shape,c=[i&&l>1?a-1:a,i&&h>1?u-1:u],d=[i&&l>1?l-1:l,i&&h>1?h-1:h],f=c[0]/d[0],m=c[1]/d[1],x=1/f,b=1/m,v=Math.ceil(x)*2+2,k=Math.ceil(b)*2+2,$=new yR(s.shape,i),N=[{type:"int32",data:c},{type:"int32",data:d},{type:"float32",data:[x]},{type:"float32",data:[b]},{type:"int32",data:[v]},{type:"int32",data:[k]}];return t.runWebGPUProgram($,[o],o.dtype,N)}const wR={kernelName:cg,backendName:"webgpu",kernelFunc:bR};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xR{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`
      
      // Using uniform variables as judging conditions, so the function has
      // coherent execution within all threads.
      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {
        var reverseCoords = coords;
        if (uniforms.axis[0] == 1) {
          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;
        }
        if (uniforms.axis[1] == 1) {
          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;
        }
        if (uniforms.axis[2] == 1) {
          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;
        }
        if (uniforms.axis[3] == 1) {
          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;
        }

        return reverseCoords;
      }
    
      ${j("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let reverseCoords = getReverseCoords(coords);
          setOutputAtIndex(index, getX(reverseCoords[0],
              reverseCoords[1], reverseCoords[2], reverseCoords[3]));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vR(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{dims:o}=r,i=s.shape.length;if(i===0)return ft({inputs:{x:s},backend:t});const a=s.shape,u=[1,1,1,1];a.forEach((b,v)=>{const k=v+4-i;u[k]=b});const l=Tt(o,s.shape),h=[0,0,0,0];l.forEach(b=>{const v=b+4-i;h[v]=1});const c=[{type:"int32",data:h}],d=te({inputs:{x:s},backend:t,attrs:{shape:u}}),f=new xR(u),m=t.runWebGPUProgram(f,[d],d.dtype,c);t.disposeData(d.dataId);const x=te({inputs:{x:m},backend:t,attrs:{shape:a}});return t.disposeData(m.dataId),x}const SR={kernelName:qh,backendName:"webgpu",kernelFunc:vR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CR{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`centerX : f32, centerY : f32, sinRadians : f32,
          cosRadians : f32,`,this.shaderKey="rotate",this.outputShape=e,typeof t=="number"?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`
        ${j("index")} {
          if (index < uniforms.size) {
            let coords = getCoordsFromIndex(index);
            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *
                uniforms.sinRadians;
            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *
                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *
                uniforms.cosRadians;
            let coordX = i32(round(coordXFloat + uniforms.centerX));
            let coordY = i32(round(coordYFloat + uniforms.centerY));
            ${this.fillSnippet}
            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&
                coordY < uniforms.xShape[1]) {
              outputValue = getX(coords[0], coordY, coordX, coords[3]);
            }
            setOutputAtIndex(index, outputValue);
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IR={kernelName:$d,backendName:"webgpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:s,fillValue:o,center:i}=e,a=t,u=new CR(r.shape,o),[l,h]=_C(i,r.shape[1],r.shape[2]),c=[{type:"float32",data:[l]},{type:"float32",data:[h]},{type:"float32",data:[Math.sin(s)]},{type:"float32",data:[Math.cos(s)]}];return typeof o=="number"?c.push({type:"float32",data:[Number.parseFloat(o.toFixed(2))]}):c.push({type:"float32",data:o}),a.runWebGPUProgram(u,[r],r.dtype,c)}};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kR=xe({opType:G.ROUND}),NR={kernelName:Kh,backendName:"webgpu",kernelFunc:kR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $R=xe({opType:G.RSQRT,cpuKernelImpl:WN}),TR={kernelName:Xh,backendName:"webgpu",kernelFunc:$R};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xr{constructor(e,t,r,s,o,i,a,u=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=i,this.type=a,this.sumDupeIndices=u,this.dispatchLayout=Q(e),this.dispatch=K(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${r}_${s}_${this.sliceDimGreaterThanOne}_${a}_${u}_${o.length}`;const l=Fe(o.length);this.uniforms=`sliceDim : i32, strides: ${l}, updatesSize: i32,`,this.updatesRank=s,this.indicesRank=r}getUserCode(){let e="";this.indicesRank===1?e="coords[0]":this.indicesRank===2&&(e="coords[0], j");const t=`getIndices(${e})`,r=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let s="",o="";this.dispatchLayout.x.length===1?(s="flattenedIndex",o=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {
        return index;
      }
      `):this.dispatchLayout.x.length===2&&(s="vec2<i32>(flattenedIndex, coords[1])",o=`
      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {
        // N.B. |updates| could be a scalar tensor, conceptually representing a
        // 2D tensor with all values equal to that. By design, its size must be
        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|
        // gives the other.
        let sliceSize = uniforms.outShape[1];
        let d0 = index / sliceSize;
        let d1 = index - d0 * sliceSize;
        return vec2<i32>(d0, d1);
      }
      `);const a=`getUpdates(${Array.from({length:this.updatesRank},(l,h)=>`coords[${h}]`).join(", ")})`;return`
    ${o}
      ${j("index")} {
        if (index < uniforms.updatesSize) {
          let coords = getUpdatesCoordsFromFlatIndex(index);
          var flattenedIndex = 0;
          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {
            let indexInside = i32(round(${t}));
            flattenedIndex = flattenedIndex + indexInside * ${r};
          }
          let updateValue =
              ${On(this.type)}(${a});
          let flatIndex = getOutputIndexFromCoords(${s});

          ${this.sumDupeIndices?kn("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}
        }
      }`}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ER(n){const{inputs:e,backend:t,attrs:r}=n,{indices:s,updates:o}=e,{shape:i}=r,{sliceRank:a,numUpdates:u,sliceSize:l,strides:h,outputSize:c}=ba(o,s,i),d=[c/l,l];if(c===0)return t.makeTensorInfo(i,s.dtype);const f=te({inputs:{x:s},backend:t,attrs:{shape:[u,a]}}),m=te({inputs:{x:o},backend:t,attrs:{shape:[u,l]}}),x=m.dtype,b=st({backend:t,attrs:{shape:d,value:0,dtype:x}}),v=H(m.shape),k=[{type:"int32",data:[a]},{type:"int32",data:h},{type:"int32",data:[v]}],$=new Xr(m.shape,a,f.shape.length,m.shape.length,h,d,x),N=t.runWebGPUProgram($,[m,f],x,k,b),R=te({inputs:{x:N},backend:t,attrs:{shape:i}});return t.disposeData(f.dataId),t.disposeData(m.dataId),t.disposeData(N.dataId),R}const _R={kernelName:Yh,backendName:"webgpu",kernelFunc:ER};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AR{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey=`search_sorted_${t}`}getUserCode(){return`
      fn findBound(batch: i32, value: f32) -> i32 {
        var left = i32(0);
        var right = uniforms.numInputs;
        while (left < right) {
          var mid = (left + right) / 2;
          if (getSortedSequence(batch, mid) ${this.side==="left"?"<":"<="} value) {
            left = mid + 1;
          } else {
            right = mid;
          }
        }
        return right;
      }

      ${j("index")} {
        if (index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let value = getValuesByOutputIndex(index);
          setOutputAtIndexI32(index, findBound(coords[0], value));
        }
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RR(n){const{inputs:e,backend:t,attrs:r}=n,{sortedSequence:s,values:o}=e,{side:i}=r,a=new AR([o.shape[0],o.shape[1]],i),u=[{type:"int32",data:[s.shape[1]]}];return t.runWebGPUProgram(a,[s,o],"int32",u)}const DR={kernelName:Zh,backendName:"webgpu",kernelFunc:RR};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PR{constructor(e,t,r){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=r,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(this.rank===1)t="resRC",e="resRC";else{const s=["resRC.x","resRC.y","resRC.z","resRC.w"],o=[],i=[];for(let a=0;a<this.outputShape.length;a++)i.push(`${s[a]}`),a<this.cRank&&o.push(`${s[a]}`);e=o.join(),t=i.join()}return`
      ${j("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          let cVal = getC(${e});
          if (cVal >= 1.0) {
            setOutputAtIndex(index, getA(${t}));
          } else {
            setOutputAtIndex(index, getB(${t}));
          }
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OR(n){const{inputs:e,backend:t}=n,{condition:r,t:s,e:o}=e,i=new PR(r.shape.length,s.shape,s.shape.length);return t.runWebGPUProgram(i,[r,s,o],xn(s.dtype,o.dtype))}const FR={kernelName:Jh,backendName:"webgpu",kernelFunc:OR};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zR=xe({opType:G.SELU}),LR={kernelName:ed,backendName:"webgpu",kernelFunc:zR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BR=xe({opType:G.SIGMOID}),MR={kernelName:od,backendName:"webgpu",kernelFunc:BR};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VR=xe({opType:G.SIGN}),WR={kernelName:sd,backendName:"webgpu",kernelFunc:VR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UR=xe({opType:G.SIN}),GR={kernelName:nd,backendName:"webgpu",kernelFunc:UR};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HR=xe({opType:G.SINH}),jR={kernelName:rd,backendName:"webgpu",kernelFunc:HR};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qR=xe({opType:G.SOFTPLUS}),KR={kernelName:id,backendName:"webgpu",kernelFunc:qR};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XR{constructor(e,t,r,s,o,i){this.variableNames=["x"],this.outputShape=[],this.uniforms="",this.workgroupSize=[64,1,1],this.size=!0;const a=new Array(s.length);for(let u=0;u<a.length;u++)a[u]=s[o[u]];this.outputShape=a,this.newDim=o,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,this.paddedXShape=t,this.uniforms+=`reshapedPaddedXShape : ${Fe(s.length)}, paddedXShapeStrides : ${Fe(i)}, `,r.map((u,l)=>{this.uniforms+=` pad${l} : vec2<i32>,`}),this.shaderKey=`spaceToBatchND_${o}`}getUserCode(){const e=Fe(this.outputShape.length),t=pf(this.newDim);return`
      ${zs(this.paddedXShape,"PaddedX")}
      ${j("index")} {
        if(index < uniforms.size) {
          let coords = getCoordsFromIndex(index);
          let switchedIndex = getIndexFromCoords${this.outputShape.length}D(${e}(${t}), uniforms.reshapedPaddedXShape);
          let paddedCoords = getPaddedXCoordsFromIndex(switchedIndex);
          ${Rf(this.xShape,!0)}
        }
      }
    `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YR=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{blockShape:o,paddings:i}=r;I(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet");const a=o.reduce((k,$)=>k*$),u=[[0,0]];u.push(...i);for(let k=1+o.length;k<s.shape.length;++k)u.push([0,0]);const l=u.map((k,$)=>k[0]+s.shape[$]+k[1]),h=tf(l,o,a,!1),c=nf(h.length,o.length,!1),d=rf(l,o,a,!1),f=Qe(l),m=new XR(s.shape,l,u,h,c,f.length),x=[{type:"int32",data:h},{type:"int32",data:f}];u.map(k=>x.push({type:"int32",data:[k[0],k[1]]}));const b=t.runWebGPUProgram(m,[s],s.dtype,x),v=te({inputs:{x:b},backend:t,attrs:{shape:d}});return t.disposeData(b.dataId),v},QR={kernelName:ld,backendName:"webgpu",kernelFunc:YR};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZR{constructor(e,t,r){this.variableNames=["input","indices","segmentIds"],this.outputShape=[],this.uniforms="segmentSize : i32, sparseSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=e,this.type=r,this.dispatchLayout=Q([t]),this.dispatch=K(this.dispatchLayout,[t],this.workgroupSize),this.shaderKey="sparseSegmentSum"}getUserCode(){return`
    ${j("index")} {
      if (index < uniforms.sparseSize) {
        let indexInSegmentIds = index / uniforms.segmentSize;
        let indexInSegment = index % uniforms.segmentSize;
        let indexInInput = indices[indexInSegmentIds];
        let segmentId = segmentIds[indexInSegmentIds];

        let value = input[indexInInput * uniforms.segmentSize + indexInSegment];
        let outIndex = segmentId * uniforms.segmentSize + indexInSegment;
        ${kn("&result[outIndex]","value",this.type)}
      }
    }
  `}}class JR{constructor(e,t){this.variableNames=["segmentIds"],this.outputShape=[],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=[e],this.dispatchLayout=Q(t),this.dispatch=K(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="sparseSegmentIdCountProgram"}getUserCode(){return`
    ${j("index")} {
      if (index < uniforms.segmentIdsShape) {
        let segmentId = segmentIds[index];
        ${kn("&result[segmentId]","1","int32")}
      }
    }
  `}}class eD{constructor(e,t){this.variableNames=["segmentSum","sameSegmentIdCount"],this.outputShape=[],this.uniforms="segmentSize : i32",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.type=t,this.dispatchLayout=Q(e),this.dispatch=K(this.dispatchLayout,e,this.workgroupSize),this.shaderKey="sparseSegmentMean"}getUserCode(){return`
    ${j("index")} {
      if (index < uniforms.size) {
        let segmentId = index / uniforms.segmentSize;
        let count = sameSegmentIdCount[segmentId];
        if (count != 0) {
          ${this.type==="float32"?"setOutputAtIndex(index, segmentSum[index] / f32(count));":"setOutputAtIndexI32(index, segmentSum[index] / count);"}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Df(n,e,t,r=!1,s){const i=H(n.shape)/n.shape[0],a=n.dtype,u=H(e.shape),l=s.readSync(t.dataId),c=u>0?l[u-1]+1:0;let d;const f=n.shape.slice();f[0]=c;const m=u*i,x=st({backend:s,attrs:{shape:f,value:0,dtype:a}});d=new ZR(f,m,a);let b=[{type:"int32",data:[i]},{type:"int32",data:[m]}];const v=s.runWebGPUProgram(d,[n,e,t],a,b,x);if(r)return v;const k=st({backend:s,attrs:{shape:[c],value:0,dtype:"int32"}});d=new JR(c,t.shape);const $=s.runWebGPUProgram(d,[t],"int32",null,k),N=st({backend:s,attrs:{shape:f,value:0,dtype:a}});d=new eD(f,a),b=[{type:"int32",data:[i]}];const R=s.runWebGPUProgram(d,[v,$],a,b,N);return s.disposeData(v.dataId),s.disposeData($.dataId),R}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tD(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:o}=e;return Df(r,s,o,!1,t)}const nD={kernelName:dd,backendName:"webgpu",kernelFunc:tD};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rD(n){const{inputs:e,backend:t}=n,{data:r,indices:s,segmentIds:o}=e;return Df(r,s,o,!0,t)}const sD={kernelName:pd,backendName:"webgpu",kernelFunc:rD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oD{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const r=new Array(e.length);for(let s=0;s<r.length;s++)r[s]=e[s]*t[s];this.outputShape=r,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=iD(this.rank,"uniforms.");return`
      ${j("index")} {
        if (index < uniforms.size) {
          let resRC = getCoordsFromIndex(index);
          setOutputAtIndex(index, getA(${e}));
        }
      }
    `}}function iD(n,e=""){if(n>=5)throw Error(`Tile for rank ${n} is not yet supported`);if(n===1)return`(resRC % ${e}aShape)`;const t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let s=0;s<n;s++)r.push(`(${t[s]} % ${e}aShape[${s}])`);return r.join()}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _a(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{reps:o}=r;if(t.shouldExecuteOnCPU([s])||s.dtype==="string"||s.shape.length>=5){const u=t.readSync(s.dataId),l=s.dtype==="string"?u.map(d=>xr(d)):u,h=Ee(s.shape,s.dtype,l),c=XN(h,o);return t.makeTensorInfo(c.shape,c.dtype,c.values)}const i=new oD(s.shape,o);return t.runWebGPUProgram(i,[s],s.dtype)}const aD={kernelName:Zi,backendName:"webgpu",kernelFunc:_a};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uD(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:s,sparseValues:o,defaultValue:i}=e,{outputShape:a}=r,{sliceRank:u,numUpdates:l,sliceSize:h,strides:c,outputSize:d}=ba(o,s,a),f=!1;if(o.dtype==="string"){const B=t.bufferSync(s),L=t.bufferSync(o),W=xr(t.readSync(i.dataId)[0]),V=UN(B,L,a,d,h,l,u,c,W,f);return t.makeTensorInfo(a,V.dtype,V.values)}const m=[d/h,h],x=te({inputs:{x:s},backend:t,attrs:{shape:[l,u]}}),b=o.shape.length?te({inputs:{x:o},backend:t,attrs:{shape:[l,h]}}):ft({inputs:{x:o},backend:t}),v=b.dtype,k=t.makeTensorInfo([],v,on(1,v)),$=te({inputs:{x:i},backend:t,attrs:{shape:Array(m.length).fill(1)}}),N=_a({inputs:{x:$},backend:t,attrs:{reps:m}}),R=H([l,h]),O=[{type:"int32",data:[u]},{type:"int32",data:c},{type:"int32",data:[R]}];switch(l){case 0:break;case 1:{const B=new Xr([l,h],u,x.shape.length,b.shape.length,c,m,v,f);t.runWebGPUProgram(B,[b,x],v,O,N)}break;default:{const B=new Xr([l,h],u,x.shape.length,k.shape.length,c,m,v,f);t.runWebGPUProgram(B,[k,x],v,O,N)}{const B=new Xr([l,h],u,x.shape.length,b.shape.length,c,m,v);t.runWebGPUProgram(B,[b,x],v,O,N)}}const F=te({inputs:{x:N},backend:t,attrs:{shape:a}});return t.disposeData(x.dataId),t.disposeData(b.dataId),t.disposeData($.dataId),t.disposeData(k.dataId),t.disposeData(N.dataId),F}const lD={kernelName:fd,backendName:"webgpu",kernelFunc:uD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cD(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{numOrSizeSplits:o,axis:i}=r,a=Tt(i,s.shape)[0],u=KC(s,o,a),l=s.shape.length,h=new Array(l).fill(0),c=s.shape.slice();return u.map(d=>{const f=[...c];f[a]=d;const m=_r({inputs:{x:s},backend:t,attrs:{begin:h,size:f}});return h[a]+=d,m})}const hD={kernelName:cd,backendName:"webgpu",kernelFunc:cD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dD=xe({opType:G.SQRT}),pD={kernelName:ad,backendName:"webgpu",kernelFunc:dD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fD={kernelName:fg,backendName:"webgpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,r=e,s=new Er(t.shape,G.SQUARE);return r.runWebGPUProgram(s,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mD=Ue({opType:ae.SQUARED_DIFFERENCE}),gD={kernelName:md,backendName:"webgpu",kernelFunc:mD};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yD({inputs:n,attrs:e,backend:t}){const{x:r}=n,s=new Er(r.shape,G.STEP,"stepAlpha : f32,"),o=[{type:"float32",data:[e.alpha]}];return t.runWebGPUProgram(s,[r],r.dtype,o)}const bD={kernelName:Nd,backendName:"webgpu",kernelFunc:yD};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wD{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=Fe(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){const e=this.outputShape.length;let t="";if(e===1)t="coords * uniforms.strides + uniforms.begin";else{let s=0;t=this.outputShape.map((o,i)=>(s++,this.outputShape.length===1?`coords * uniforms.strides[${i}] + uniforms.begin[${i}]`:`coords[${s-1}] * uniforms.strides[${i}] + uniforms.begin[${i}]`)).join(",")}return`
       ${j("index")} {
         if (index < uniforms.size) {
           let coords = getCoordsFromIndex(index);
           setOutputAtIndex(index, getX(${t}));
         }
       }
     `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xD(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{begin:o,end:i,strides:a,beginMask:u,endMask:l,ellipsisMask:h,newAxisMask:c,shrinkAxisMask:d}=r,{finalShapeSparse:f,finalShape:m,isIdentity:x,sliceDim0:b,isSimpleSlice:v,begin:k,end:$,strides:N}=CC(s.shape,o,i,a,u,l,h,c,d);let R;if(x)R=te({inputs:{x:s},backend:t,attrs:{shape:m}});else if(b||v){I(s.shape.length>=1,()=>`Input must have rank at least 1, got: ${s.shape.length}`);const O=wC(k,$,N),F=_r({inputs:{x:s},backend:t,attrs:{begin:k,size:O}});R=te({inputs:{x:F},backend:t,attrs:{shape:m}}),t.disposeData(F.dataId)}else if(t.shouldExecuteOnCPU([s])){const F=t.readSync(s.dataId),B=Ee(s.shape,s.dtype,F),L=jN(f,B,N,k);R=t.makeTensorInfo(m,s.dtype,L.values)}else{const F=new wD(f),B=[{type:"int32",data:k},{type:"int32",data:N}],L=t.runWebGPUProgram(F,[s],s.dtype,B);R=te({inputs:{x:L},backend:t,attrs:{shape:m}}),t.disposeData(L.dataId)}return R}const vD={kernelName:gd,backendName:"webgpu",kernelFunc:xD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SD(n){const{inputs:e,backend:t,attrs:r}=n,{separator:s,nGramWidths:o,leftPad:i,rightPad:a,padWidth:u,preserveShortSequences:l}=r,{data:h,dataSplits:c}=e,d=t.readSync(h.dataId),f=t.readSync(c.dataId),[m,x]=qN(d,f,s,o,i,a,u,l);return[t.makeTensorInfo([m.length],"string",m),t.makeTensorInfo(c.shape,"int32",x)]}const CD={kernelName:yd,backendName:"webgpu",kernelFunc:SD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ID=Ue({opType:ae.SUB,cpuKernelImpl:KN,supportsComplex:!0}),kD={kernelName:bd,backendName:"webgpu",kernelFunc:ID};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ND=xe({opType:G.TAN}),$D={kernelName:wd,backendName:"webgpu",kernelFunc:ND};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TD=xe({opType:G.TANH}),ED={kernelName:xd,backendName:"webgpu",kernelFunc:TD};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _D(n){const{inputs:e,backend:t,attrs:r}=n,{tensor:s,indices:o,updates:i}=e,{sliceRank:a,numUpdates:u,sliceSize:l,strides:h,outputSize:c}=ba(i,o,s.shape),d=[c/l,l];if(c===0)return t.makeTensorInfo(s.shape,o.dtype);const f=[],m=te({inputs:{x:o},backend:t,attrs:{shape:[u,a]}});f.push(m);const x=te({inputs:{x:i},backend:t,attrs:{shape:[u,l]}});f.push(x);const b=te({inputs:{x:s},backend:t,attrs:{shape:d}});f.push(b);const v=_a({inputs:{x:b},backend:t,attrs:{reps:Array(d.length).fill(1)}}),k=new Xr([u,l],a,m.shape.length,x.shape.length,h,d,s.dtype,!1),$=H([u,l]),N=[{type:"int32",data:[a]},{type:"int32",data:h},{type:"int32",data:[$]}],R=t.runWebGPUProgram(k,[x,m],b.dtype,N,v);f.push(R);const O=te({inputs:{x:R},backend:t,attrs:{shape:s.shape}});return f.forEach(F=>t.disposeData(F.dataId)),O}const AD={kernelName:Qh,backendName:"webgpu",kernelFunc:_D};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RD{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=`inputSize : i32, firstPass : i32, negativeInf : f32,
        dir : i32, inc : i32,`,this.shaderKey="swap"}getUserCode(){return`
        ${j("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // We compare elements pair-wise within a group of size 2 * inc.
            // The comparing rule for each group alternates between ascending
            // and descending. Within each group, we compare each pair at
            // positions i and i+inc. To decide whether an element at position i
            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
            // inc, it is in the first half of the group, we denote it as x0,
            // otherwise we denote it as x1.
            // For example, as shown in the Bitonic top K paper referenced
            // above, Figure5(a) shows that element[1] is in the second half of
            // the group when group size is 2, but it is in the first half of
            // the group when group size is 4.
            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;
            var i = 0;
            if (isFirstInPair) {
              i = elemIdx;
            } else {
              i = elemIdx - uniforms.inc;
            }

            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }

            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.inc;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.inc));
            }

            var x0 = f32(0.0);
            var x1 = f32(0.0);
            if (i0 < uniforms.inputSize) {
              x0 = getX(batch, i0);
            } else {
              x0 = uniforms.negativeInf;
            }
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = uniforms.negativeInf;
            }

            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;
            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
            if (reverse == isGreater) {
              // Elements in opposite order of direction
              let iTemp = i0;
              i0 = i1;
              i1 = iTemp;
            }
            if (isFirstInPair) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}class DD{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`
        ${j("index")} {
          if (index < uniforms.size) {
            let outC = getCoordsFromIndex(index);
            let batch = outC[0];
            let elemIdx = outC[1];
            // The output size is half of the previous size.
            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _
            // (k=4), we only need to output the indices at positions |, the
            // indices at positions _ can be thrown away, see Figure5(b) After
            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced
            // above.
            // For example, the paper shows we only need to output the orange
            // bars. The output sequence should look like this | | | | | | | |.
            // Because the sequence is halved, to map the output index back to
            // the previous sequence to find the corresponding value, we need
            // to double the index. When we double the index, we basically
            // interpolate a position, so 2i looks like
            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k
            // position of each 2k positions by - elemIdx % k. E.g. for output
            // at index 4,5,6,7, we want to get the corresponding element at
            // original index 8,9,10,11, for output at index 8,9,10,11,
            // we want to get the corresponding element at original index
            // 16,17,18,19, so on and so forth.

            var i = 0;
            if (elemIdx < uniforms.k) {
              i = elemIdx;
            } else {
              i = elemIdx * 2 - elemIdx % uniforms.k;
            }
            var i0 = 0;
            if (uniforms.firstPass == 1) {
              i0 = i;
            } else {
              i0 = i32(getIndices(batch, i));
            }
            var i1 = 0;
            if (uniforms.firstPass == 1) {
              i1 = i + uniforms.k;
            } else {
              i1 = i32(getIndices(batch, i + uniforms.k));
            }

            let x0 = getX(batch, i0);
            var x1 = f32(0.0);
            if (i1 < uniforms.inputSize) {
              x1 = getX(batch, i1);
            } else {
              x1 = x0;
            }

            if (x0 >= x1) {
              setOutputAtIndex(index, f32(i0));
            } else {
              setOutputAtIndex(index, f32(i1));
            }
          }
        }
      `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cr(n,e){e!==null&&n.disposeData(e.dataId)}function kl(n){let e=1;for(;e<n;)e*=2;return e}function PD(n){const{inputs:e,backend:t,attrs:r}=n,{x:s}=e,{k:o,sorted:i}=r,a=s.shape,u=a[a.length-1];if(t.shouldExecuteOnCPU([s])){const R=t.readSync(s.dataId),[O,F]=YN(R,a,s.dtype,o,i);return[t.makeTensorInfo(O.shape,O.dtype,O.values),t.makeTensorInfo(F.shape,F.dtype,F.values)]}if(o===0)return a[a.length-1]=0,[t.makeTensorInfo(a,s.dtype,[]),t.makeTensorInfo(a,"int32",[])];if(u===1)return[s,st({attrs:{shape:a,dtype:"int32",value:0},backend:t})];const h=H(a)/u,c=te({inputs:{x:s},attrs:{shape:[h,u]},backend:t}),d=kl(o),f=kl(u);let m=null;const x=()=>m===null?[c,c]:[c,m],b=(R,O,F)=>{const B=x(),L=new RD(F),V=[{type:"int32",data:[u]},{type:"int32",data:[m===null?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[R]},{type:"int32",data:[O]}],ee=m;m=t.runWebGPUProgram(L,B,"int32",V),cr(t,ee)};for(let R=1;R<d;R*=2){const O=R*2;for(let F=R;F>=1;F/=2)b(O,F,[h,f])}for(let R=f;R>d;R/=2){const O=x(),F=new DD([h,R/2]),L=[{type:"int32",data:[u]},{type:"int32",data:[m===null?1:0]},{type:"int32",data:[d]}],W=m;m=t.runWebGPUProgram(F,O,"int32",L),cr(t,W);const V=d/2,ee=V*2;for(let J=V;J>=1;J/=2)b(ee,J,m.shape)}let v=m;m=_r({inputs:{x:m},backend:t,attrs:{begin:0,size:[h,o]}}),cr(t,v);let k=Tf({inputs:{x:c,indices:m},backend:t,attrs:{axis:1,batchDims:1}});cr(t,c);const $=a.slice(0,-1);$.push(o),v=m,m=te({inputs:{x:m},attrs:{shape:$},backend:t}),cr(t,v);const N=k;return k=te({inputs:{x:k},attrs:{shape:$},backend:t}),cr(t,N),[k,m]}const OD={kernelName:vd,backendName:"webgpu",kernelFunc:PD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FD{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Q(this.outputShape),this.dispatch=K(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`
          fn mapCoord(outCoord : f32, len : f32) -> f32{
            var inCoord = outCoord;
            if(uniforms.fillModeId == 2) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  if (inCoord < sz2) {
                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +
                    inCoord;
                  }
                  if (inCoord < -len) {
                    inCoord = inCoord + sz2;
                  } else {
                    inCoord = -inCoord - 1.0;
                  }
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz2 = 2.0 * len;
                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));
                  if (inCoord >= len) {
                    inCoord = sz2 - inCoord - 1.0;
                  }
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 3) {
              if (inCoord < 0.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);
                }
              } else if (inCoord > len - 1.0) {
                if (len <= 1.0) {
                  inCoord = 0.0;
                } else {
                  let sz = len - 1.0;
                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));
                }
              }
              return clamp(inCoord, 0.0, len - 1.0);
            } else if (uniforms.fillModeId == 4) {
              return clamp(outCoord, 0.0, len - 1.0);
            }
            return outCoord;
          }
          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,
            channel : i32) -> f32 {
            var outputValue : f32;
            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {
                outputValue = getImage(batch, coordY, coordX, channel);
            } else {
              outputValue = uniforms.fillValue;
            }
            return outputValue;
          }

          ${j("index")} {
            if (index < uniforms.size) {
              let coords = getCoordsFromIndex(index);
              var outputValue : f32;
              let batch = coords[0];
              let x = coords[2];
              let y = coords[1];
              let channel = coords[3];
              let xf = f32(x);
              let yf = f32(y);
              let a1 = getTransforms(batch, 0);
              let a2 = getTransforms(batch, 1);
              let a3 = getTransforms(batch, 2);
              let b1 = getTransforms(batch, 3);
              let b2 = getTransforms(batch, 4);
              let b3 = getTransforms(batch, 5);
              let c1 = getTransforms(batch, 6);
              let c2 = getTransforms(batch, 7);
              let projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = uniforms.fillValue;
              } else {
                let inX = (a1 * xf + a2 * yf + a3) / projection;
                let inY = (b1 * xf + b2 * yf + b3) / projection;
                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));
                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));

                if (uniforms.interpolationModeId == 1) {
                  let coordY = i32(round(mapY));
                  let coordX = i32(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  let yFloor = floor(mapY);
                  let xFloor = floor(mapX);
                  let yCeil = yFloor + 1.0;
                  let xCeil = xFloor + 1.0;
                  let valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);
                  let valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutputAtIndex(index, outputValue);
            }
          }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zD(n){const{inputs:e,backend:t,attrs:r}=n,{image:s,transforms:o}=e,{interpolation:i,fillMode:a,fillValue:u,outputShape:l}=r,[h,c,d,f]=s.shape,[m,x]=l??[c,d],b=[h,m,x,f],v=new FD(b),k=i==="nearest"?1:2;let $;switch(a){case"constant":$=1;break;case"reflect":$=2;break;case"wrap":$=3;break;case"nearest":$=4;break;default:$=1;break}const N=[{type:"int32",data:[k]},{type:"int32",data:[$]},{type:"float32",data:[u]}];return t.runWebGPUProgram(v,[s,o],"float32",N)}const LD={kernelName:Sd,backendName:"webgpu",kernelFunc:zD};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BD(n){const{inputs:e,backend:t,attrs:r}=n,{value:s}=e;let{axis:o}=r;o<0&&(o+=s.shape.length);const i=s,a=i.shape.length,u=s.shape[o],l=new Array(a-1);let h=0;for(let x=0;x<a;x++)x!==o&&(l[h++]=i.shape[x]);const c=[],d=new Array(a).fill(0),f=i.shape.slice();f[o]=1;const m=new Array(u);for(let x=0;x<m.length;x++){d[o]=x;const b=_r({inputs:{x:i},backend:t,attrs:{begin:d,size:f}}),v=te({inputs:{x:b},backend:t,attrs:{shape:l}});m[x]=v,c.push(b)}return c.forEach(x=>t.disposeData(x.dataId)),m}const MD={kernelName:Cd,backendName:"webgpu",kernelFunc:BD};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VD{constructor(e,t,r){if(this.outputShape=[],this.variableNames=["x","segmentIds"],this.uniforms="numSegments : i32, xSize: i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=t,this.dispatchLayout=Q(e),this.dispatch=K(this.dispatchLayout,e,this.workgroupSize),r!=="float32"&&r!=="int32")throw new Error(`UnsortedSegmentSum only supports float32 and int32
              types, does not support ${r} type.`);this.type=r,this.shaderKey="unsortedSegmentSum"}getUserCode(){return`
    ${j("index")} {
      if (index < uniforms.xSize) {
        let coords = getXCoordsFromIndex(index);
        let b = coords[0];
        let inCol = coords[1];

        let segmentId = i32(getSegmentIds(inCol));
        if (segmentId >= 0) {
          let flatIndex = b * uniforms.numSegments + segmentId % uniforms.numSegments;
          let value = getX(b, inCol);

          ${kn("&result[flatIndex]","value",this.type)}
        }
      }
    }
  `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WD(n){const{inputs:e,backend:t,attrs:r}=n,{x:s,segmentIds:o}=e,{numSegments:i}=r,a=s.shape.length,u=[];let l=0;const h=ds([l],a);let c=s;h!=null&&(c=Qt({inputs:{x:s},backend:t,attrs:{perm:h}}),u.push(c),l=ps(1,a)[0]);const d=iI(c.shape,l,i),f=H([c.shape[l]]),m=te({inputs:{x:c},backend:t,attrs:{shape:[-1,f]}});u.push(m);const x=s.dtype,b=[m.shape[0],i],v=st({backend:t,attrs:{shape:b,value:0,dtype:x}}),k=new VD(m.shape,b,x),$=[{type:"int32",data:[i]},{type:"int32",data:[H(m.shape)]}],N=t.runWebGPUProgram(k,[m,o],x,$,v),R=te({inputs:{x:N},backend:t,attrs:{shape:d}});u.push(N);let O=R;if(h!=null){u.push(R);const F=gp(h);O=Qt({inputs:{x:O},backend:t,attrs:{perm:F}})}return u.forEach(F=>t.disposeData(F.dataId)),O}const UD={kernelName:Id,backendName:"webgpu",kernelFunc:WD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GD=[ck,JN,t$,r$,o$,u$,m$,y$,w$,v$,C$,k$,$$,E$,A$,F$,L$,W$,G$,j$,Q$,tT,sT,uT,cT,fT,dk,yT,vT,ET,OT,BT,WT,GT,jT,KT,YT,JT,tE,rE,oE,uE,mE,yE,hE,xE,CE,$E,EE,RE,FE,LE,ME,WE,GE,jE,qE,XE,QE,ak,JE,o_,t_,r_,u_,c_,d_,m_,b_,x_,S_,hk,I_,wT,N_,T_,__,R_,P_,F_,B_,U_,V_,H_,q_,X_,J_,nA,D$,sA,iA,fA,uA,dA,gA,P$,bA,xA,SA,IA,EA,DE,AA,DA,OA,oT,LA,MA,WA,HA,qA,XA,QA,JA,iT,tR,rR,oR,aR,uk,cR,pR,gR,wR,SR,IR,NR,TR,_R,DR,FR,LR,MR,WR,GR,jR,X$,bD,vD,CD,$A,KR,QR,nD,sD,lD,hD,pD,fD,gD,kD,PE,$D,ED,AD,aD,OD,LD,h$,MD,UD,BA];for(const n of GD)xg(n);(function(){var n;function e(p){var g=0;return function(){return g<p.length?{done:!1,value:p[g++]}:{done:!0}}}var t=typeof Object.defineProperties=="function"?Object.defineProperty:function(p,g,w){return p==Array.prototype||p==Object.prototype||(p[g]=w.value),p};function r(p){p=[typeof globalThis=="object"&&globalThis,p,typeof window=="object"&&window,typeof self=="object"&&self,typeof Kt=="object"&&Kt];for(var g=0;g<p.length;++g){var w=p[g];if(w&&w.Math==Math)return w}throw Error("Cannot find global object")}var s=r(this);function o(p,g){if(g)e:{var w=s;p=p.split(".");for(var S=0;S<p.length-1;S++){var T=p[S];if(!(T in w))break e;w=w[T]}p=p[p.length-1],S=w[p],g=g(S),g!=S&&g!=null&&t(w,p,{configurable:!0,writable:!0,value:g})}}o("Symbol",function(p){function g(_){if(this instanceof g)throw new TypeError("Symbol is not a constructor");return new w(S+(_||"")+"_"+T++,_)}function w(_,E){this.h=_,t(this,"description",{configurable:!0,writable:!0,value:E})}if(p)return p;w.prototype.toString=function(){return this.h};var S="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",T=0;return g}),o("Symbol.iterator",function(p){if(p)return p;p=Symbol("Symbol.iterator");for(var g="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),w=0;w<g.length;w++){var S=s[g[w]];typeof S=="function"&&typeof S.prototype[p]!="function"&&t(S.prototype,p,{configurable:!0,writable:!0,value:function(){return i(e(this))}})}return p});function i(p){return p={next:p},p[Symbol.iterator]=function(){return this},p}function a(p){var g=typeof Symbol<"u"&&Symbol.iterator&&p[Symbol.iterator];return g?g.call(p):{next:e(p)}}function u(p){if(!(p instanceof Array)){p=a(p);for(var g,w=[];!(g=p.next()).done;)w.push(g.value);p=w}return p}var l=typeof Object.assign=="function"?Object.assign:function(p,g){for(var w=1;w<arguments.length;w++){var S=arguments[w];if(S)for(var T in S)Object.prototype.hasOwnProperty.call(S,T)&&(p[T]=S[T])}return p};o("Object.assign",function(p){return p||l});var h=typeof Object.create=="function"?Object.create:function(p){function g(){}return g.prototype=p,new g},c;if(typeof Object.setPrototypeOf=="function")c=Object.setPrototypeOf;else{var d;e:{var f={a:!0},m={};try{m.__proto__=f,d=m.a;break e}catch{}d=!1}c=d?function(p,g){if(p.__proto__=g,p.__proto__!==g)throw new TypeError(p+" is not extensible");return p}:null}var x=c;function b(p,g){if(p.prototype=h(g.prototype),p.prototype.constructor=p,x)x(p,g);else for(var w in g)if(w!="prototype")if(Object.defineProperties){var S=Object.getOwnPropertyDescriptor(g,w);S&&Object.defineProperty(p,w,S)}else p[w]=g[w];p.ya=g.prototype}function v(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function k(p){if(p.m)throw new TypeError("Generator is already running");p.m=!0}v.prototype.u=function(p){this.i=p};function $(p,g){p.l={ma:g,na:!0},p.h=p.s||p.v}v.prototype.return=function(p){this.l={return:p},this.h=this.v};function N(p,g,w){return p.h=w,{value:g}}function R(p){this.h=new v,this.i=p}function O(p,g){k(p.h);var w=p.h.j;return w?F(p,"return"in w?w.return:function(S){return{value:S,done:!0}},g,p.h.return):(p.h.return(g),B(p))}function F(p,g,w,S){try{var T=g.call(p.h.j,w);if(!(T instanceof Object))throw new TypeError("Iterator result "+T+" is not an object");if(!T.done)return p.h.m=!1,T;var _=T.value}catch(E){return p.h.j=null,$(p.h,E),B(p)}return p.h.j=null,S.call(p.h,_),B(p)}function B(p){for(;p.h.h;)try{var g=p.i(p.h);if(g)return p.h.m=!1,{value:g.value,done:!1}}catch(w){p.h.i=void 0,$(p.h,w)}if(p.h.m=!1,p.h.l){if(g=p.h.l,p.h.l=null,g.na)throw g.ma;return{value:g.return,done:!0}}return{value:void 0,done:!0}}function L(p){this.next=function(g){return k(p.h),p.h.j?g=F(p,p.h.j.next,g,p.h.u):(p.h.u(g),g=B(p)),g},this.throw=function(g){return k(p.h),p.h.j?g=F(p,p.h.j.throw,g,p.h.u):($(p.h,g),g=B(p)),g},this.return=function(g){return O(p,g)},this[Symbol.iterator]=function(){return this}}function W(p){function g(S){return p.next(S)}function w(S){return p.throw(S)}return new Promise(function(S,T){function _(E){E.done?S(E.value):Promise.resolve(E.value).then(g,w).then(_,T)}_(p.next())})}function V(p){return W(new L(new R(p)))}o("Promise",function(p){function g(E){this.i=0,this.j=void 0,this.h=[],this.u=!1;var P=this.l();try{E(P.resolve,P.reject)}catch(z){P.reject(z)}}function w(){this.h=null}function S(E){return E instanceof g?E:new g(function(P){P(E)})}if(p)return p;w.prototype.i=function(E){if(this.h==null){this.h=[];var P=this;this.j(function(){P.m()})}this.h.push(E)};var T=s.setTimeout;w.prototype.j=function(E){T(E,0)},w.prototype.m=function(){for(;this.h&&this.h.length;){var E=this.h;this.h=[];for(var P=0;P<E.length;++P){var z=E[P];E[P]=null;try{z()}catch(U){this.l(U)}}}this.h=null},w.prototype.l=function(E){this.j(function(){throw E})},g.prototype.l=function(){function E(U){return function(X){z||(z=!0,U.call(P,X))}}var P=this,z=!1;return{resolve:E(this.I),reject:E(this.m)}},g.prototype.I=function(E){if(E===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(E instanceof g)this.L(E);else{e:switch(typeof E){case"object":var P=E!=null;break e;case"function":P=!0;break e;default:P=!1}P?this.F(E):this.s(E)}},g.prototype.F=function(E){var P=void 0;try{P=E.then}catch(z){this.m(z);return}typeof P=="function"?this.M(P,E):this.s(E)},g.prototype.m=function(E){this.v(2,E)},g.prototype.s=function(E){this.v(1,E)},g.prototype.v=function(E,P){if(this.i!=0)throw Error("Cannot settle("+E+", "+P+"): Promise already settled in state"+this.i);this.i=E,this.j=P,this.i===2&&this.K(),this.H()},g.prototype.K=function(){var E=this;T(function(){if(E.D()){var P=s.console;typeof P<"u"&&P.error(E.j)}},1)},g.prototype.D=function(){if(this.u)return!1;var E=s.CustomEvent,P=s.Event,z=s.dispatchEvent;return typeof z>"u"?!0:(typeof E=="function"?E=new E("unhandledrejection",{cancelable:!0}):typeof P=="function"?E=new P("unhandledrejection",{cancelable:!0}):(E=s.document.createEvent("CustomEvent"),E.initCustomEvent("unhandledrejection",!1,!0,E)),E.promise=this,E.reason=this.j,z(E))},g.prototype.H=function(){if(this.h!=null){for(var E=0;E<this.h.length;++E)_.i(this.h[E]);this.h=null}};var _=new w;return g.prototype.L=function(E){var P=this.l();E.T(P.resolve,P.reject)},g.prototype.M=function(E,P){var z=this.l();try{E.call(P,z.resolve,z.reject)}catch(U){z.reject(U)}},g.prototype.then=function(E,P){function z(se,Z){return typeof se=="function"?function(le){try{U(se(le))}catch(me){X(me)}}:Z}var U,X,ue=new g(function(se,Z){U=se,X=Z});return this.T(z(E,U),z(P,X)),ue},g.prototype.catch=function(E){return this.then(void 0,E)},g.prototype.T=function(E,P){function z(){switch(U.i){case 1:E(U.j);break;case 2:P(U.j);break;default:throw Error("Unexpected state: "+U.i)}}var U=this;this.h==null?_.i(z):this.h.push(z),this.u=!0},g.resolve=S,g.reject=function(E){return new g(function(P,z){z(E)})},g.race=function(E){return new g(function(P,z){for(var U=a(E),X=U.next();!X.done;X=U.next())S(X.value).T(P,z)})},g.all=function(E){var P=a(E),z=P.next();return z.done?S([]):new g(function(U,X){function ue(le){return function(me){se[le]=me,Z--,Z==0&&U(se)}}var se=[],Z=0;do se.push(void 0),Z++,S(z.value).T(ue(se.length-1),X),z=P.next();while(!z.done)})},g});function ee(p,g){p instanceof String&&(p+="");var w=0,S=!1,T={next:function(){if(!S&&w<p.length){var _=w++;return{value:g(_,p[_]),done:!1}}return S=!0,{done:!0,value:void 0}}};return T[Symbol.iterator]=function(){return T},T}o("Array.prototype.keys",function(p){return p||function(){return ee(this,function(g){return g})}}),o("Array.prototype.fill",function(p){return p||function(g,w,S){var T=this.length||0;for(0>w&&(w=Math.max(0,T+w)),(S==null||S>T)&&(S=T),S=Number(S),0>S&&(S=Math.max(0,T+S)),w=Number(w||0);w<S;w++)this[w]=g;return this}});function J(p){return p||Array.prototype.fill}o("Int8Array.prototype.fill",J),o("Uint8Array.prototype.fill",J),o("Uint8ClampedArray.prototype.fill",J),o("Int16Array.prototype.fill",J),o("Uint16Array.prototype.fill",J),o("Int32Array.prototype.fill",J),o("Uint32Array.prototype.fill",J),o("Float32Array.prototype.fill",J),o("Float64Array.prototype.fill",J),o("Object.is",function(p){return p||function(g,w){return g===w?g!==0||1/g===1/w:g!==g&&w!==w}}),o("Array.prototype.includes",function(p){return p||function(g,w){var S=this;S instanceof String&&(S=String(S));var T=S.length;for(w=w||0,0>w&&(w=Math.max(w+T,0));w<T;w++){var _=S[w];if(_===g||Object.is(_,g))return!0}return!1}}),o("String.prototype.includes",function(p){return p||function(g,w){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(g instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(g,w||0)!==-1}});var ne=this||self;function re(p,g){p=p.split(".");var w=ne;p[0]in w||typeof w.execScript>"u"||w.execScript("var "+p[0]);for(var S;p.length&&(S=p.shift());)p.length||g===void 0?w[S]&&w[S]!==Object.prototype[S]?w=w[S]:w=w[S]={}:w[S]=g}function he(p){var g;e:{if((g=ne.navigator)&&(g=g.userAgent))break e;g=""}return g.indexOf(p)!=-1}var Le=Array.prototype.map?function(p,g){return Array.prototype.map.call(p,g,void 0)}:function(p,g){for(var w=p.length,S=Array(w),T=typeof p=="string"?p.split(""):p,_=0;_<w;_++)_ in T&&(S[_]=g.call(void 0,T[_],_,p));return S},ge={},ce=null;function Ae(p){var g=p.length,w=3*g/4;w%3?w=Math.floor(w):"=.".indexOf(p[g-1])!=-1&&(w="=.".indexOf(p[g-2])!=-1?w-2:w-1);var S=new Uint8Array(w),T=0;return Ze(p,function(_){S[T++]=_}),T!==w?S.subarray(0,T):S}function Ze(p,g){function w(z){for(;S<p.length;){var U=p.charAt(S++),X=ce[U];if(X!=null)return X;if(!/^[\s\xa0]*$/.test(U))throw Error("Unknown base64 encoding at char: "+U)}return z}Jt();for(var S=0;;){var T=w(-1),_=w(0),E=w(64),P=w(64);if(P===64&&T===-1)break;g(T<<2|_>>4),E!=64&&(g(_<<4&240|E>>2),P!=64&&g(E<<6&192|P))}}function Jt(){if(!ce){ce={};for(var p="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),g=["+/=","+/","-_=","-_.","-_"],w=0;5>w;w++){var S=p.concat(g[w].split(""));ge[w]=S;for(var T=0;T<S.length;T++){var _=S[T];ce[_]===void 0&&(ce[_]=T)}}}}var Ar=typeof Uint8Array<"u",gs=!(he("Trident")||he("MSIE"))&&typeof ne.btoa=="function";function Ra(p){if(!gs){var g;g===void 0&&(g=0),Jt(),g=ge[g];for(var w=Array(Math.floor(p.length/3)),S=g[64]||"",T=0,_=0;T<p.length-2;T+=3){var E=p[T],P=p[T+1],z=p[T+2],U=g[E>>2];E=g[(E&3)<<4|P>>4],P=g[(P&15)<<2|z>>6],z=g[z&63],w[_++]=U+E+P+z}switch(U=0,z=S,p.length-T){case 2:U=p[T+1],z=g[(U&15)<<2]||S;case 1:p=p[T],w[_]=g[p>>2]+g[(p&3)<<4|U>>4]+z+S}return w.join("")}for(g="";10240<p.length;)g+=String.fromCharCode.apply(null,p.subarray(0,10240)),p=p.subarray(10240);return g+=String.fromCharCode.apply(null,p),btoa(g)}var Da=RegExp("[-_.]","g");function Bf(p){switch(p){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function Pa(p){if(!gs)return Ae(p);Da.test(p)&&(p=p.replace(Da,Bf)),p=atob(p);for(var g=new Uint8Array(p.length),w=0;w<p.length;w++)g[w]=p.charCodeAt(w);return g}var Oa;function ko(){return Oa||(Oa=new Uint8Array(0))}var Rr={},Mf=typeof Uint8Array.prototype.slice=="function",Me=0,nt=0;function Fa(p){var g=0>p;p=Math.abs(p);var w=p>>>0;p=Math.floor((p-w)/4294967296),g&&(w=a(za(w,p)),g=w.next().value,p=w.next().value,w=g),Me=w>>>0,nt=p>>>0}var Vf=typeof BigInt=="function";function za(p,g){return g=~g,p?p=~p+1:g+=1,[p,g]}function La(p,g){this.i=p>>>0,this.h=g>>>0}function Ba(p){if(!p)return Ma||(Ma=new La(0,0));if(!/^-?\d+$/.test(p))return null;if(16>p.length)Fa(Number(p));else if(Vf)p=BigInt(p),Me=Number(p&BigInt(4294967295))>>>0,nt=Number(p>>BigInt(32)&BigInt(4294967295));else{var g=+(p[0]==="-");nt=Me=0;for(var w=p.length,S=g,T=(w-g)%6+g;T<=w;S=T,T+=6)S=Number(p.slice(S,T)),nt*=1e6,Me=1e6*Me+S,4294967296<=Me&&(nt+=Me/4294967296|0,Me%=4294967296);g&&(g=a(za(Me,nt)),p=g.next().value,g=g.next().value,Me=p,nt=g)}return new La(Me,nt)}var Ma;function Va(p,g){return Error("Invalid wire type: "+p+" (at position "+g+")")}function No(){return Error("Failed to read varint, encoding is invalid.")}function Wa(p,g){return Error("Tried to read past the end of the data "+g+" > "+p)}function Nn(){throw Error("Invalid UTF8")}function Ua(p,g){return g=String.fromCharCode.apply(null,g),p==null?g:p+g}var ys=void 0,$o,Wf=typeof TextDecoder<"u",Ga,Uf=typeof TextEncoder<"u",Ha;function ja(p){if(p!==Rr)throw Error("illegal external caller")}function Dr(p,g){if(ja(g),this.V=p,p!=null&&p.length===0)throw Error("ByteString should be constructed with non-empty values")}function To(){return Ha||(Ha=new Dr(null,Rr))}function qa(p){ja(Rr);var g=p.V;return g=g==null||Ar&&g!=null&&g instanceof Uint8Array?g:typeof g=="string"?Pa(g):null,g==null?g:p.V=g}function Gf(p){if(typeof p=="string")return{buffer:Pa(p),C:!1};if(Array.isArray(p))return{buffer:new Uint8Array(p),C:!1};if(p.constructor===Uint8Array)return{buffer:p,C:!1};if(p.constructor===ArrayBuffer)return{buffer:new Uint8Array(p),C:!1};if(p.constructor===Dr)return{buffer:qa(p)||ko(),C:!0};if(p instanceof Uint8Array)return{buffer:new Uint8Array(p.buffer,p.byteOffset,p.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}function Ka(p,g){this.i=null,this.m=!1,this.h=this.j=this.l=0,Eo(this,p,g)}function Eo(p,g,w){w=w===void 0?{}:w,p.S=w.S===void 0?!1:w.S,g&&(g=Gf(g),p.i=g.buffer,p.m=g.C,p.l=0,p.j=p.i.length,p.h=p.l)}Ka.prototype.reset=function(){this.h=this.l};function $n(p,g){if(p.h=g,g>p.j)throw Wa(p.j,g)}function Pr(p){var g=p.i,w=p.h,S=g[w++],T=S&127;if(S&128&&(S=g[w++],T|=(S&127)<<7,S&128&&(S=g[w++],T|=(S&127)<<14,S&128&&(S=g[w++],T|=(S&127)<<21,S&128&&(S=g[w++],T|=S<<28,S&128&&g[w++]&128&&g[w++]&128&&g[w++]&128&&g[w++]&128&&g[w++]&128)))))throw No();return $n(p,w),T}function Xa(p,g){if(0>g)throw Error("Tried to read a negative byte length: "+g);var w=p.h,S=w+g;if(S>p.j)throw Wa(g,p.j-w);return p.h=S,w}var Ya=[];function _o(){this.h=[]}_o.prototype.length=function(){return this.h.length},_o.prototype.end=function(){var p=this.h;return this.h=[],p};function Qa(p,g,w){for(;0<w||127<g;)p.h.push(g&127|128),g=(g>>>7|w<<25)>>>0,w>>>=7;p.h.push(g)}function Tn(p,g){for(;127<g;)p.h.push(g&127|128),g>>>=7;p.h.push(g)}function Ao(p,g){if(Ya.length){var w=Ya.pop();Eo(w,p,g),p=w}else p=new Ka(p,g);this.h=p,this.j=this.h.h,this.i=this.l=-1,this.setOptions(g)}Ao.prototype.setOptions=function(p){p=p===void 0?{}:p,this.ca=p.ca===void 0?!1:p.ca},Ao.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};function Za(p){var g=p.h;if(g.h==g.j)return!1;p.j=p.h.h;var w=Pr(p.h)>>>0;if(g=w>>>3,w&=7,!(0<=w&&5>=w))throw Va(w,p.j);if(1>g)throw Error("Invalid field number: "+g+" (at position "+p.j+")");return p.l=g,p.i=w,!0}function bs(p){switch(p.i){case 0:if(p.i!=0)bs(p);else e:{p=p.h;for(var g=p.h,w=g+10,S=p.i;g<w;)if(!(S[g++]&128)){$n(p,g);break e}throw No()}break;case 1:p=p.h,$n(p,p.h+8);break;case 2:p.i!=2?bs(p):(g=Pr(p.h)>>>0,p=p.h,$n(p,p.h+g));break;case 5:p=p.h,$n(p,p.h+4);break;case 3:g=p.l;do{if(!Za(p))throw Error("Unmatched start-group tag: stream EOF");if(p.i==4){if(p.l!=g)throw Error("Unmatched end-group tag");break}bs(p)}while(!0);break;default:throw Va(p.i,p.j)}}var ws=[];function Hf(){this.j=[],this.i=0,this.h=new _o}function ir(p,g){g.length!==0&&(p.j.push(g),p.i+=g.length)}function jf(p,g){if(g=g.R){ir(p,p.h.end());for(var w=0;w<g.length;w++)ir(p,qa(g[w])||ko())}}var en=typeof Symbol=="function"&&typeof Symbol()=="symbol"?Symbol():void 0;function En(p,g){return en?p[en]|=g:p.A!==void 0?p.A|=g:(Object.defineProperties(p,{A:{value:g,configurable:!0,writable:!0,enumerable:!1}}),g)}function Ja(p,g){en?p[en]&&(p[en]&=~g):p.A!==void 0&&(p.A&=~g)}function ze(p){var g;return en?g=p[en]:g=p.A,g??0}function Mt(p,g){en?p[en]=g:p.A!==void 0?p.A=g:Object.defineProperties(p,{A:{value:g,configurable:!0,writable:!0,enumerable:!1}})}function Ro(p){return En(p,1),p}function qf(p,g){Mt(g,(p|0)&-51)}function xs(p,g){Mt(g,(p|18)&-41)}var Do={};function vs(p){return p!==null&&typeof p=="object"&&!Array.isArray(p)&&p.constructor===Object}var Or,eu=[];Mt(eu,23),Or=Object.freeze(eu);function Po(p){if(ze(p.o)&2)throw Error("Cannot mutate an immutable Message")}function Oo(p){var g=p.length;(g=g?p[g-1]:void 0)&&vs(g)?g.g=1:(g={},p.push((g.g=1,g)))}function tu(p){var g=p.i+p.G;return p.B||(p.B=p.o[g]={})}function _t(p,g){return g===-1?null:g>=p.i?p.B?p.B[g]:void 0:p.o[g+p.G]}function Vt(p,g,w,S){Po(p),Fr(p,g,w,S)}function Fr(p,g,w,S){p.j&&(p.j=void 0),g>=p.i||S?tu(p)[g]=w:(p.o[g+p.G]=w,(p=p.B)&&g in p&&delete p[g])}function Fo(p,g,w,S){var T=_t(p,g);Array.isArray(T)||(T=Or);var _=ze(T);if(_&1||Ro(T),S)_&2||En(T,2),w&1||Object.freeze(T);else{S=!(w&2);var E=_&2;w&1||!E?S&&_&16&&!E&&Ja(T,16):(T=Ro(Array.prototype.slice.call(T)),Fr(p,g,T))}return T}function zo(p,g){var w=_t(p,g),S=w==null?w:typeof w=="number"||w==="NaN"||w==="Infinity"||w==="-Infinity"?Number(w):void 0;return S!=null&&S!==w&&Fr(p,g,S),S}function nu(p,g,w,S,T){p.h||(p.h={});var _=p.h[w],E=Fo(p,w,3,T);if(!_){var P=E;_=[];var z=!!(ze(p.o)&16);E=!!(ze(P)&2);var U=P;!T&&E&&(P=Array.prototype.slice.call(P));for(var X=E,ue=0;ue<P.length;ue++){var se=P[ue],Z=g,le=!1;if(le=le===void 0?!1:le,se=Array.isArray(se)?new Z(se):le?new Z:void 0,se!==void 0){Z=se.o;var me=le=ze(Z);E&&(me|=2),z&&(me|=16),me!=le&&Mt(Z,me),Z=me,X=X||!!(2&Z),_.push(se)}}return p.h[w]=_,z=ze(P),g=z|33,g=X?g&-9:g|8,z!=g&&(X=P,Object.isFrozen(X)&&(X=Array.prototype.slice.call(X)),Mt(X,g),P=X),U!==P&&Fr(p,w,P),(T||S&&E)&&En(_,2),S&&Object.freeze(_),_}return T||(T=Object.isFrozen(_),S&&!T?Object.freeze(_):!S&&T&&(_=Array.prototype.slice.call(_),p.h[w]=_)),_}function Ss(p,g,w){var S=!!(ze(p.o)&2);if(g=nu(p,g,w,S,S),p=Fo(p,w,3,S),!(S||ze(p)&8)){for(S=0;S<g.length;S++){if(w=g[S],ze(w.o)&2){var T=uu(w,!1);T.j=w}else T=w;w!==T&&(g[S]=T,p[S]=T.o)}En(p,8)}return g}function Wt(p,g,w){if(w!=null&&typeof w!="number")throw Error("Value of float/double field must be a number|null|undefined, found "+typeof w+": "+w);Vt(p,g,w)}function ru(p,g,w,S,T){Po(p);var _=nu(p,w,g,!1,!1);return w=S??new w,p=Fo(p,g,2,!1),T!=null?(_.splice(T,0,w),p.splice(T,0,w.o)):(_.push(w),p.push(w.o)),w.C()&&Ja(p,8),w}function Cs(p,g){return p??g}function Ut(p,g,w){return w=w===void 0?0:w,Cs(zo(p,g),w)}var Is;function Kf(p){switch(typeof p){case"number":return isFinite(p)?p:String(p);case"object":if(p)if(Array.isArray(p)){if(ze(p)&128)return p=Array.prototype.slice.call(p),Oo(p),p}else{if(Ar&&p!=null&&p instanceof Uint8Array)return Ra(p);if(p instanceof Dr){var g=p.V;return g==null?"":typeof g=="string"?g:p.V=Ra(g)}}}return p}function su(p,g,w,S){if(p!=null){if(Array.isArray(p))p=Lo(p,g,w,S!==void 0);else if(vs(p)){var T={},_;for(_ in p)T[_]=su(p[_],g,w,S);p=T}else p=g(p,S);return p}}function Lo(p,g,w,S){var T=ze(p);S=S?!!(T&16):void 0,p=Array.prototype.slice.call(p);for(var _=0;_<p.length;_++)p[_]=su(p[_],g,w,S);return w(T,p),p}function Xf(p){return p.ja===Do?p.toJSON():Kf(p)}function Yf(p,g){p&128&&Oo(g)}function ou(p,g,w){if(w=w===void 0?xs:w,p!=null){if(Ar&&p instanceof Uint8Array)return p.length?new Dr(new Uint8Array(p),Rr):To();if(Array.isArray(p)){var S=ze(p);return S&2?p:g&&!(S&32)&&(S&16||S===0)?(Mt(p,S|2),p):(p=Lo(p,ou,S&4?xs:w,!0),g=ze(p),g&4&&g&2&&Object.freeze(p),p)}return p.ja===Do?au(p):p}}function iu(p,g,w,S,T,_,E){if(p=p.h&&p.h[w]){if(S=ze(p),S&2?S=p:(_=Le(p,au),xs(S,_),Object.freeze(_),S=_),Po(g),E=S==null?Or:Ro([]),S!=null){for(_=!!S.length,p=0;p<S.length;p++){var P=S[p];_=_&&!(ze(P.o)&2),E[p]=P.o}_=(_?8:0)|1,p=ze(E),(p&_)!==_&&(Object.isFrozen(E)&&(E=Array.prototype.slice.call(E)),Mt(E,p|_)),g.h||(g.h={}),g.h[w]=S}else g.h&&(g.h[w]=void 0);Fr(g,w,E,T)}else Vt(g,w,ou(S,_,E),T)}function au(p){return ze(p.o)&2||(p=uu(p,!0),En(p.o,2)),p}function uu(p,g){var w=p.o,S=[];En(S,16);var T=p.constructor.h;if(T&&S.push(T),T=p.B,T){S.length=w.length,S.fill(void 0,S.length,w.length);var _={};S[S.length-1]=_}ze(w)&128&&Oo(S),g=g||p.C()?xs:qf,_=p.constructor,Is=S,S=new _(S),Is=void 0,p.R&&(S.R=p.R.slice()),_=!!(ze(w)&16);for(var E=T?w.length-1:w.length,P=0;P<E;P++)iu(p,S,P-p.G,w[P],!1,_,g);if(T)for(var z in T)iu(p,S,+z,T[z],!0,_,g);return S}function ut(p,g,w){p==null&&(p=Is),Is=void 0;var S=this.constructor.i||0,T=0<S,_=this.constructor.h,E=!1;if(p==null){p=_?[_]:[];var P=48,z=!0;T&&(S=0,P|=128),Mt(p,P)}else{if(!Array.isArray(p)||_&&_!==p[0])throw Error();var U=P=En(p,0);if((z=(16&U)!==0)&&((E=(32&U)!==0)||(U|=32)),T){if(128&U)S=0;else if(0<p.length){var X=p[p.length-1];if(vs(X)&&"g"in X){S=0,U|=128,delete X.g;var ue=!0,se;for(se in X){ue=!1;break}ue&&p.pop()}}}else if(128&U)throw Error();P!==U&&Mt(p,U)}this.G=(_?0:-1)-S,this.h=void 0,this.o=p;e:{if(_=this.o.length,S=_-1,_&&(_=this.o[S],vs(_))){this.B=_,this.i=S-this.G;break e}g!==void 0&&-1<g?(this.i=Math.max(g,S+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE}if(!T&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(w){g=z&&!E&&!0,T=this.i;var Z;for(z=0;z<w.length;z++)E=w[z],E<T?(E+=this.G,(S=p[E])?lu(S,g):p[E]=Or):(Z||(Z=tu(this)),(S=Z[E])?lu(S,g):Z[E]=Or)}}ut.prototype.toJSON=function(){return Lo(this.o,Xf,Yf)},ut.prototype.C=function(){return!!(ze(this.o)&2)};function lu(p,g){if(Array.isArray(p)){var w=ze(p),S=1;!g||w&2||(S|=16),(w&S)!==S&&Mt(p,w|S)}}ut.prototype.ja=Do,ut.prototype.toString=function(){return this.o.toString()};function cu(p,g,w){if(w){var S={},T;for(T in w){var _=w[T],E=_.qa;E||(S.J=_.wa||_.oa.W,_.ia?(S.aa=mu(_.ia),E=function(P){return function(z,U,X){return P.J(z,U,X,P.aa)}}(S)):_.ka?(S.Z=gu(_.da.P,_.ka),E=function(P){return function(z,U,X){return P.J(z,U,X,P.Z)}}(S)):E=S.J,_.qa=E),E(g,p,_.da),S={J:S.J,aa:S.aa,Z:S.Z}}}jf(g,p)}var ks=Symbol();function hu(p,g,w){return p[ks]||(p[ks]=function(S,T){return g(S,T,w)})}function du(p){var g=p[ks];if(!g){var w=Mo(p);g=function(S,T){return yu(S,T,w)},p[ks]=g}return g}function Qf(p){var g=p.ia;if(g)return du(g);if(g=p.va)return hu(p.da.P,g,p.ka)}function Zf(p){var g=Qf(p),w=p.da,S=p.oa.U;return g?function(T,_){return S(T,_,w,g)}:function(T,_){return S(T,_,w)}}function pu(p,g){var w=p[g];return typeof w=="function"&&w.length===0&&(w=w(),p[g]=w),Array.isArray(w)&&(Lr in w||zr in w||0<w.length&&typeof w[0]=="function")?w:void 0}function fu(p,g,w,S,T,_){g.P=p[0];var E=1;if(p.length>E&&typeof p[E]!="number"){var P=p[E++];w(g,P)}for(;E<p.length;){w=p[E++];for(var z=E+1;z<p.length&&typeof p[z]!="number";)z++;switch(P=p[E++],z-=E,z){case 0:S(g,w,P);break;case 1:(z=pu(p,E))?(E++,T(g,w,P,z)):S(g,w,P,p[E++]);break;case 2:z=E++,z=pu(p,z),T(g,w,P,z,p[E++]);break;case 3:_(g,w,P,p[E++],p[E++],p[E++]);break;case 4:_(g,w,P,p[E++],p[E++],p[E++],p[E++]);break;default:throw Error("unexpected number of binary field arguments: "+z)}}return g}var Ns=Symbol();function mu(p){var g=p[Ns];if(!g){var w=Bo(p);g=function(S,T){return bu(S,T,w)},p[Ns]=g}return g}function gu(p,g){var w=p[Ns];return w||(w=function(S,T){return cu(S,T,g)},p[Ns]=w),w}var zr=Symbol();function Jf(p,g){p.push(g)}function em(p,g,w){p.push(g,w.W)}function tm(p,g,w,S){var T=mu(S),_=Bo(S).P,E=w.W;p.push(g,function(P,z,U){return E(P,z,U,_,T)})}function nm(p,g,w,S,T,_){var E=gu(S,_),P=w.W;p.push(g,function(z,U,X){return P(z,U,X,S,E)})}function Bo(p){var g=p[zr];return g||(g=fu(p,p[zr]=[],Jf,em,tm,nm),Lr in p&&zr in p&&(p.length=0),g)}var Lr=Symbol();function rm(p,g){p[0]=g}function sm(p,g,w,S){var T=w.U;p[g]=S?function(_,E,P){return T(_,E,P,S)}:T}function om(p,g,w,S,T){var _=w.U,E=du(S),P=Mo(S).P;p[g]=function(z,U,X){return _(z,U,X,P,E,T)}}function im(p,g,w,S,T,_,E){var P=w.U,z=hu(S,T,_);p[g]=function(U,X,ue){return P(U,X,ue,S,z,E)}}function Mo(p){var g=p[Lr];return g||(g=fu(p,p[Lr]={},rm,sm,om,im),Lr in p&&zr in p&&(p.length=0),g)}function yu(p,g,w){for(;Za(g)&&g.i!=4;){var S=g.l,T=w[S];if(!T){var _=w[0];_&&(_=_[S])&&(T=w[S]=Zf(_))}if(!T||!T(g,p,S)){T=g,S=p,_=T.j,bs(T);var E=T;if(!E.ca){if(T=E.h.h-_,E.h.h=_,E=E.h,T==0)T=To();else{if(_=Xa(E,T),E.S&&E.m)T=E.i.subarray(_,_+T);else{E=E.i;var P=_;T=_+T,T=P===T?ko():Mf?E.slice(P,T):new Uint8Array(E.subarray(P,T))}T=T.length==0?To():new Dr(T,Rr)}(_=S.R)?_.push(T):S.R=[T]}}}return p}function bu(p,g,w){for(var S=w.length,T=S%2==1,_=T?1:0;_<S;_+=2)(0,w[_+1])(g,p,w[_]);cu(p,g,T?w[0]:void 0)}function Br(p,g){return{U:p,W:g}}var At=Br(function(p,g,w){if(p.i!==5)return!1;p=p.h;var S=p.i,T=p.h,_=S[T],E=S[T+1],P=S[T+2];return S=S[T+3],$n(p,p.h+4),E=(_<<0|E<<8|P<<16|S<<24)>>>0,p=2*(E>>31)+1,_=E>>>23&255,E&=8388607,Vt(g,w,_==255?E?NaN:1/0*p:_==0?p*Math.pow(2,-149)*E:p*Math.pow(2,_-150)*(E+Math.pow(2,23))),!0},function(p,g,w){if(g=zo(g,w),g!=null){Tn(p.h,8*w+5),p=p.h;var S=+g;S===0?0<1/S?Me=nt=0:(nt=0,Me=2147483648):isNaN(S)?(nt=0,Me=2147483647):(S=(w=0>S?-2147483648:0)?-S:S,34028234663852886e22<S?(nt=0,Me=(w|2139095040)>>>0):11754943508222875e-54>S?(S=Math.round(S/Math.pow(2,-149)),nt=0,Me=(w|S)>>>0):(g=Math.floor(Math.log(S)/Math.LN2),S*=Math.pow(2,-g),S=Math.round(8388608*S),16777216<=S&&++g,nt=0,Me=(w|g+127<<23|S&8388607)>>>0)),w=Me,p.h.push(w>>>0&255),p.h.push(w>>>8&255),p.h.push(w>>>16&255),p.h.push(w>>>24&255)}}),am=Br(function(p,g,w){if(p.i!==0)return!1;var S=p.h,T=0,_=p=0,E=S.i,P=S.h;do{var z=E[P++];T|=(z&127)<<_,_+=7}while(32>_&&z&128);for(32<_&&(p|=(z&127)>>4),_=3;32>_&&z&128;_+=7)z=E[P++],p|=(z&127)<<_;if($n(S,P),128>z)S=T>>>0,z=p>>>0,(p=z&2147483648)&&(S=~S+1>>>0,z=~z>>>0,S==0&&(z=z+1>>>0)),S=4294967296*z+(S>>>0);else throw No();return Vt(g,w,p?-S:S),!0},function(p,g,w){g=_t(g,w),g!=null&&(typeof g=="string"&&Ba(g),g!=null&&(Tn(p.h,8*w),typeof g=="number"?(p=p.h,Fa(g),Qa(p,Me,nt)):(w=Ba(g),Qa(p.h,w.i,w.h))))}),um=Br(function(p,g,w){return p.i!==0?!1:(Vt(g,w,Pr(p.h)),!0)},function(p,g,w){if(g=_t(g,w),g!=null&&g!=null)if(Tn(p.h,8*w),p=p.h,w=g,0<=w)Tn(p,w);else{for(g=0;9>g;g++)p.h.push(w&127|128),w>>=7;p.h.push(1)}}),wu=Br(function(p,g,w){if(p.i!==2)return!1;var S=Pr(p.h)>>>0;p=p.h;var T=Xa(p,S);if(p=p.i,Wf){var _=p,E;(E=$o)||(E=$o=new TextDecoder("utf-8",{fatal:!0})),p=T+S,_=T===0&&p===_.length?_:_.subarray(T,p);try{var P=E.decode(_)}catch(ue){if(ys===void 0){try{E.decode(new Uint8Array([128]))}catch{}try{E.decode(new Uint8Array([97])),ys=!0}catch{ys=!1}}throw!ys&&($o=void 0),ue}}else{P=T,S=P+S,T=[];for(var z=null,U,X;P<S;)U=p[P++],128>U?T.push(U):224>U?P>=S?Nn():(X=p[P++],194>U||(X&192)!==128?(P--,Nn()):T.push((U&31)<<6|X&63)):240>U?P>=S-1?Nn():(X=p[P++],(X&192)!==128||U===224&&160>X||U===237&&160<=X||((_=p[P++])&192)!==128?(P--,Nn()):T.push((U&15)<<12|(X&63)<<6|_&63)):244>=U?P>=S-2?Nn():(X=p[P++],(X&192)!==128||(U<<28)+(X-144)>>30||((_=p[P++])&192)!==128||((E=p[P++])&192)!==128?(P--,Nn()):(U=(U&7)<<18|(X&63)<<12|(_&63)<<6|E&63,U-=65536,T.push((U>>10&1023)+55296,(U&1023)+56320))):Nn(),8192<=T.length&&(z=Ua(z,T),T.length=0);P=Ua(z,T)}return Vt(g,w,P),!0},function(p,g,w){if(g=_t(g,w),g!=null){var S=!1;if(S=S===void 0?!1:S,Uf){if(S&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(g))throw Error("Found an unpaired surrogate");g=(Ga||(Ga=new TextEncoder)).encode(g)}else{for(var T=0,_=new Uint8Array(3*g.length),E=0;E<g.length;E++){var P=g.charCodeAt(E);if(128>P)_[T++]=P;else{if(2048>P)_[T++]=P>>6|192;else{if(55296<=P&&57343>=P){if(56319>=P&&E<g.length){var z=g.charCodeAt(++E);if(56320<=z&&57343>=z){P=1024*(P-55296)+z-56320+65536,_[T++]=P>>18|240,_[T++]=P>>12&63|128,_[T++]=P>>6&63|128,_[T++]=P&63|128;continue}else E--}if(S)throw Error("Found an unpaired surrogate");P=65533}_[T++]=P>>12|224,_[T++]=P>>6&63|128}_[T++]=P&63|128}}g=T===_.length?_:_.subarray(0,T)}Tn(p.h,8*w+2),Tn(p.h,g.length),ir(p,p.h.end()),ir(p,g)}}),xu=Br(function(p,g,w,S,T){if(p.i!==2)return!1;g=ru(g,w,S),w=p.h.j,S=Pr(p.h)>>>0;var _=p.h.h+S,E=_-w;if(0>=E&&(p.h.j=_,T(g,p,void 0,void 0,void 0),E=_-p.h.h),E)throw Error("Message parsing ended unexpectedly. Expected to read "+(S+" bytes, instead read "+(S-E)+" bytes, either the data ended unexpectedly or the message misreported its own length"));return p.h.h=_,p.h.j=w,!0},function(p,g,w,S,T){if(g=Ss(g,S,w),g!=null)for(S=0;S<g.length;S++){var _=p;Tn(_.h,8*w+2);var E=_.h.end();ir(_,E),E.push(_.i),_=E,T(g[S],p),E=p;var P=_.pop();for(P=E.i+E.h.length()-P;127<P;)_.push(P&127|128),P>>>=7,E.i++;_.push(P),E.i++}});function Vo(p){return function(g,w){e:{if(ws.length){var S=ws.pop();S.setOptions(w),Eo(S.h,g,w),g=S}else g=new Ao(g,w);try{var T=Mo(p),_=yu(new T.P,g,T);break e}finally{T=g.h,T.i=null,T.m=!1,T.l=0,T.j=0,T.h=0,T.S=!1,g.l=-1,g.i=-1,100>ws.length&&ws.push(g)}_=void 0}return _}}function Wo(p){return function(){var g=new Hf;bu(this,g,Bo(p)),ir(g,g.h.end());for(var w=new Uint8Array(g.i),S=g.j,T=S.length,_=0,E=0;E<T;E++){var P=S[E];w.set(P,_),_+=P.length}return g.j=[w],w}}function ar(p){ut.call(this,p)}b(ar,ut);var vu=[ar,1,um,2,At,3,wu,4,wu];ar.prototype.l=Wo(vu);function Uo(p){ut.call(this,p,-1,lm)}b(Uo,ut),Uo.prototype.addClassification=function(p,g){return ru(this,1,ar,p,g),this};var lm=[1],Su=Vo([Uo,1,xu,vu]);function ur(p){ut.call(this,p)}b(ur,ut);var Cu=[ur,1,At,2,At,3,At,4,At,5,At];ur.prototype.l=Wo(Cu);function Iu(p){ut.call(this,p,-1,cm)}b(Iu,ut);var cm=[1],ku=Vo([Iu,1,xu,Cu]);function $s(p){ut.call(this,p)}b($s,ut);var Nu=[$s,1,At,2,At,3,At,4,At,5,At,6,am],hm=Vo(Nu);$s.prototype.l=Wo(Nu);function $u(p,g,w){if(w=p.createShader(w===0?p.VERTEX_SHADER:p.FRAGMENT_SHADER),p.shaderSource(w,g),p.compileShader(w),!p.getShaderParameter(w,p.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+p.getShaderInfoLog(w));return w}function Tu(p){return Ss(p,ar,1).map(function(g){var w=_t(g,1);return{index:w??0,score:Ut(g,2),label:_t(g,3)!=null?Cs(_t(g,3),""):void 0,displayName:_t(g,4)!=null?Cs(_t(g,4),""):void 0}})}function Eu(p){return{x:Ut(p,1),y:Ut(p,2),z:Ut(p,3),visibility:zo(p,4)!=null?Ut(p,4):void 0}}function _u(p){return p.map(function(g){return Ss(ku(g),ur,1).map(Eu)})}function Go(p,g){this.i=p,this.h=g,this.m=0}function Au(p,g,w){return dm(p,g),typeof p.h.canvas.transferToImageBitmap=="function"?Promise.resolve(p.h.canvas.transferToImageBitmap()):w?Promise.resolve(p.h.canvas):typeof createImageBitmap=="function"?createImageBitmap(p.h.canvas):(p.j===void 0&&(p.j=document.createElement("canvas")),new Promise(function(S){p.j.height=p.h.canvas.height,p.j.width=p.h.canvas.width,p.j.getContext("2d",{}).drawImage(p.h.canvas,0,0,p.h.canvas.width,p.h.canvas.height),S(p.j)}))}function dm(p,g){var w=p.h;if(p.s===void 0){var S=$u(w,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),T=$u(w,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),_=w.createProgram();if(w.attachShader(_,S),w.attachShader(_,T),w.linkProgram(_),!w.getProgramParameter(_,w.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+w.getProgramInfoLog(_));S=p.s=_,w.useProgram(S),T=w.getUniformLocation(S,"sampler0"),p.l={O:w.getAttribLocation(S,"aVertex"),N:w.getAttribLocation(S,"aTex"),xa:T},p.v=w.createBuffer(),w.bindBuffer(w.ARRAY_BUFFER,p.v),w.enableVertexAttribArray(p.l.O),w.vertexAttribPointer(p.l.O,2,w.FLOAT,!1,0,0),w.bufferData(w.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),w.STATIC_DRAW),w.bindBuffer(w.ARRAY_BUFFER,null),p.u=w.createBuffer(),w.bindBuffer(w.ARRAY_BUFFER,p.u),w.enableVertexAttribArray(p.l.N),w.vertexAttribPointer(p.l.N,2,w.FLOAT,!1,0,0),w.bufferData(w.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),w.STATIC_DRAW),w.bindBuffer(w.ARRAY_BUFFER,null),w.uniform1i(T,0)}S=p.l,w.useProgram(p.s),w.canvas.width=g.width,w.canvas.height=g.height,w.viewport(0,0,g.width,g.height),w.activeTexture(w.TEXTURE0),p.i.bindTexture2d(g.glName),w.enableVertexAttribArray(S.O),w.bindBuffer(w.ARRAY_BUFFER,p.v),w.vertexAttribPointer(S.O,2,w.FLOAT,!1,0,0),w.enableVertexAttribArray(S.N),w.bindBuffer(w.ARRAY_BUFFER,p.u),w.vertexAttribPointer(S.N,2,w.FLOAT,!1,0,0),w.bindFramebuffer(w.DRAW_FRAMEBUFFER?w.DRAW_FRAMEBUFFER:w.FRAMEBUFFER,null),w.clearColor(0,0,0,0),w.clear(w.COLOR_BUFFER_BIT),w.colorMask(!0,!0,!0,!0),w.drawArrays(w.TRIANGLE_FAN,0,4),w.disableVertexAttribArray(S.O),w.disableVertexAttribArray(S.N),w.bindBuffer(w.ARRAY_BUFFER,null),p.i.bindTexture2d(0)}function pm(p){this.h=p}var fm=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function mm(p,g){return g+p}function Ru(p,g){window[p]=g}function gm(p){var g=document.createElement("script");return g.setAttribute("src",p),g.setAttribute("crossorigin","anonymous"),new Promise(function(w){g.addEventListener("load",function(){w()},!1),g.addEventListener("error",function(){w()},!1),document.body.appendChild(g)})}function ym(){return V(function(p){switch(p.h){case 1:return p.s=2,N(p,WebAssembly.instantiate(fm),4);case 4:p.h=3,p.s=0;break;case 2:return p.s=0,p.l=null,p.return(!1);case 3:return p.return(!0)}})}function Ho(p){if(this.h=p,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=p&&p.locateFile||mm,typeof window=="object")var g=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location<"u")g=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.ha=g,p.options){g=a(Object.keys(p.options));for(var w=g.next();!w.done;w=g.next()){w=w.value;var S=p.options[w].default;S!==void 0&&(this.l[w]=typeof S=="function"?S():S)}}}n=Ho.prototype,n.close=function(){return this.j&&this.j.delete(),Promise.resolve()};function bm(p){var g,w,S,T,_,E,P,z,U,X,ue;return V(function(se){switch(se.h){case 1:return p.ga?(g=p.h.files===void 0?[]:typeof p.h.files=="function"?p.h.files(p.l):p.h.files,N(se,ym(),2)):se.return();case 2:if(w=se.i,typeof window=="object")return Ru("createMediapipeSolutionsWasm",{locateFile:p.locateFile}),Ru("createMediapipeSolutionsPackedAssets",{locateFile:p.locateFile}),E=g.filter(function(Z){return Z.data!==void 0}),P=g.filter(function(Z){return Z.data===void 0}),z=Promise.all(E.map(function(Z){var le=Ts(p,Z.url);if(Z.path!==void 0){var me=Z.path;le=le.then(function(_e){return p.overrideFile(me,_e),Promise.resolve(_e)})}return le})),U=Promise.all(P.map(function(Z){return Z.simd===void 0||Z.simd&&w||!Z.simd&&!w?gm(p.locateFile(Z.url,p.ha)):Promise.resolve()})).then(function(){var Z,le,me;return V(function(_e){if(_e.h==1)return Z=window.createMediapipeSolutionsWasm,le=window.createMediapipeSolutionsPackedAssets,me=p,N(_e,Z(le),2);me.i=_e.i,_e.h=0})}),X=function(){return V(function(Z){return p.h.graph&&p.h.graph.url?Z=N(Z,Ts(p,p.h.graph.url),0):(Z.h=0,Z=void 0),Z})}(),N(se,Promise.all([U,z,X]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return S=g.filter(function(Z){return Z.simd===void 0||Z.simd&&w||!Z.simd&&!w}).map(function(Z){return p.locateFile(Z.url,p.ha)}),importScripts.apply(null,u(S)),T=p,N(se,createMediapipeSolutionsWasm(Module),6);case 6:T.i=se.i,p.m=new OffscreenCanvas(1,1),p.i.canvas=p.m,_=p.i.GL.createContext(p.m,{antialias:!1,alpha:!1,ua:typeof WebGL2RenderingContext<"u"?2:1}),p.i.GL.makeContextCurrent(_),se.h=4;break;case 7:if(p.m=document.createElement("canvas"),ue=p.m.getContext("webgl2",{}),!ue&&(ue=p.m.getContext("webgl",{}),!ue))return alert("Failed to create WebGL canvas context when passing video frame."),se.return();p.K=ue,p.i.canvas=p.m,p.i.createContext(p.m,!0,!0,{});case 4:p.j=new p.i.SolutionWasm,p.ga=!1,se.h=0}})}function wm(p){var g,w,S,T,_,E,P,z;return V(function(U){if(U.h==1){if(p.h.graph&&p.h.graph.url&&p.fa===p.h.graph.url)return U.return();if(p.u=!0,!p.h.graph||!p.h.graph.url){U.h=2;return}return p.fa=p.h.graph.url,N(U,Ts(p,p.h.graph.url),3)}for(U.h!=2&&(g=U.i,p.j.loadGraph(g)),w=a(Object.keys(p.D)),S=w.next();!S.done;S=w.next())T=S.value,p.j.overrideFile(T,p.D[T]);if(p.D={},p.h.listeners)for(_=a(p.h.listeners),E=_.next();!E.done;E=_.next())P=E.value,Cm(p,P);z=p.l,p.l={},p.setOptions(z),U.h=0})}n.reset=function(){var p=this;return V(function(g){p.j&&(p.j.reset(),p.s={},p.v={}),g.h=0})},n.setOptions=function(p,g){var w=this;if(g=g||this.h.options){for(var S=[],T=[],_={},E=a(Object.keys(p)),P=E.next();!P.done;_={X:_.X,Y:_.Y},P=E.next())if(P=P.value,!(P in this.l&&this.l[P]===p[P])){this.l[P]=p[P];var z=g[P];z!==void 0&&(z.onChange&&(_.X=z.onChange,_.Y=p[P],S.push(function(U){return function(){var X;return V(function(ue){if(ue.h==1)return N(ue,U.X(U.Y),2);X=ue.i,X===!0&&(w.u=!0),ue.h=0})}}(_))),z.graphOptionXref&&(P=Object.assign({},{calculatorName:"",calculatorIndex:0},z.graphOptionXref,{valueNumber:z.type===1?p[P]:0,valueBoolean:z.type===0?p[P]:!1,valueString:z.type===2?p[P]:""}),T.push(P)))}(S.length!==0||T.length!==0)&&(this.u=!0,this.H=(this.H===void 0?[]:this.H).concat(T),this.F=(this.F===void 0?[]:this.F).concat(S))}};function xm(p){var g,w,S,T,_,E,P;return V(function(z){switch(z.h){case 1:if(!p.u)return z.return();if(!p.F){z.h=2;break}g=a(p.F),w=g.next();case 3:if(w.done){z.h=5;break}return S=w.value,N(z,S(),4);case 4:w=g.next(),z.h=3;break;case 5:p.F=void 0;case 2:if(p.H){for(T=new p.i.GraphOptionChangeRequestList,_=a(p.H),E=_.next();!E.done;E=_.next())P=E.value,T.push_back(P);p.j.changeOptions(T),T.delete(),p.H=void 0}p.u=!1,z.h=0}})}n.initialize=function(){var p=this;return V(function(g){return g.h==1?N(g,bm(p),2):g.h!=3?N(g,wm(p),3):N(g,xm(p),0)})};function Ts(p,g){var w,S;return V(function(T){return g in p.L?T.return(p.L[g]):(w=p.locateFile(g,""),S=fetch(w).then(function(_){return _.arrayBuffer()}),p.L[g]=S,T.return(S))})}n.overrideFile=function(p,g){this.j?this.j.overrideFile(p,g):this.D[p]=g},n.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},n.send=function(p,g){var w=this,S,T,_,E,P,z,U,X,ue;return V(function(se){switch(se.h){case 1:return w.h.inputs?(S=1e3*(g??performance.now()),N(se,w.I,2)):se.return();case 2:return N(se,w.initialize(),3);case 3:for(T=new w.i.PacketDataList,_=a(Object.keys(p)),E=_.next();!E.done;E=_.next())if(P=E.value,z=w.h.inputs[P]){e:{var Z=p[P];switch(z.type){case"video":var le=w.s[z.stream];if(le||(le=new Go(w.i,w.K),w.s[z.stream]=le),le.m===0&&(le.m=le.i.createTexture()),typeof HTMLVideoElement<"u"&&Z instanceof HTMLVideoElement)var me=Z.videoWidth,_e=Z.videoHeight;else typeof HTMLImageElement<"u"&&Z instanceof HTMLImageElement?(me=Z.naturalWidth,_e=Z.naturalHeight):(me=Z.width,_e=Z.height);_e={glName:le.m,width:me,height:_e},me=le.h,me.canvas.width=_e.width,me.canvas.height=_e.height,me.activeTexture(me.TEXTURE0),le.i.bindTexture2d(le.m),me.texImage2D(me.TEXTURE_2D,0,me.RGBA,me.RGBA,me.UNSIGNED_BYTE,Z),le.i.bindTexture2d(0),le=_e;break e;case"detections":for(le=w.s[z.stream],le||(le=new pm(w.i),w.s[z.stream]=le),le.data||(le.data=new le.h.DetectionListData),le.data.reset(Z.length),_e=0;_e<Z.length;++_e){me=Z[_e];var ke=le.data,Ke=ke.setBoundingBox,vt=_e,lt=me.la,ve=new $s;if(Wt(ve,1,lt.ra),Wt(ve,2,lt.sa),Wt(ve,3,lt.height),Wt(ve,4,lt.width),Wt(ve,5,lt.rotation),Vt(ve,6,lt.pa),lt=ve.l(),Ke.call(ke,vt,lt),me.ea)for(ke=0;ke<me.ea.length;++ke){ve=me.ea[ke],Ke=le.data,vt=Ke.addNormalizedLandmark,lt=_e,ve=Object.assign({},ve,{visibility:ve.visibility?ve.visibility:0});var Xe=new ur;Wt(Xe,1,ve.x),Wt(Xe,2,ve.y),Wt(Xe,3,ve.z),ve.visibility&&Wt(Xe,4,ve.visibility),ve=Xe.l(),vt.call(Ke,lt,ve)}if(me.ba)for(ke=0;ke<me.ba.length;++ke)Ke=le.data,vt=Ke.addClassification,lt=_e,ve=me.ba[ke],Xe=new ar,Wt(Xe,2,ve.score),ve.index&&Vt(Xe,1,ve.index),ve.label&&Vt(Xe,3,ve.label),ve.displayName&&Vt(Xe,4,ve.displayName),ve=Xe.l(),vt.call(Ke,lt,ve)}le=le.data;break e;default:le={}}}switch(U=le,X=z.stream,z.type){case"video":T.pushTexture2d(Object.assign({},U,{stream:X,timestamp:S}));break;case"detections":ue=U,ue.stream=X,ue.timestamp=S,T.pushDetectionList(ue);break;default:throw Error("Unknown input config type: '"+z.type+"'")}}return w.j.send(T),N(se,w.I,4);case 4:T.delete(),se.h=0}})};function vm(p,g,w){var S,T,_,E,P,z,U,X,ue,se,Z,le,me,_e;return V(function(ke){switch(ke.h){case 1:if(!w)return ke.return(g);for(S={},T=0,_=a(Object.keys(w)),E=_.next();!E.done;E=_.next())P=E.value,z=w[P],typeof z!="string"&&z.type==="texture"&&g[z.stream]!==void 0&&++T;1<T&&(p.M=!1),U=a(Object.keys(w)),E=U.next();case 2:if(E.done){ke.h=4;break}if(X=E.value,ue=w[X],typeof ue=="string")return me=S,_e=X,N(ke,Sm(p,X,g[ue]),14);if(se=g[ue.stream],ue.type==="detection_list"){if(se){for(var Ke=se.getRectList(),vt=se.getLandmarksList(),lt=se.getClassificationsList(),ve=[],Xe=0;Xe<Ke.size();++Xe){var fn=hm(Ke.get(Xe)),Im=Ut(fn,1),km=Ut(fn,2),Nm=Ut(fn,3),$m=Ut(fn,4),Tm=Ut(fn,5,0),Es=void 0;Es=Es===void 0?0:Es,fn={la:{ra:Im,sa:km,height:Nm,width:$m,rotation:Tm,pa:Cs(_t(fn,6),Es)},ea:Ss(ku(vt.get(Xe)),ur,1).map(Eu),ba:Tu(Su(lt.get(Xe)))},ve.push(fn)}Ke=ve}else Ke=[];S[X]=Ke,ke.h=7;break}if(ue.type==="proto_list"){if(se){for(Ke=Array(se.size()),vt=0;vt<se.size();vt++)Ke[vt]=se.get(vt);se.delete()}else Ke=[];S[X]=Ke,ke.h=7;break}if(se===void 0){ke.h=3;break}if(ue.type==="float_list"){S[X]=se,ke.h=7;break}if(ue.type==="proto"){S[X]=se,ke.h=7;break}if(ue.type!=="texture")throw Error("Unknown output config type: '"+ue.type+"'");return Z=p.v[X],Z||(Z=new Go(p.i,p.K),p.v[X]=Z),N(ke,Au(Z,se,p.M),13);case 13:le=ke.i,S[X]=le;case 7:ue.transform&&S[X]&&(S[X]=ue.transform(S[X])),ke.h=3;break;case 14:me[_e]=ke.i;case 3:E=U.next(),ke.h=2;break;case 4:return ke.return(S)}})}function Sm(p,g,w){var S;return V(function(T){return typeof w=="number"||w instanceof Uint8Array||w instanceof p.i.Uint8BlobList?T.return(w):w instanceof p.i.Texture2dDataOut?(S=p.v[g],S||(S=new Go(p.i,p.K),p.v[g]=S),T.return(Au(S,w,p.M))):T.return(void 0)})}function Cm(p,g){for(var w=g.name||"$",S=[].concat(u(g.wants)),T=new p.i.StringList,_=a(g.wants),E=_.next();!E.done;E=_.next())T.push_back(E.value);_=p.i.PacketListener.implement({onResults:function(P){for(var z={},U=0;U<g.wants.length;++U)z[S[U]]=P.get(U);var X=p.listeners[w];X&&(p.I=vm(p,z,g.outs).then(function(ue){ue=X(ue);for(var se=0;se<g.wants.length;++se){var Z=z[S[se]];typeof Z=="object"&&Z.hasOwnProperty&&Z.hasOwnProperty("delete")&&Z.delete()}ue&&(p.I=ue)}))}}),p.j.attachMultiListener(T,_),T.delete()}n.onResults=function(p,g){this.listeners[g||"$"]=p},re("Solution",Ho),re("OptionType",{BOOL:0,NUMBER:1,ta:2,0:"BOOL",1:"NUMBER",2:"STRING"});function Du(p){return p===void 0&&(p=0),p===1?"hand_landmark_full.tflite":"hand_landmark_lite.tflite"}function Pu(p){var g=this;p=p||{},this.h=new Ho({locateFile:p.locateFile,files:function(w){return[{url:"hands_solution_packed_assets_loader.js"},{simd:!1,url:"hands_solution_wasm_bin.js"},{simd:!0,url:"hands_solution_simd_wasm_bin.js"},{data:!0,url:Du(w.modelComplexity)}]},graph:{url:"hands.binarypb"},inputs:{image:{type:"video",stream:"input_frames_gpu"}},listeners:[{wants:["multi_hand_landmarks","multi_hand_world_landmarks","image_transformed","multi_handedness"],outs:{image:"image_transformed",multiHandLandmarks:{type:"proto_list",stream:"multi_hand_landmarks",transform:_u},multiHandWorldLandmarks:{type:"proto_list",stream:"multi_hand_world_landmarks",transform:_u},multiHandedness:{type:"proto_list",stream:"multi_handedness",transform:function(w){return w.map(function(S){return Tu(Su(S))[0]})}}}}],options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:typeof window!="object"||window.navigator===void 0?!1:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},maxNumHands:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculator",fieldName:"int_value"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(w){var S,T,_;return V(function(E){return E.h==1?(S=Du(w),T="third_party/mediapipe/modules/hand_landmark/"+S,N(E,Ts(g.h,S),2)):(_=E.i,g.h.overrideFile(T,_),E.return(!0))})}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"handlandmarktrackinggpu__palmdetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"handlandmarktrackinggpu__handlandmarkgpu__ThresholdingCalculator",fieldName:"threshold"}}}})}n=Pu.prototype,n.close=function(){return this.h.close(),Promise.resolve()},n.onResults=function(p){this.h.onResults(p)},n.initialize=function(){var p=this;return V(function(g){return N(g,p.h.initialize(),0)})},n.reset=function(){this.h.reset()},n.send=function(p){var g=this;return V(function(w){return N(w,g.h.send(p),0)})},n.setOptions=function(p){this.h.setOptions(p)},re("Hands",Pu),re("HAND_CONNECTIONS",[[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[0,17],[17,18],[18,19],[19,20]]),re("VERSION","0.4.1675469240")}).call(Kt);var HD=Hands;/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jD=oe();jD.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var ht;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(ht||(ht={}));var Nl;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(Nl||(Nl={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qD={};function Pf(n){return qD[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y(n,e,t,r,s){const o=e.inputParams[n];if(o&&o.inputIndexStart!==void 0){const a=o.inputIndexStart,u=o.inputIndexEnd===0?void 0:o.inputIndexEnd===void 0?a+1:o.inputIndexEnd,l=a<0?e.inputNames.length+a:a;if(o.type==="tensor")return He(e.inputNames[l],t,r,s);if(o.type==="tensors"){const d=e.inputs.slice(a,u);return e.inputNames.slice(a,u).filter((m,x)=>{var b;return((b=d[x])===null||b===void 0?void 0:b.op)!=="NoOp"}).map(m=>He(m,t,r,s))}const h=He(e.inputNames[l],t,r,s),c=h.dataSync();return o.type==="number"?c[0]:li(h.shape,c)}const i=e.attrParams[n];return i&&i.value}function He(n,e,t,r){const[s,o]=dt(n,t);if(r!=null){const a=r.getHashTableHandleByName(s);if(a!=null)return a}const i=t.currentContextIds.find(a=>!!e[to(s,a)]);return i!==void 0?e[to(s,i)][o]:void 0}function $l(n,e,t){return e[to(n,t.currentContextId)]}function tn(n,e){const[t,r,s]=dt(n,e);return[to(t,e&&e.currentContextId),r,s]}function to(n,e){return e?`${n}-${e}`:n}function dt(n,e){if(n==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const o=e.parseNodeNameCache.get(n);if(o!=null)return o}const r=n.split(":");let s;if(r.length===1)s=[n,0,void 0];else{const o=r[0],i=r.length===3?r[1]:void 0,a=Number(r[r.length-1]);s=[o,a,i]}return t&&e.parseNodeNameCache.set(n,s),s}function Ls(n,e,t){let r=y("pad",n,e,t);if(r==="explicit"){r=y("explicitPaddings",n,e,t);const s=[[0,0],[0,0],[0,0],[0,0]];for(let o=0;o<4;o++)s[o][0]=r[o*2],s[o][1]=r[o*2+1];return s}return r}function nn(n){return n.kept?n:yn(n)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KD=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],XD=Object.freeze(Object.defineProperty({__proto__:null,json:KD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YD=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],QD=Object.freeze(Object.defineProperty({__proto__:null,json:YD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZD=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],JD=Object.freeze(Object.defineProperty({__proto__:null,json:ZD},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eP=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],tP=Object.freeze(Object.defineProperty({__proto__:null,json:eP},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nP=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],rP=Object.freeze(Object.defineProperty({__proto__:null,json:nP},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sP=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],oP=Object.freeze(Object.defineProperty({__proto__:null,json:sP},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iP=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],aP=Object.freeze(Object.defineProperty({__proto__:null,json:iP},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uP=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],lP=Object.freeze(Object.defineProperty({__proto__:null,json:uP},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cP=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],hP=Object.freeze(Object.defineProperty({__proto__:null,json:cP},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dP=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],pP=Object.freeze(Object.defineProperty({__proto__:null,json:dP},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fP=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],mP=Object.freeze(Object.defineProperty({__proto__:null,json:fP},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gP=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],yP=Object.freeze(Object.defineProperty({__proto__:null,json:gP},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bP=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],wP=Object.freeze(Object.defineProperty({__proto__:null,json:bP},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xP=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],vP=Object.freeze(Object.defineProperty({__proto__:null,json:xP},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SP=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],CP=Object.freeze(Object.defineProperty({__proto__:null,json:SP},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IP=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],kP=Object.freeze(Object.defineProperty({__proto__:null,json:IP},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NP=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],$P=Object.freeze(Object.defineProperty({__proto__:null,json:NP},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TP=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],EP=Object.freeze(Object.defineProperty({__proto__:null,json:TP},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _P=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],AP=Object.freeze(Object.defineProperty({__proto__:null,json:_P},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tl{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[XD,QD,JD,tP,rP,oP,aP,lP,hP,pP,mP,yP,wP,vP,CP,kP,$P,EP,AP],t=[].concat(...e.map(r=>r.json));this.opMappers=t.reduce((r,s)=>(r[s.tfOpName]=s,r),{})}transformGraph(e,t={}){const r=e.node,s=[],o=[],i=[],a=r.reduce((x,b)=>(x[b.name]=this.mapNode(b),b.op.startsWith("Placeholder")?s.push(x[b.name]):b.op==="Const"?o.push(x[b.name]):(b.input==null||b.input.length===0)&&i.push(x[b.name]),x),{});let u=[];const l=[];let h={},c={};t!=null&&(h=this.mapSignatureEntries(t.inputs),c=this.mapSignatureEntries(t.outputs));const d=Object.keys(a);d.forEach(x=>{const b=a[x];b.inputNames.forEach((v,k)=>{const[$,,N]=tn(v),R=a[$];if(R.outputs!=null){const O=R.outputs.indexOf(N);if(O!==-1){const F=`${$}:${O}`;b.inputNames[k]=F}}b.inputs.push(R),R.children.push(b)})}),Object.keys(c).length===0?d.forEach(x=>{const b=a[x];b.children.length===0&&l.push(b)}):Object.keys(c).forEach(x=>{const[b]=tn(x),v=a[b];v!=null&&(v.signatureKey=c[x],l.push(v))}),Object.keys(h).length>0?Object.keys(h).forEach(x=>{const[b]=tn(x),v=a[b];v&&(v.signatureKey=h[x],u.push(v))}):u=s;let f={};e.library!=null&&e.library.function!=null&&(f=e.library.function.reduce((x,b)=>(x[b.signature.name]=this.mapFunction(b),x),{}));const m={nodes:a,inputs:u,outputs:l,weights:o,placeholders:s,signature:t,functions:f};return i.length>0&&(m.initNodes=i),m}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,r)=>(t[e[r].name]=r,t),{})}mapNode(e){const t=Pf(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(s=>s.startsWith("^")?s.slice(1):s),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(r.inputParams=t.inputs.reduce((s,o)=>(s[o.name]={type:o.type,inputIndexStart:o.start,inputIndexEnd:o.end},s),{})),t.attrs!=null&&(r.attrParams=t.attrs.reduce((s,o)=>{const i=o.type;let a;switch(o.type){case"string":a=Fi(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Fi(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"string[]":a=Ui(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Ui(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number":a=Li(e.attr,o.tfName,o.defaultValue||0),a===void 0&&o.tfDeprecatedName&&(a=Li(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"number[]":a=Wi(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Wi(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool":a=zi(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=zi(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"bool[]":a=Hi(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Hi(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape":a=Vi(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Vi(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"shape[]":a=Gi(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Gi(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype":a=Bi(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Bi(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"dtype[]":a=Mi(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=Mi(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"func":a=El(e.attr,o.tfName,o.defaultValue),a===void 0&&o.tfDeprecatedName&&(a=El(e.attr,o.tfDeprecatedName,o.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${o.type} for op: ${e.op}`)}return s[o.name]={value:a,type:i},s},{})),r}mapFunction(e){const t=e.nodeDef,r=[],s=[];let o={};t!=null&&(o=t.reduce((c,d)=>(c[d.name]=this.mapNode(d),d.op==="Const"&&s.push(c[d.name]),c),{}));const i=[],a=[];e.signature.inputArg.forEach(c=>{const[d]=tn(c.name),f={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Aa(c.type),type:"dtype"}},children:[]};f.signatureKey=c.name,i.push(f),o[d]=f}),Object.keys(o).forEach(c=>{const d=o[c];d.inputNames.forEach((f,m)=>{const[x,,b]=tn(f),v=o[x];if(v.outputs!=null){const k=v.outputs.indexOf(b);if(k!==-1){const $=`${x}:${k}`;d.inputNames[m]=$}}d.inputs.push(v),v.children.push(d)})});const l=e.ret;e.signature.outputArg.forEach(c=>{const[d,f]=tn(l[c.name]),m=o[d];m!=null&&(m.defaultOutput=f,a.push(m))});const h=this.mapArgsToSignature(e);return{nodes:o,inputs:i,outputs:a,weights:s,placeholders:r,signature:h}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r),t),{}),outputs:e.signature.outputArg.reduce((t,r)=>(t[r.name]=this.mapArgToTensorInfo(r,e.ret),t),{})}}mapArgToTensorInfo(e,t){let r=e.name;return t!=null&&(r=t[r]),{name:r,dtype:e.type}}}function RP(n){const e=oe().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function Of(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):RP(n);return e?t:t.toLowerCase()}function Fi(n,e,t,r=!1){const s=n[e];return s!=null?Of(s.s,r):t}function zi(n,e,t){const r=n[e];return r?r.b:t}function Li(n,e,t){const r=n[e]||{},s=r.i!=null?r.i:r.f!=null?r.f:t;return typeof s=="number"?s:parseInt(s,10)}function Aa(n){switch(typeof n=="string"&&(n=ht[n]),n){case ht.DT_FLOAT:case ht.DT_HALF:return"float32";case ht.DT_INT32:case ht.DT_INT64:case ht.DT_INT8:case ht.DT_UINT8:return"int32";case ht.DT_BOOL:return"bool";case ht.DT_DOUBLE:return"float32";case ht.DT_STRING:return"string";case ht.DT_COMPLEX64:case ht.DT_COMPLEX128:return"complex64";default:return null}}function El(n,e,t){const r=n[e];return r&&r.func?r.func.name:t}function Bi(n,e,t){const r=n[e];return r&&r.type?Aa(r.type):t}function Mi(n,e,t){const r=n[e];return r&&r.list&&r.list.type?r.list.type.map(s=>Aa(s)):t}function Ff(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Vi(n,e,t){const r=n[e];return r&&r.shape?Ff(r.shape):t}function Wi(n,e,t){const r=n[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(s=>typeof s=="number"?s:parseInt(s,10)):t}function Ui(n,e,t,r=!1){const s=n[e];return s&&s.list&&s.list.s?s.list.s.map(o=>Of(o,r)):t}function Gi(n,e,t){const r=n[e];return r&&r.list&&r.list.shape?r.list.shape.map(s=>Ff(s)):t}function Hi(n,e,t){const r=n[e];return r&&r.list&&r.list.b?r.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DP{constructor(e,t,r){this.node=e,this.tensorMap=t,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(s=>this.getInput(s)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((s,o)=>(s[o]=this.getAttr(o),s),{}))}getInput(e){return He(e,this.tensorMap,this.context)}getAttr(e,t){const r=this.node.rawAttrs[e];if(r.tensor!=null)return He(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return Li(this.node.rawAttrs,e,t);if(r.s!=null)return Fi(this.node.rawAttrs,e,t);if(r.b!=null)return zi(this.node.rawAttrs,e,t);if(r.shape!=null)return Vi(this.node.rawAttrs,e,t);if(r.type!=null)return Bi(this.node.rawAttrs,e,t);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return Wi(this.node.rawAttrs,e,t);if(r.list.s!=null)return Ui(this.node.rawAttrs,e,t);if(r.list.shape!=null)return Gi(this.node.rawAttrs,e,t);if(r.list.b!=null)return Hi(this.node.rawAttrs,e,t);if(r.list.type!=null)return Mi(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qe=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:jd,abs:gt,acos:Wy,acosh:Gy,add:ie,addN:jy,all:Ky,any:Yy,argMax:Zy,argMin:e0,asin:n0,asinh:s0,atan:i0,atan2:u0,atanh:c0,avgPool:up,avgPool3d:b0,basicLSTMCell:k0,batchNorm:ho,batchNorm2d:_0,batchNorm3d:R0,batchNorm4d:P0,batchToSpaceND:lp,bincount:cp,bitwiseAnd:z0,booleanMaskAsync:k2,broadcastArgs:B0,broadcastTo:qr,buffer:Ee,cast:Pe,ceil:W0,clipByValue:hp,clone:yn,complex:vn,concat:je,concat1d:H0,concat2d:q0,concat3d:X0,concat4d:Q0,conv1d:eb,conv2d:po,conv2dTranspose:rb,conv3d:ob,conv3dTranspose:lb,cos:hb,cosh:pb,cosineWindow:wa,cumprod:mb,cumsum:yb,denseBincount:wb,depthToSpace:vb,depthwiseConv2d:ra,diag:Ib,dilation2d:Nb,div:ye,divNoNan:Rb,dot:Pb,dropout:L2,einsum:fr,elu:fp,enclosingPowerOfTwo:Up,ensureShape:Lb,equal:pp,erf:Mb,euclideanNorm:Yb,exp:un,expandDims:Ht,expm1:ew,eye:bp,fft:ga,fill:cs,floor:wp,floorDiv:ip,fused:J2,gather:xp,gatherND:O2,greater:go,greaterEqual:vp,ifft:Xs,imag:yo,image:wo,inTopKAsync:M2,irfft:zp,isFinite:lw,isInf:hw,isNaN:pw,leakyRelu:Sp,less:Ei,lessEqual:oa,linalg:DS,linspace:yw,localResponseNormalization:ww,log:es,log1p:Cp,logSigmoid:Nw,logSoftmax:Ew,logSumExp:kp,logicalAnd:js,logicalNot:Np,logicalOr:$p,logicalXor:Ow,losses:PS,lowerBound:zw,matMul:Se,max:br,maxPool:Tp,maxPool3d:Mw,maxPoolWithArgmax:Ww,maximum:Ep,mean:qs,meshgrid:Hw,min:Ti,minimum:Ks,mirrorPad:Kw,mod:Yw,moments:Zw,movingAverage:T2,mul:q,multiRNNCell:e1,multinomial:n1,neg:Yt,norm:mo,notEqual:_p,oneHot:o1,ones:Bn,onesLike:a1,op:A,outerProduct:l1,pad:fs,pad1d:d1,pad2d:f1,pad3d:g1,pad4d:b1,pool:C1,pow:Jr,prelu:Rp,print:op,prod:N1,raggedGather:T1,raggedRange:_1,raggedTensorToTensor:R1,rand:P1,randomGamma:ex,randomNormal:Pp,randomStandardNormal:rx,randomUniform:ma,randomUniformInt:ix,range:ts,real:ns,reciprocal:lx,relu:bo,relu6:Op,reshape:M,reverse:Yn,reverse1d:fx,reverse2d:gx,reverse3d:bx,reverse4d:xx,rfft:ya,round:Fp,rsqrt:Cx,scalar:we,scatterND:_2,searchSorted:ia,selu:kx,separableConv2d:$x,setdiff1dAsync:Ex,sigmoid:Vn,sign:Ax,signal:RS,sin:Dx,sinh:Ox,slice:pe,slice1d:zx,slice2d:Bx,slice3d:Vx,slice4d:Ux,softmax:Hx,softplus:Ip,spaceToBatchND:Ap,sparse:OS,sparseToDense:D2,spectral:AS,split:rs,sqrt:an,square:Pt,squaredDifference:Lp,squeeze:Ge,stack:cn,step:Bp,stridedSlice:n2,string:FS,sub:fe,sum:Ne,tan:s2,tanh:$i,tensor:Xt,tensor1d:Ye,tensor2d:Wn,tensor3d:Mp,tensor4d:o2,tensor5d:i2,tensor6d:a2,tensorScatterUpdate:c2,tile:Kr,topk:d2,transpose:_i,truncatedNormal:f2,unique:g2,unsortedSegmentSum:b2,unstack:tr,upperBound:x2,variable:v2,where:bn,whereAsync:Wp,zeros:Xn,zerosLike:yt},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PP=(n,e,t,r=qe)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(y("a",n,e,t),y("b",n,e,t))];case"AddN":return[r.addN(y("tensors",n,e,t))];case"FloorMod":case"Mod":return[r.mod(y("a",n,e,t),y("b",n,e,t))];case"Mul":return[r.mul(y("a",n,e,t),y("b",n,e,t))];case"RealDiv":case"Div":return[r.div(y("a",n,e,t),y("b",n,e,t))];case"DivNoNan":return[r.divNoNan(y("a",n,e,t),y("b",n,e,t))];case"FloorDiv":return[r.floorDiv(y("a",n,e,t),y("b",n,e,t))];case"Sub":return[r.sub(y("a",n,e,t),y("b",n,e,t))];case"Minimum":return[r.minimum(y("a",n,e,t),y("b",n,e,t))];case"Maximum":return[r.maximum(y("a",n,e,t),y("b",n,e,t))];case"Pow":return[r.pow(y("a",n,e,t),y("b",n,e,t))];case"SquaredDifference":return[r.squaredDifference(y("a",n,e,t),y("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OP=(n,e,t,r=qe)=>{switch(n.op){case"Abs":case"ComplexAbs":return[r.abs(y("x",n,e,t))];case"Acos":return[r.acos(y("x",n,e,t))];case"Acosh":return[r.acosh(y("x",n,e,t))];case"Asin":return[r.asin(y("x",n,e,t))];case"Asinh":return[r.asinh(y("x",n,e,t))];case"Atan":return[r.atan(y("x",n,e,t))];case"Atan2":return[r.atan2(y("x",n,e,t),y("y",n,e,t))];case"Atanh":return[r.atanh(y("x",n,e,t))];case"Ceil":return[r.ceil(y("x",n,e,t))];case"Complex":return[r.complex(y("real",n,e,t),y("imag",n,e,t))];case"Cos":return[r.cos(y("x",n,e,t))];case"Cosh":return[r.cosh(y("x",n,e,t))];case"Elu":return[r.elu(y("x",n,e,t))];case"Erf":return[r.erf(y("x",n,e,t))];case"Exp":return[r.exp(y("x",n,e,t))];case"Expm1":return[r.expm1(y("x",n,e,t))];case"Floor":return[r.floor(y("x",n,e,t))];case"Log":return[r.log(y("x",n,e,t))];case"Log1p":return[r.log1p(y("x",n,e,t))];case"Imag":return[r.imag(y("x",n,e,t))];case"Neg":return[r.neg(y("x",n,e,t))];case"Reciprocal":return[r.reciprocal(y("x",n,e,t))];case"Real":return[r.real(y("x",n,e,t))];case"Relu":return[r.relu(y("x",n,e,t))];case"Round":return[r.round(y("x",n,e,t))];case"Selu":return[r.selu(y("x",n,e,t))];case"Sigmoid":return[r.sigmoid(y("x",n,e,t))];case"Sin":return[r.sin(y("x",n,e,t))];case"Sign":return[r.sign(y("x",n,e,t))];case"Sinh":return[r.sinh(y("x",n,e,t))];case"Softplus":return[r.softplus(y("x",n,e,t))];case"Sqrt":return[r.sqrt(y("x",n,e,t))];case"Square":return[r.square(y("x",n,e,t))];case"Tanh":return[r.tanh(y("x",n,e,t))];case"Tan":return[r.tan(y("x",n,e,t))];case"ClipByValue":return[r.clipByValue(y("x",n,e,t),y("clipValueMin",n,e,t),y("clipValueMax",n,e,t))];case"Relu6":return[r.relu6(y("x",n,e,t))];case"Rsqrt":return[r.rsqrt(He(n.inputNames[0],e,t))];case"LeakyRelu":return[r.leakyRelu(y("x",n,e,t),y("alpha",n,e,t))];case"Prelu":return[r.prelu(y("x",n,e,t),y("alpha",n,e,t))];case"IsNan":return[r.isNaN(He(n.inputNames[0],e,t))];case"IsInf":return[r.isInf(He(n.inputNames[0],e,t))];case"IsFinite":return[r.isFinite(He(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ct(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){I(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let r=0;r<n.length;r++){const s=n[r],o=e[r];I(s<0||o<0||s===o,()=>t+` Shapes ${n} and ${e} must match`)}}}function _l(n){return!(typeof n=="number"||n.some(e=>e<0))}function Wr(n,e,t){let r=ji(n,t);const s=!_l(r);if(s&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(s&&e.forEach(o=>{r=ji(o.shape,r)}),!_l(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function ji(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let r=0;r<n.length;++r){const s=n[r],o=e[r];if(s>=0&&o>=0&&s!==o)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[r]=s>=0?s:o}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FP{constructor(e,t,r,s,o,i,a){this.name=e,this.dtype=t,this.maxSize=r,this.elementShape=s,this.identicalElementShapes=o,this.dynamicSize=i,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=we(0),qt(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),Ct(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=t,qt(t),r.written=!0,this.tensors[e]=r}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((r,s)=>this.write(r,t[s]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let s=0;s<this.size();s++)e.push(s)}if(e.length===0)return Xt([],[0].concat(this.elementShape));const r=this.readMany(e);return Ct(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),cn(r,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Xt([],[0].concat(this.elementShape));const t=[];for(let s=0;s<this.size();s++)t.push(s);const r=this.readMany(t);return Ct(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),je(r,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,tr(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let r=0;const s=e.map(u=>(r+=u,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const o=r===0?0:t.size/r,i=[];be(()=>{t=M(t,[1,r,o]);for(let u=0;u<e.length;++u){const h=[0,u===0?0:s[u-1],0],c=[1,e[u],o];i[u]=M(pe(t,h,c),this.elementShape)}return i});const a=[];for(let u=0;u<e.length;u++)a[u]=u;this.writeMany(a,i)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zn{get id(){return this.idTensor.id}constructor(e,t,r,s=-1){this.tensors=e,this.elementShape=t,this.elementDtype=r,e!=null&&e.forEach(o=>{if(r!==o.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${o.dtype}`);Ct(t,o.shape,"TensorList shape mismatch: "),qt(o)}),this.idTensor=we(0),this.maxNumElements=s,qt(this.idTensor)}copy(){return new Zn([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,r=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);Ct(e,this.elementShape,"TensorList shape mismatch: ");const s=Wr(this.elementShape,this.tensors,e);return be(()=>{const o=this.tensors.map(i=>M(i,s));return cn(o,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=Wr(this.elementShape,this.tensors,e),s=this.tensors.pop();return s.kept=!1,Ct(s.shape,e,"TensorList shape mismatch: "),M(s,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(Ct(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");qt(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new Zn([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)t.tensors[r]=this.tensors[r];return t}getItem(e,t,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);Ct(this.tensors[e].shape,t,"TensorList shape mismatch: ");const s=Wr(this.elementShape,this.tensors,t);return M(this.tensors[e],s)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);Ct(this.elementShape,t.shape,"TensorList shape mismatch: "),qt(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,r){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);Ct(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const s=Wr(this.elementShape,this.tensors,r);return e.length===0?Xt([],[0].concat(s)):be(()=>{const o=e.map(i=>M(this.tensors[i],s));return cn(o,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);Ct(this.elementShape,t,"TensorList shape mismatch: ");const r=Wr(this.elementShape,this.tensors,t);return this.size()===0?Xt([],[0].concat(r)):be(()=>{const s=this.tensors.map(o=>M(o,r));return je(s,0)})}}function zP(n,e,t){const r=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const s=n.shape.slice(1);Ct(s,e,"TensorList shape mismatch: ");const o=tr(n);return new Zn(o,e,r)}function LP(n,e,t,r){return new Zn([],n,e,r)}function BP(n,e,t,r){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const s=Math.max(...e);if(r!=null&&r!==-1&&s>=r)throw new Error(`Max index must be < array size (${s}  vs. ${r})`);const o=new Zn([],t,n.dtype,r),i=tr(n,0);return e.forEach((a,u)=>{o.setItem(a,i[u])}),o}function MP(n,e,t){let r=0;const s=e.map(h=>(r+=h,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);const o=n.shape.slice(1),i=ji(o,t),a=r===0?0:n.size/r,u=be(()=>{const h=[];n=M(n,[1,r,a]);for(let c=0;c<e.length;++c){const f=[0,c===0?0:s[c-1],0],m=[1,e[c],a];h[c]=M(pe(n,f,m),i)}return n.dispose(),h}),l=new Zn([],t,n.dtype,e.length);for(let h=0;h<u.length;h++)l.setItem(h,u[h]);return l}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VP=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const r=y("thenBranch",n,e,t),s=y("elseBranch",n,e,t),o=y("cond",n,e,t),i=y("args",n,e,t);return(await o.data())[0]?t.functionMap[r].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap):t.functionMap[s].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const r=y("body",n,e,t),s=y("cond",n,e,t),o=y("args",n,e,t),i=await t.functionMap[s].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap),a=o.map(h=>h.id);let u=await i[0].data();i.forEach(h=>{!h.kept&&a.indexOf(h.id)===-1&&h.dispose()});let l=o;for(;u[0];){const h=l;l=await t.functionMap[r].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);const c=l.map(f=>f.id);h.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&c.indexOf(f.id)===-1&&f.dispose()});const d=await t.functionMap[s].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);u=await d[0].data(),d.forEach(f=>{!f.kept&&a.indexOf(f.id)===-1&&c.indexOf(f.id)===-1&&f.dispose()})}return l}case"LoopCond":{const r=y("pred",n,e,t);return[nn(r)]}case"Switch":{const r=y("pred",n,e,t);let s=y("data",n,e,t);return s.kept||(s=nn(s)),(await r.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const r=n.inputNames.find(s=>He(s,e,t)!==void 0);if(r){const s=He(r,e,t);return[nn(s)]}return}case"Enter":{const r=y("frameName",n,e,t),s=y("tensor",n,e,t);return t.enterFrame(r),[nn(s)]}case"Exit":{const r=y("tensor",n,e,t);return t.exitFrame(),[nn(r)]}case"NextIteration":{const r=y("tensor",n,e,t);return t.nextIteration(),[nn(r)]}case"TensorArrayV3":{const r=y("size",n,e,t),s=y("dtype",n,e,t),o=y("elementShape",n,e,t),i=y("dynamicSize",n,e,t),a=y("clearAfterRead",n,e,t),u=y("identicalElementShapes",n,e,t),l=y("name",n,e,t),h=new FP(l,s,r,o,u,i,a);return t.addTensorArray(h),[h.idTensor,we(1)]}case"TensorArrayWriteV3":{const r=y("tensorArrayId",n,e,t),s=y("index",n,e,t),o=y("tensor",n,e,t),i=t.getTensorArray(r.id);return i.write(s,o),[i.idTensor]}case"TensorArrayReadV3":{const r=y("tensorArrayId",n,e,t),s=y("index",n,e,t);return[t.getTensorArray(r.id).read(s)]}case"TensorArrayGatherV3":{const r=y("tensorArrayId",n,e,t),s=y("indices",n,e,t),o=y("dtype",n,e,t);return[t.getTensorArray(r.id).gather(s,o)]}case"TensorArrayScatterV3":{const r=y("tensorArrayId",n,e,t),s=y("indices",n,e,t),o=y("tensor",n,e,t),i=t.getTensorArray(r.id);return i.scatter(s,o),[i.idTensor]}case"TensorArrayConcatV3":{const r=y("tensorArrayId",n,e,t),s=t.getTensorArray(r.id),o=y("dtype",n,e,t);return[s.concat(o)]}case"TensorArraySplitV3":{const r=y("tensorArrayId",n,e,t),s=y("tensor",n,e,t),o=y("lengths",n,e,t),i=t.getTensorArray(r.id);return i.split(o,s),[i.idTensor]}case"TensorArraySizeV3":{const r=y("tensorArrayId",n,e,t),s=t.getTensorArray(r.id);return[we(s.size(),"int32")]}case"TensorArrayCloseV3":{const r=y("tensorArrayId",n,e,t),s=t.getTensorArray(r.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const r=y("tensorListId",n,e,t),s=y("index",n,e,t),o=y("tensor",n,e,t),i=t.getTensorList(r.id);return i.setItem(s,o),[i.idTensor]}case"TensorListGetItem":{const r=y("tensorListId",n,e,t),s=y("index",n,e,t),o=y("elementShape",n,e,t),i=y("elementDType",n,e,t);return[t.getTensorList(r.id).getItem(s,o,i)]}case"TensorListScatterV2":case"TensorListScatter":{const r=y("indices",n,e,t),s=y("tensor",n,e,t),o=y("elementShape",n,e,t),i=y("numElements",n,e,t),a=BP(s,r,o,i);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=y("elementShape",n,e,t),s=y("elementDType",n,e,t);let o;n.op==="TensorListReserve"?o="numElements":o="maxNumElements";const i=y(o,n,e,t),a=n.op==="TensorListReserve"?-1:i,u=LP(r,s,i,a);return t.addTensorList(u),[u.idTensor]}case"TensorListGather":{const r=y("tensorListId",n,e,t),s=y("indices",n,e,t),o=y("elementShape",n,e,t),i=y("elementDType",n,e,t);return[t.getTensorList(r.id).gather(s,i,o)]}case"TensorListStack":{const r=y("tensorListId",n,e,t),s=y("elementShape",n,e,t),o=y("elementDType",n,e,t),i=y("numElements",n,e,t);return[t.getTensorList(r.id).stack(s,o,i)]}case"TensorListFromTensor":{const r=y("tensor",n,e,t),s=y("elementShape",n,e,t),o=y("elementDType",n,e,t),i=zP(r,s,o);return t.addTensorList(i),[i.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=y("tensorListId",n,e,t),s=t.getTensorList(r.id),o=y("dtype",n,e,t),i=y("elementShape",n,e,t);return[s.concat(o,i)]}case"TensorListPushBack":{const r=y("tensorListId",n,e,t),s=y("tensor",n,e,t),o=t.getTensorList(r.id);return o.pushBack(s),[o.idTensor]}case"TensorListPopBack":{const r=y("tensorListId",n,e,t),s=y("elementShape",n,e,t),o=y("elementDType",n,e,t);return[t.getTensorList(r.id).popBack(s,o)]}case"TensorListSplit":{const r=y("tensor",n,e,t),s=y("elementShape",n,e,t),o=y("lengths",n,e,t),i=MP(r,o,s);return t.addTensorList(i),[i.idTensor]}case"TensorListLength":{const r=y("tensorListId",n,e,t),s=t.getTensorList(r.id);return[we(s.size(),"int32")]}case"TensorListResize":{const r=y("tensorListId",n,e,t),s=y("size",n,e,t),i=t.getTensorList(r.id).resize(s);return t.addTensorList(i),[i.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Al(n,e,t){const[r,s]=y("fusedOps",n,e,t),o=r==="biasadd",i=!o,a=s==="prelu",u=r==="fusedbatchnorm",l=y("numArgs",n,e,t);if(o){if(a&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&o&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(u)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const h=y("strides",n,e,t),c=Ls(n,e,t),d=y("dataFormat",n,e,t).toUpperCase(),f=y("dilations",n,e,t);let[m,x]=y("args",n,e,t);i&&(x=m,m=void 0);const b=y("leakyreluAlpha",n,e,t);return{stride:h,pad:c,dataFormat:d,dilations:f,biasArg:m,preluArg:x,activationFunc:s,leakyreluAlpha:b}}const WP=(n,e,t,r=qe)=>{switch(n.op){case"Conv1D":{const s=y("stride",n,e,t),o=y("pad",n,e,t),i=y("dataFormat",n,e,t).toUpperCase(),a=y("dilation",n,e,t);return[r.conv1d(y("x",n,e,t),y("filter",n,e,t),s,o,i,a)]}case"Conv2D":{const s=y("strides",n,e,t),o=Ls(n,e,t),i=y("dataFormat",n,e,t).toUpperCase(),a=y("dilations",n,e,t);return[r.conv2d(y("x",n,e,t),y("filter",n,e,t),[s[1],s[2]],o,i,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:s,pad:o,dataFormat:i,dilations:a,biasArg:u,preluArg:l,activationFunc:h,leakyreluAlpha:c}=Al(n,e,t);return[r.fused.conv2d({x:y("x",n,e,t),filter:y("filter",n,e,t),strides:[s[1],s[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:u,activation:h,preluActivationWeights:l,leakyreluAlpha:c})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:o,dataFormat:i,dilations:a,biasArg:u,preluArg:l,activationFunc:h,leakyreluAlpha:c}=Al(n,e,t);return[r.fused.depthwiseConv2d({x:y("x",n,e,t),filter:y("filter",n,e,t),strides:[s[1],s[2]],pad:o,dataFormat:i,dilations:[a[1],a[2]],bias:u,activation:h,preluActivationWeights:l,leakyreluAlpha:c})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=y("outputShape",n,e,t),o=y("strides",n,e,t),i=Ls(n,e,t);return[r.conv2dTranspose(y("x",n,e,t),y("filter",n,e,t),s,[o[1],o[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=y("strides",n,e,t),o=Ls(n,e,t),i=y("dilations",n,e,t),a=y("dataFormat",n,e,t).toUpperCase();return[r.depthwiseConv2d(y("input",n,e,t),y("filter",n,e,t),[s[1],s[2]],o,a,[i[1],i[2]])]}case"Conv3D":{const s=y("strides",n,e,t),o=y("pad",n,e,t),i=y("dataFormat",n,e,t).toUpperCase(),a=y("dilations",n,e,t);return[r.conv3d(y("x",n,e,t),y("filter",n,e,t),[s[1],s[2],s[3]],o,i,[a[1],a[2],a[3]])]}case"AvgPool":{const s=y("strides",n,e,t),o=y("pad",n,e,t),i=y("kernelSize",n,e,t);return[r.avgPool(y("x",n,e,t),[i[1],i[2]],[s[1],s[2]],o)]}case"MaxPool":{const s=y("strides",n,e,t),o=y("pad",n,e,t),i=y("kernelSize",n,e,t);return[r.maxPool(y("x",n,e,t),[i[1],i[2]],[s[1],s[2]],o)]}case"MaxPoolWithArgmax":{const s=y("strides",n,e,t),o=y("pad",n,e,t),i=y("kernelSize",n,e,t),a=y("includeBatchInIndex",n,e,t),{result:u,indexes:l}=r.maxPoolWithArgmax(y("x",n,e,t),[i[1],i[2]],[s[1],s[2]],o,a);return[u,l]}case"AvgPool3D":{const s=y("strides",n,e,t),o=y("pad",n,e,t),i=y("kernelSize",n,e,t);return[r.avgPool3d(y("x",n,e,t),[i[1],i[2],i[3]],[s[1],s[2],s[3]],o)]}case"MaxPool3D":{const s=y("strides",n,e,t),o=y("pad",n,e,t),i=y("kernelSize",n,e,t);return[r.maxPool3d(y("x",n,e,t),[i[1],i[2],i[3]],[s[1],s[2],s[3]],o)]}case"Dilation2D":{const s=y("strides",n,e,t),o=y("pad",n,e,t),i=y("dilations",n,e,t),a=s[1],u=s[2],l=i[1],h=i[2];return[r.dilation2d(y("x",n,e,t),y("filter",n,e,t),[a,u],o,[l,h],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UP=(n,e,t,r=qe)=>{switch(n.op){case"Fill":{const s=y("shape",n,e,t),o=y("dtype",n,e,t),i=y("value",n,e,t);return[r.fill(s,i,o)]}case"LinSpace":{const s=y("start",n,e,t),o=y("stop",n,e,t),i=y("num",n,e,t);return[r.linspace(s,o,i)]}case"Multinomial":{const s=y("logits",n,e,t),o=y("numSamples",n,e,t),i=y("seed",n,e,t);return[r.multinomial(s,o,i)]}case"OneHot":{const s=y("indices",n,e,t),o=y("depth",n,e,t),i=y("onValue",n,e,t),a=y("offValue",n,e,t),u=y("dtype",n,e,t);return[r.oneHot(s,o,i,a,u)]}case"Ones":return[r.ones(y("shape",n,e,t),y("dtype",n,e,t))];case"OnesLike":return[r.onesLike(y("x",n,e,t))];case"RandomStandardNormal":return[r.randomStandardNormal(y("shape",n,e,t),y("dtype",n,e,t),y("seed",n,e,t))];case"RandomUniform":return[r.randomUniform(y("shape",n,e,t),y("minval",n,e,t),y("maxval",n,e,t),y("dtype",n,e,t))];case"RandomUniformInt":return[r.randomUniformInt(y("shape",n,e,t),y("minval",n,e,t),y("maxval",n,e,t),y("seed",n,e,t))];case"Range":{const s=y("start",n,e,t),o=y("stop",n,e,t),i=y("step",n,e,t);return[r.range(s,o,i,y("dtype",n,e,t))]}case"TruncatedNormal":{const s=y("shape",n,e,t),o=y("mean",n,e,t),i=y("stdDev",n,e,t),a=y("seed",n,e,t);return[r.truncatedNormal(s,o,i,y("dtype",n,e,t),a)]}case"Zeros":return[r.zeros(y("shape",n,e,t),y("dtype",n,e,t))];case"ZerosLike":return[r.zerosLike(y("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ti(n,e,t){const r=y("boxes",n,e,t),s=y("scores",n,e,t),o=y("maxOutputSize",n,e,t),i=y("iouThreshold",n,e,t),a=y("scoreThreshold",n,e,t),u=y("softNmsSigma",n,e,t);return{boxes:r,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:a,softNmsSigma:u}}const GP=async(n,e,t,r,s=qe)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:u,scoreThreshold:l,softNmsSigma:h}=ti(n,e,t),c=await s.image.nonMaxSuppressionWithScoreAsync(o,i,a,u,l,h);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:u,scoreThreshold:l}=ti(n,e,t),h=y("padToMaxOutputSize",n,e,t),c=await s.image.nonMaxSuppressionPaddedAsync(o,i,a,u,l,h);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:o,scores:i,maxOutputSize:a,iouThreshold:u,scoreThreshold:l}=ti(n,e,t);return[await s.image.nonMaxSuppressionAsync(o,i,a,u,l)]}case"Where":{const o=s.cast(y("condition",n,e,t),"bool"),i=[await s.whereAsync(o)];return o.dispose(),i}case"ListDiff":return s.setdiff1dAsync(y("x",n,e,t),y("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HP=(n,e,t,r=qe)=>{switch(n.op){case"LowerBound":{const s=y("sortedSequence",n,e,t),o=y("values",n,e,t);return[r.lowerBound(s,o)]}case"TopKV2":{const s=y("x",n,e,t),o=y("k",n,e,t),i=y("sorted",n,e,t),a=r.topk(s,o,i);return[a.values,a.indices]}case"UpperBound":{const s=y("sortedSequence",n,e,t),o=y("values",n,e,t);return[r.upperBound(s,o)]}case"Unique":{const s=y("x",n,e,t),o=r.unique(s);return[o.values,o.indices]}case"UniqueV2":{const s=y("x",n,e,t),o=y("axis",n,e,t),i=r.unique(s,o);return[i.values,i.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jP=(n,e,t,r=qe)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const s=y("default",n,e,t);return[He(n.name,e,t)||s];case"Placeholder":return[He(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const h=y("x",n,e,t);return[nn(h)]}case"IdentityN":return y("x",n,e,t).map(h=>nn(h));case"Snapshot":const o=y("x",n,e,t);return[nn(o)];case"Shape":return[r.tensor1d(y("x",n,e,t).shape,"int32")];case"ShapeN":return y("x",n,e,t).map(h=>r.tensor1d(h.shape));case"Size":return[r.scalar(y("x",n,e,t).size,"int32")];case"Rank":return[r.scalar(y("x",n,e,t).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const i=y("x",n,e,t),a=y("data",n,e,t),u=y("message",n,e,t),l=y("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(u);for(let h=0;h<a.length;h++)console.log(Array.prototype.slice.call(a[h].dataSync()).slice(0,l));return[i];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qP{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=we(0),this.tensorMap=new Map,qt(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return we(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return this.tensorMap.forEach(s=>s.dispose()),this.tensorMap.clear(),be(()=>{const s=tr(t),o=r.length,i=s.length;I(o===i,()=>`The number of elements doesn't match, keys has ${o} elements, the values has ${i} elements.`);for(let a=0;a<o;a++){const u=r[a],l=s[a];qt(l),this.tensorMap.set(u,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const r=await e.data();return be(()=>{const s=[];for(let o=0;o<r.length;o++){const i=r[o],a=this.findWithDefault(i,t);s.push(a)}return cn(s)})}findWithDefault(e,t){const r=this.tensorMap.get(e);return r??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KP=async(n,e,t,r)=>{switch(n.op){case"HashTable":case"HashTableV2":{const s=r.getHashTableHandleByName(n.name);if(s!=null)return[s];{const o=y("keyDType",n,e,t),i=y("valueDType",n,e,t),a=new qP(o,i);return r.addHashTable(n.name,a),[a.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const s=y("tableHandle",n,e,t,r),o=y("keys",n,e,t),i=y("values",n,e,t);return[await r.getHashTableById(s.id).import(o,i)]}case"LookupTableFind":case"LookupTableFindV2":{const s=y("tableHandle",n,e,t,r),o=y("keys",n,e,t),i=y("defaultValue",n,e,t);return[await r.getHashTableById(s.id).find(o,i)]}case"LookupTableSize":case"LookupTableSizeV2":{const s=y("tableHandle",n,e,t,r);return[r.getHashTableById(s.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XP=(n,e,t,r=qe)=>{switch(n.op){case"ResizeBilinear":{const s=y("images",n,e,t),o=y("size",n,e,t),i=y("alignCorners",n,e,t),a=y("halfPixelCenters",n,e,t);return[r.image.resizeBilinear(s,[o[0],o[1]],i,a)]}case"ResizeNearestNeighbor":{const s=y("images",n,e,t),o=y("size",n,e,t),i=y("alignCorners",n,e,t),a=y("halfPixelCenters",n,e,t);return[r.image.resizeNearestNeighbor(s,[o[0],o[1]],i,a)]}case"CropAndResize":{const s=y("image",n,e,t),o=y("boxes",n,e,t),i=y("boxInd",n,e,t),a=y("cropSize",n,e,t),u=y("method",n,e,t),l=y("extrapolationValue",n,e,t);return[r.image.cropAndResize(s,o,i,a,u,l)]}case"ImageProjectiveTransformV3":{const s=y("images",n,e,t),o=y("transforms",n,e,t),i=y("outputShape",n,e,t),a=y("fillValue",n,e,t),u=y("interpolation",n,e,t),l=y("fillMode",n,e,t);return[r.image.transform(s,o,u.toLowerCase(),l.toLowerCase(),a,i)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YP=(n,e,t,r=qe)=>{switch(n.op){case"Equal":return[r.equal(y("a",n,e,t),y("b",n,e,t))];case"NotEqual":return[r.notEqual(y("a",n,e,t),y("b",n,e,t))];case"Greater":return[r.greater(y("a",n,e,t),y("b",n,e,t))];case"GreaterEqual":return[r.greaterEqual(y("a",n,e,t),y("b",n,e,t))];case"Less":return[r.less(y("a",n,e,t),y("b",n,e,t))];case"LessEqual":return[r.lessEqual(y("a",n,e,t),y("b",n,e,t))];case"LogicalAnd":return[r.logicalAnd(y("a",n,e,t),y("b",n,e,t))];case"LogicalNot":return[r.logicalNot(y("a",n,e,t))];case"LogicalOr":return[r.logicalOr(y("a",n,e,t),y("b",n,e,t))];case"Select":case"SelectV2":return[r.where(y("condition",n,e,t),y("a",n,e,t),y("b",n,e,t))];case"BitwiseAnd":return[r.bitwiseAnd(y("a",n,e,t),y("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QP=(n,e,t,r=qe)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(y("a",n,e,t),y("b",n,e,t),y("transposeA",n,e,t),y("transposeB",n,e,t))];case"Einsum":return[r.einsum(y("equation",n,e,t),...y("tensors",n,e,t))];case"Transpose":return[r.transpose(y("x",n,e,t),y("perm",n,e,t))];case"_FusedMatMul":const[s,o]=y("fusedOps",n,e,t),i=s==="biasadd",a=o==="prelu",u=y("numArgs",n,e,t),l=y("leakyreluAlpha",n,e,t);if(i){if(a&&u!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&u!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[h,c]=y("args",n,e,t);return[r.fused.matMul({a:y("a",n,e,t),b:y("b",n,e,t),transposeA:y("transposeA",n,e,t),transposeB:y("transposeB",n,e,t),bias:h,activation:o,preluActivationWeights:c,leakyreluAlpha:l})];case"MatrixBandPart":return[r.linalg.bandPart(y("a",n,e,t),y("numLower",n,e,t),y("numUpper",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZP=(n,e,t,r=qe)=>{switch(n.op){case"EuclideanNorm":return[r.euclideanNorm(y("x",n,e,t),y("axis",n,e,t),y("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(y("x",n,e,t),y("mean",n,e,t),y("variance",n,e,t),y("offset",n,e,t),y("scale",n,e,t),y("epsilon",n,e,t))];case"FusedBatchNormV3":return[r.batchNorm(y("x",n,e,t),y("mean",n,e,t),y("variance",n,e,t),y("offset",n,e,t),y("scale",n,e,t),y("epsilon",n,e,t))];case"LRN":return[r.localResponseNormalization(y("x",n,e,t),y("radius",n,e,t),y("bias",n,e,t),y("alpha",n,e,t),y("beta",n,e,t))];case"Softmax":return[r.softmax(y("x",n,e,t))];case"LogSoftmax":return[r.logSoftmax(y("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JP=(n,e,t,r=qe)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:s,outputDenseValues:o}=r.raggedGather(y("paramsNestedSplits",n,e,t),y("paramsDenseValues",n,e,t),y("indices",n,e,t),y("outputRaggedRank",n,e,t));return s.concat(o)}case"RaggedRange":{const{rtNestedSplits:s,rtDenseValues:o}=r.raggedRange(y("starts",n,e,t),y("limits",n,e,t),y("splits",n,e,t));return[s,o]}case"RaggedTensorToTensor":return[r.raggedTensorToTensor(y("shape",n,e,t),y("values",n,e,t),y("defaultValue",n,e,t),y("rowPartitionTensors",n,e,t),y("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eO=(n,e,t,r=qe)=>{switch(n.op){case"Max":{const a=y("axis",n,e,t),u=y("keepDims",n,e,t);return[r.max(y("x",n,e,t),a,u)]}case"Mean":{const a=y("axis",n,e,t),u=y("keepDims",n,e,t);return[r.mean(y("x",n,e,t),a,u)]}case"Min":{const a=y("axis",n,e,t),u=y("keepDims",n,e,t);return[r.min(y("x",n,e,t),a,u)]}case"Sum":{const a=y("axis",n,e,t),u=y("keepDims",n,e,t);return[r.sum(y("x",n,e,t),a,u)]}case"All":{const a=y("axis",n,e,t),u=y("keepDims",n,e,t);return[r.all(y("x",n,e,t),a,u)]}case"Any":{const a=y("axis",n,e,t),u=y("keepDims",n,e,t);return[r.any(y("x",n,e,t),a,u)]}case"ArgMax":{const a=y("axis",n,e,t);return[r.argMax(y("x",n,e,t),a)]}case"ArgMin":{const a=y("axis",n,e,t);return[r.argMin(y("x",n,e,t),a)]}case"Prod":{const a=y("axis",n,e,t),u=y("keepDims",n,e,t);return[r.prod(y("x",n,e,t),a,u)]}case"Cumprod":{const a=y("axis",n,e,t),u=y("exclusive",n,e,t),l=y("reverse",n,e,t);return[r.cumprod(y("x",n,e,t),a,u,l)]}case"Cumsum":{const a=y("axis",n,e,t),u=y("exclusive",n,e,t),l=y("reverse",n,e,t);return[r.cumsum(y("x",n,e,t),a,u,l)]}case"Bincount":const s=y("x",n,e,t),o=y("weights",n,e,t),i=y("size",n,e,t);return[r.bincount(s,o,i)];case"DenseBincount":{const a=y("x",n,e,t),u=y("weights",n,e,t),l=y("size",n,e,t),h=y("binaryOutput",n,e,t);return[r.denseBincount(a,u,l,h)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tO=(n,e,t,r=qe)=>{switch(n.op){case"ConcatV2":case"Concat":{const s=y("n",n,e,t),o=y("axis",n,e,t);let i=y("tensors",n,e,t);return i=i.slice(0,s),[r.concat(i,o)]}case"Gather":{const s=y("x",n,e,t),o=y("indices",n,e,t);return[r.gather(s,r.cast(o,"int32"),0)]}case"GatherV2":{const s=y("axis",n,e,t),o=y("batchDims",n,e,t),i=y("x",n,e,t),a=y("indices",n,e,t);return[r.gather(i,r.cast(a,"int32"),s,o)]}case"Reverse":{const s=y("dims",n,e,t),o=[];for(let a=0;a<s.length;a++)s[a]&&o.push(a);const i=y("x",n,e,t);return[r.reverse(i,o)]}case"ReverseV2":{const s=y("axis",n,e,t),o=y("x",n,e,t);return[r.reverse(o,s)]}case"Slice":{const s=y("begin",n,e,t),o=y("size",n,e,t);return[r.slice(y("x",n,e,t),s,o)]}case"StridedSlice":{const s=y("begin",n,e,t),o=y("end",n,e,t),i=y("strides",n,e,t),a=y("beginMask",n,e,t),u=y("endMask",n,e,t),l=y("ellipsisMask",n,e,t),h=y("newAxisMask",n,e,t),c=y("shrinkAxisMask",n,e,t),d=y("x",n,e,t);return[r.stridedSlice(d,s,o,i,a,u,l,h,c)]}case"Pack":return be(()=>{const s=y("axis",n,e,t),o=y("tensors",n,e,t),i=o[0].shape,a=r.squeeze(o[0]).shape,u=o.map(l=>{const h=ot(l.shape,i);if(!h&&!ot(r.squeeze(l).shape,a))throw new Error("the input tensors shape does not match");return h?l:r.reshape(l,i)});return[r.stack(u,s)]});case"Unpack":{const s=y("axis",n,e,t),o=y("tensor",n,e,t);return r.unstack(o,s)}case"Tile":{const s=y("reps",n,e,t);return[r.tile(y("x",n,e,t),s)]}case"Split":case"SplitV":{const s=y("axis",n,e,t),o=y("numOrSizeSplits",n,e,t),i=y("x",n,e,t);return r.split(i,o,s)}case"ScatterNd":{const s=y("indices",n,e,t),o=y("values",n,e,t),i=y("shape",n,e,t);return[r.scatterND(s,o,i)]}case"GatherNd":{const s=y("x",n,e,t),o=y("indices",n,e,t);return[r.gatherND(s,o)]}case"SparseToDense":{const s=y("sparseIndices",n,e,t),o=y("outputShape",n,e,t),i=y("sparseValues",n,e,t),a=y("defaultValue",n,e,t);return[r.sparseToDense(s,i,o,i.dtype===a.dtype?a:r.cast(a,i.dtype))]}case"TensorScatterUpdate":{const s=y("indices",n,e,t),o=y("values",n,e,t),i=y("tensor",n,e,t);return[r.tensorScatterUpdate(i,s,o)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nO=(n,e,t,r=qe)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:o,emptyRowIndicator:i,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(y("indices",n,e,t),y("values",n,e,t),y("denseShape",n,e,t),y("defaultValue",n,e,t));return[s,o,i,a]}case"SparseReshape":{const{outputIndices:s,outputShape:o}=r.sparse.sparseReshape(y("inputIndices",n,e,t),y("inputShape",n,e,t),y("newShape",n,e,t));return[s,o]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(y("data",n,e,t),y("indices",n,e,t),y("segmentIds",n,e,t))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(y("data",n,e,t),y("indices",n,e,t),y("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rO=(n,e,t,r=qe)=>{switch(n.op){case"FFT":return[r.fft(y("x",n,e,t))];case"IFFT":return[r.ifft(y("x",n,e,t))];case"RFFT":return[r.rfft(y("x",n,e,t))];case"IRFFT":return[r.irfft(y("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sO=(n,e,t,r=qe)=>{switch(n.op){case"StaticRegexReplace":return[r.string.staticRegexReplace(y("input",n,e,t),y("pattern",n,e,t),y("rewrite",n,e,t),y("replaceGlobal",n,e,t))];case"StringNGrams":{const{nGrams:s,nGramsSplits:o}=r.string.stringNGrams(y("data",n,e,t),y("dataSplits",n,e,t),y("separator",n,e,t),y("nGramWidths",n,e,t),y("leftPad",n,e,t),y("rightPad",n,e,t),y("padWidth",n,e,t),y("preserveShortSequences",n,e,t));return[s,o]}case"StringSplit":{const{indices:s,values:o,shape:i}=r.string.stringSplit(y("input",n,e,t),y("delimiter",n,e,t),y("skipEmpty",n,e,t));return[s,o,i]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(y("input",n,e,t),y("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oO=(n,e,t,r=qe)=>{switch(n.op){case"Cast":return[r.cast(y("x",n,e,t),y("dtype",n,e,t))];case"ExpandDims":{const s=y("axis",n,e,t);return[r.expandDims(y("x",n,e,t),s)]}case"Squeeze":{const s=y("axis",n,e,t);return[r.squeeze(y("x",n,e,t),s)]}case"Reshape":return[r.reshape(y("x",n,e,t),y("shape",n,e,t))];case"EnsureShape":return[r.ensureShape(y("x",n,e,t),y("shape",n,e,t))];case"MirrorPad":return[r.mirrorPad(y("x",n,e,t),y("padding",n,e,t),y("mode",n,e,t))];case"PadV2":case"Pad":return[r.pad(y("x",n,e,t),y("padding",n,e,t),y("constantValue",n,e,t))];case"SpaceToBatchND":{const s=y("blockShape",n,e,t),o=y("paddings",n,e,t);return[r.spaceToBatchND(y("x",n,e,t),s,o)]}case"BatchToSpaceND":{const s=y("blockShape",n,e,t),o=y("crops",n,e,t);return[r.batchToSpaceND(y("x",n,e,t),s,o)]}case"DepthToSpace":{const s=y("blockSize",n,e,t),o=y("dataFormat",n,e,t).toUpperCase();return[r.depthToSpace(y("x",n,e,t),s,o)]}case"BroadcastTo":return[r.broadcastTo(y("x",n,e,t),y("shape",n,e,t))];case"BroadcastArgs":return[r.broadcastArgs(y("s0",n,e,t),y("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rl(n,e,t,r,s=be){const o=((i,a,u)=>{switch(i.category){case"arithmetic":return s(()=>PP(i,a,u));case"basic_math":return s(()=>OP(i,a,u));case"control":return VP(i,a,u);case"convolution":return s(()=>WP(i,a,u));case"creation":return s(()=>UP(i,a,u));case"dynamic":return GP(i,a,u);case"evaluation":return s(()=>HP(i,a,u));case"image":return s(()=>XP(i,a,u));case"graph":return s(()=>jP(i,a,u));case"logical":return s(()=>YP(i,a,u));case"matrices":return s(()=>QP(i,a,u));case"normalization":return s(()=>ZP(i,a,u));case"ragged":return s(()=>JP(i,a,u));case"reduction":return s(()=>eO(i,a,u));case"slice_join":return s(()=>tO(i,a,u));case"sparse":return s(()=>nO(i,a,u));case"spectral":return s(()=>rO(i,a,u));case"string":return s(()=>sO(i,a,u));case"transformation":return s(()=>oO(i,a,u));case"hash_table":return KP(i,a,u,r);case"custom":const l=Pf(i.op);if(l&&l.customExecutor)return l.customExecutor(new DP(i,a,u));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Gn(o)?o.then(i=>[].concat(i)):[].concat(o)}class Dl{constructor(e={},t={},r={},s={},o){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=r,this.functionMap=s,this.parseNodeNameCache=o,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const r=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pl(n,e,t,r){const s=new Set,o=[];let i=null,a=null;const u=new Set,l=new Set(Object.keys(n).map(d=>dt(d)[0]));r=r||[];const h=new Set(r.map(d=>dt(d.name)[0])),c=[...e];for(;c.length>0;){const d=c.pop();if((Fn(d)||pO(d)||fO(d))&&i==null&&(i=d,a=i.children.map(f=>f.name).filter(f=>s.has(f))),s.add(d.name),t[d.name]==null&&!l.has(d.name)&&!h.has(d.name)){if(d.inputs.length===0){o.push(d.name);continue}d.inputs.forEach(f=>{u.has(f.name)||(u.add(f.name),c.push(f))})}}return{inputs:n,outputs:e,usedNodes:s,missingInputs:o,dynamicNode:i,syncInputs:a}}function iO(n,e){const{usedNodes:t,inputs:r}=e,s=Object.keys(r).map(b=>dt(b)[0]).map(b=>n.nodes[b]),o=n.initNodes||[],i=b=>t.has(typeof b=="string"?b:b.name);function a(b){return[...new Map(b.map(v=>[v.name,v])).values()]}const u=a([...s,...n.weights,...o]).filter(i),l=a([...u,...Object.values(n.nodes)]).filter(i),h=new Map(l.map(b=>[b.name,b])),c={};for(const b of l){c[b.name]=c[b.name]||0;for(const v of b.children)i(v)||(c[v.name]=Number.POSITIVE_INFINITY),c[v.name]=(c[v.name]||0)+1}const d=Object.entries(c).filter(([,b])=>b===0).map(([b])=>b),f=[...d];for(;d.length>0;){const b=d.pop(),v=h.get(b);for(const k of v.children.filter(i))--c[k.name]===0&&(f.push(k.name),d.push(k.name))}const m=f.map(b=>h.get(b)),x=aO(m,u);return uO(x,u),x}function aO(n,e){const t=new Map(n.map(i=>[i.name,i])),r=e.map(i=>i.name),s=new Set(r);for(;r.length>0;){const i=r.pop(),a=t.get(i);for(const u of a.children)!t.has(u.name)||s.has(u.name)||(s.add(u.name),r.push(u.name))}return n.filter(i=>s.has(i.name))}class Rs extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function uO(n,e){const t=new Map(n.map((a,u)=>[a.name,u])),r=new Set(e.map(a=>a.name)),s=a=>r.has(typeof a=="string"?a:a.name),o=new Set(n.map(a=>a.name)),i=a=>o.has(typeof a=="string"?a:a.name);for(const a of n){for(const u of a.children.filter(i)){if(!t.has(u.name))throw new Rs(`Child ${u.name} of node ${a.name} is unreachable.`);if(t.get(a.name)>t.get(u.name))throw new Rs(`Node ${a.name} is scheduled to run after its child ${u.name}.`)}if(!s(a))for(const u of a.inputs){if(!t.has(u.name))throw new Rs(`Input ${u.name} of node ${a.name} is unreachable.`);if(t.get(u.name)>t.get(a.name))throw new Rs(`Node ${a.name} is scheduled to run before its input ${u.name}.`)}}}function lO(n){const e=new Map(n.map((a,u)=>[a.name,u])),t=Number.MAX_SAFE_INTEGER,r=n.map((a,u)=>Fn(a)?t:u),s=a=>{const u=r[e.get(a.name)];return u??-1},o=n.map((a,u)=>a.children.map(s).reduce((l,h)=>Math.max(l,h),r[u])),i=new Map;for(let a=0;a<n.length;++a){const u=o[a];if(u===t)continue;const l=n[a],h=n[u];i.has(h.name)||i.set(h.name,[]),i.get(h.name).push(l)}return i}const cO=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),hO=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),dO=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Fn(n){return cO.has(n.op)}function pO(n){return hO.has(n.op)}function fO(n){return dO.has(n.op)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class no{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(r=>e[r].map(s=>s.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new no(e.functions[r],this)})}getCompilationKey(e,t){const r=e.map(o=>o.name).sort(),s=t.map(o=>o.name).sort();return r.join(this.SEPARATOR)+"--"+s.join(this.SEPARATOR)}compile(e,t){const r=Pl(e,t,this.weightMap,this._initNodes),{missingInputs:s,dynamicNode:o,syncInputs:i}=r;if(o!=null)throw new Error(`This execution contains the node '${o.name}', which has the dynamic op '${o.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${i}]`);if(s.length>0){const l=t.map(c=>c.name),h=Object.keys(e);throw new Error(`Cannot compute the outputs [${l}] from the provided inputs [${h}]. Missing the following inputs: [${s}]`)}const a=iO(this.graph,r),u=lO(a);return{orderedNodes:a,nodeLiveUntilMap:u}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return qt(t),t}cloneTensorList(e){return e?e.map(r=>this.cloneAndKeepTensor(r)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,r])=>[t,this.cloneTensorList(r)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const s=r.map(d=>this.graph.nodes[dt(d)[0]]),o=t.map(d=>dt(d)[0]),i=new Set(o);let a=o.map(d=>this.graph.nodes[d]);a.length===0&&(a=this._outputs);const u=this.getCompilationKey(s,a);let l=this.compiledMap.get(u);l==null&&(l=this.compile(e,a),this.compiledMap.set(u,l));try{this.keepIntermediateTensors=oe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const h={},c={};return be(()=>{const d=new Dl(this.weightMap,h,c,this.functionExecutorMap,this.parseNodeNameCache),f=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(v=>{const[k,$]=dt(v,d),N=[];N[$]=e[v],f[k]=N,this.keepIntermediateTensors&&(this.clonedTensorsMap[k]=this.cloneTensorList(N))});const m=this.getFrozenTensorIds(f),{orderedNodes:x,nodeLiveUntilMap:b}=l;for(const v of x){if(f[v.name])continue;const k=Rl(v,f,d,this._resourceManager);if(Gn(k))throw new Error(`The execution of the op '${v.op}' returned a promise. Please use model.executeAsync() instead.`);f[v.name]=k,this.keepIntermediateTensors&&(this.clonedTensorsMap[v.name]=this.cloneTensorList(k)),this.checkTensorForDisposalWithNodeLiveUntilInfo(v,f,d,m,i,b.get(v.name))}return this.parent==null&&d.dispose(m),t.map(v=>He(v,f,d))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(s=>s.id)));return new Set(t)}checkTensorForDisposal(e,t,r,s,o,i,a){if(!(Fn(t)||i.has(e))){for(const u of r[e])u!=null&&(a[u.id]=(a[u.id]||0)+t.children.length);for(const u of t.inputs){if(Fn(u))continue;const l=$l(u.name,r,s);if(l!=null)for(const h of l){if(!h||h.kept||o.has(h.id))continue;const c=a[h.id];c===1?(h.dispose(),delete a[h.id]):c!=null&&a[h.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,r,s,o,i){function a(u){return Fn(u)||o.has(u.name)}if(!(Fn(e)||i==null))for(const u of i){if(a(u))continue;const l=$l(u.name,t,r);for(const h of l)!h||h.kept||s.has(h.id)||h.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,r=!1,s={},o={}){this.disposeIntermediateTensors(),r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=oe().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const i=new Dl(this.weightMap,s,o,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const a=await this.executeWithControlFlow(e,i,t,r),u=t.map(d=>He(d,a,i)),l=u.map(d=>d.id),h=Object.keys(e).map(d=>e[d].id),c=new Set([...l,...h,...this.weightIds]);return Object.values(a).forEach(d=>{d.forEach(f=>{f&&!f.isDisposed&&!c.has(f.id)&&f.dispose()})}),this.parent==null&&i.dispose(c),u}async executeFunctionAsync(e,t,r){const s=e.reduce((o,i,a)=>(o[this.inputs[a].name]=i,o),{});return this._executeAsync(s,this.outputNodes,!0,t,r)}async executeWithControlFlow(e,t,r,s){const o=Object.keys(e),i=o.map(N=>this.graph.nodes[dt(N)[0]]),a=r.map(N=>dt(N)[0]),u=new Set(a);let l=a.map(N=>this.graph.nodes[N]);l.length===0&&(l=this._outputs);const{usedNodes:h,missingInputs:c,dynamicNode:d,syncInputs:f}=Pl(e,l,this.weightMap,this._initNodes),m=[...i,...this.graph.weights,...this._initNodes||[]].map(N=>({node:N,contexts:t.currentContext})),x=Object.assign({},this.weightMap);Object.keys(e).forEach(N=>{const[R,O]=dt(N),F=[];F[O]=e[N],x[R]=F});const b={},v=this.getFrozenTensorIds(x),k={};for(;m.length>0;){const N=this.processStack(i,m,t,x,k,v,u,b,h);await Promise.all(N)}d==null&&!s&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const $=l.filter(N=>!Fn(N)&&!He(N.name,x,t)).map(N=>N.name);if($.length>0){let N="";throw d!=null&&(N=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),new Error(`Cannot compute the outputs [${$}] from the provided inputs [${o}]. Consider providing the following inputs: [${c}]. ${N}`)}return x}processStack(e,t,r,s,o,i,a,u,l){const h=[];for(;t.length>0;){const c=t.pop();r.currentContext=c.contexts;let d="";if(c.node.op==="Enter"&&y("isConstant",c.node,s,r)&&([d]=tn(c.node.name,r)),s[c.node.name]==null){const f=Rl(c.node,s,r,this._resourceManager);d||([d]=tn(c.node.name,r));const m=r.currentContext;Gn(f)?h.push(f.then(x=>(s[d]=x,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(x)),r.currentContext=m,this.checkTensorForDisposal(d,c.node,s,r,i,a,u),this.processChildNodes(c.node,t,r,s,o,l),x))):(s[d]=f,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(f)),this.checkTensorForDisposal(d,c.node,s,r,i,a,u),this.processChildNodes(c.node,t,r,s,o,l))}else this.processChildNodes(c.node,t,r,s,o,l)}return h}processChildNodes(e,t,r,s,o,i){e.children.forEach(a=>{const[u]=tn(a.name,r);o[u]||!i.has(a.name)||(a.op==="Merge"?a.inputNames.some(l=>!!He(l,s,r))&&(o[u]=!0,t.push({contexts:r.currentContext,node:a})):a.inputNames.every(l=>!!He(l,s,r))&&(o[u]=!0,t.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const r=e[t],[s]=dt(t),o=this.graph.nodes[s];if(o.attrParams.shape&&o.attrParams.shape.value){const i=o.attrParams.shape.value,a=i.length===r.shape.length&&r.shape.every((u,l)=>i[l]===-1||i[l]===u);I(a,()=>`The shape of dict['${o.name}'] provided in model.execute(dict) must be [${i}], but was [${r.shape}]`)}o.attrParams.dtype&&o.attrParams.dtype.value&&I(r.dtype===o.attrParams.dtype.value,()=>`The dtype of dict['${o.name}'] provided in model.execute(dict) must be ${o.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){var t,r;const s={};for(const o in e){const i=(r=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||r===void 0?void 0:r[o];i!=null?s[i.name]=e[o]:s[o]=e[o]}return s}checkInputs(e){const t=Object.keys(e).filter(r=>{const[s]=dt(r);return this.graph.nodes[s]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var r,s;const o=(s=(r=this._signature)===null||r===void 0?void 0:r.outputs)===null||s===void 0?void 0:s[t];return o!=null?o.name:t},{})}checkOutputs(e){e.forEach(t=>{const[r]=dt(t);if(!this.graph.nodes[r])throw new Error(`The output '${t}' is not found in the graph`)})}}class mO{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gO="?tfjs-format=file",yO="model.json";class bO{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},r=ef){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=r,t==null&&(this.loadOptions={}),this.resourceManager=new mO}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Gn(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await Xd(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const r=this.artifacts.modelTopology;let s=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const o=this.artifacts.userDefinedMetadata;o.signature!=null&&(s=o.signature),o.structuredOutputKeys!=null&&(this.structuredOutputKeys=o.structuredOutputKeys)}if(this.signature=s,this.version=`${r.versions.producer}.${r.versions.minConsumer}`,this.executor=new no(Tl.Instance.transformGraph(r,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const o=Tl.Instance.transformGraph(e.modelInitializer);this.initializer=new no(o),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof Be?[e]:e,r={};return t.forEach((s,o)=>r[this.structuredOutputKeys[o]]=s),r}return e}predict(e,t){const r=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(r)}async predictAsync(e,t){const r=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(r)}normalizeInputs(e){var t;if(!(e instanceof Be)&&!Array.isArray(e)){const o=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(o!=null)for(const i in o){const a=o[i];a.resourceId!=null&&(e[i]=this.resourceIdToCapturedInput[a.resourceId])}return e}e=Array.isArray(e)?e:[e];const r=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+r!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-r} non-resource placeholders, while there are ${e.length} input tensors provided.`);let s=0;return this.inputNodes.reduce((o,i)=>{var a,u,l;const h=(l=(u=(a=this.signature)===null||a===void 0?void 0:a.inputs)===null||u===void 0?void 0:u[i])===null||l===void 0?void 0:l.resourceId;return h!=null?o[i]=this.resourceIdToCapturedInput[h]:o[i]=e[s++],o},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,r=Object.keys(t);for(let s=0;s<r.length;s++){const o=r[s],i=t[o];this.resourceIdToCapturedInput[i.resourceId]=e[s]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=this.executor.execute(e,t);return r.length>1?r:r[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const r=await this.executor.executeAsync(e,t);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,r)=>(t[r]=[e[r]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&De(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Ol(n,e={},t=ef){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=wO(n));const r=new bO(n,e,t);return await r.load(),r}function wO(n){return n.endsWith("/")||(n=n+"/"),`${n}${yO}${gO}`}/**
    * @license
    * Copyright 2023 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var tt=function(){return tt=Object.assign||function(n){for(var e,t=1,r=arguments.length;t<r;t++)for(var s in e=arguments[t])Object.prototype.hasOwnProperty.call(e,s)&&(n[s]=e[s]);return n},tt.apply(this,arguments)};function Ot(n,e,t,r){return new(t||(t=Promise))(function(s,o){function i(l){try{u(r.next(l))}catch(h){o(h)}}function a(l){try{u(r.throw(l))}catch(h){o(h)}}function u(l){var h;l.done?s(l.value):(h=l.value,h instanceof t?h:new t(function(c){c(h)})).then(i,a)}u((r=r.apply(n,[])).next())})}function Ft(n,e){var t,r,s,o,i={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return o={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(o[Symbol.iterator]=function(){return this}),o;function a(u){return function(l){return function(h){if(t)throw new TypeError("Generator is already executing.");for(;o&&(o=0,h[0]&&(i=0)),i;)try{if(t=1,r&&(s=2&h[0]?r.return:h[0]?r.throw||((s=r.return)&&s.call(r),0):r.next)&&!(s=s.call(r,h[1])).done)return s;switch(r=0,s&&(h=[2&h[0],s.value]),h[0]){case 0:case 1:s=h;break;case 4:return i.label++,{value:h[1],done:!1};case 5:i.label++,r=h[1],h=[0];continue;case 7:h=i.ops.pop(),i.trys.pop();continue;default:if(s=i.trys,!((s=s.length>0&&s[s.length-1])||h[0]!==6&&h[0]!==2)){i=0;continue}if(h[0]===3&&(!s||h[1]>s[0]&&h[1]<s[3])){i.label=h[1];break}if(h[0]===6&&i.label<s[1]){i.label=s[1],s=h;break}if(s&&i.label<s[2]){i.label=s[2],i.ops.push(h);break}s[2]&&i.ops.pop(),i.trys.pop();continue}h=e.call(n,i)}catch(c){h=[6,c],r=0}finally{t=s=0}if(5&h[0])throw h[1];return{value:h[0]?h[1]:void 0,done:!0}}([u,l])}}}var ro=["wrist","thumb_cmc","thumb_mcp","thumb_ip","thumb_tip","index_finger_mcp","index_finger_pip","index_finger_dip","index_finger_tip","middle_finger_mcp","middle_finger_pip","middle_finger_dip","middle_finger_tip","ring_finger_mcp","ring_finger_pip","ring_finger_dip","ring_finger_tip","pinky_finger_mcp","pinky_finger_pip","pinky_finger_dip","pinky_finger_tip"],ni={runtime:"mediapipe",maxHands:2,modelType:"full"},xO=function(){function n(e){var t,r=this;this.width=0,this.height=0,this.selfieMode=!1,this.handsSolution=new HD({locateFile:function(s,o){return e.solutionPath?e.solutionPath.replace(/\/+$/,"")+"/"+s:o+"/"+s}}),e.modelType==="lite"?t=0:t=1,this.handsSolution.setOptions({modelComplexity:t,selfieMode:this.selfieMode,maxNumHands:e.maxHands}),this.handsSolution.onResults(function(s){if(r.height=s.image.height,r.width=s.image.width,r.hands=[],s.multiHandLandmarks!==null)for(var o=s.multiHandedness,i=s.multiHandLandmarks,a=s.multiHandWorldLandmarks,u=0;u<o.length;u++)r.hands.push(tt(tt({},r.translateOutput(i[u],a[u])),{score:o[u].score,handedness:o[u].label}))})}return n.prototype.translateOutput=function(e,t){var r=this;return{keypoints:e.map(function(s,o){return{x:s.x*r.width,y:s.y*r.height,score:s.visibility,name:ro[o]}}),keypoints3D:t.map(function(s,o){return{x:s.x,y:s.y,z:s.z,score:s.visibility,name:ro[o]}})}},n.prototype.estimateHands=function(e,t){return Ot(this,void 0,void 0,function(){var r,s;return Ft(this,function(o){switch(o.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.handsSolution.setOptions({selfieMode:this.selfieMode})),e instanceof Be?(s=ImageData.bind,[4,fC(e)]):[3,2];case 1:return r=new(s.apply(ImageData,[void 0,o.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:r=e,o.label=3;case 3:return e=r,[4,this.handsSolution.send({image:e})];case 4:return o.sent(),[2,this.hands]}})})},n.prototype.dispose=function(){this.handsSolution.close()},n.prototype.reset=function(){this.handsSolution.reset(),this.width=0,this.height=0,this.hands=null,this.selfieMode=!1},n.prototype.initialize=function(){return this.handsSolution.initialize()},n}();function vO(n){return Ot(this,void 0,void 0,function(){var e,t;return Ft(this,function(r){switch(r.label){case 0:return e=function(s){if(s==null)return tt({},ni);var o=tt({},s);return o.runtime="mediapipe",o.maxHands==null&&(o.maxHands=ni.maxHands),o.modelType==null&&(o.modelType=ni.modelType),o}(n),[4,(t=new xO(e)).initialize()];case 1:return r.sent(),[2,t]}})})}function ri(n){return n.width*n.height}function Fl(n){var e=n.xCenter-n.width/2,t=e+n.width,r=n.yCenter-n.height/2;return{xMin:e,xMax:t,yMin:r,yMax:r+n.height,width:n.width,height:n.height}}function SO(n,e){var t=Fl(n),r=Fl(e);if(!function(i,a){return!(i.xMax<a.xMin||a.xMax<i.xMin||i.yMax<a.yMin||a.yMax<i.yMin)}(t,r))return 0;var s=ri(function(i,a){var u=Math.max(i.xMin,a.xMin),l=Math.min(i.xMax,a.xMax),h=Math.max(i.yMin,a.yMin),c=Math.min(i.yMax,a.yMax);return{xMin:u,xMax:l,yMin:h,yMax:c,width:Math.max(l-u,0),height:Math.max(c-h,0)}}(t,r)),o=ri(t)+ri(r)-s;return o>0?s/o:0}function CO(n,e,t,r){var s=n.width,o=n.height,i=1,a=Math.cos(n.rotation),u=Math.sin(n.rotation),l=n.xCenter,h=n.yCenter,c=1/e,d=1/t,f=new Array(16);return f[0]=s*a*i*c,f[1]=-o*u*c,f[2]=0,f[3]=(-.5*s*a*i+.5*o*u+l)*c,f[4]=s*u*i*d,f[5]=o*a*d,f[6]=0,f[7]=(-.5*o*a-.5*s*u*i+h)*d,f[8]=0,f[9]=0,f[10]=s*c,f[11]=0,f[12]=0,f[13]=0,f[14]=0,f[15]=1,function(m){if(m.length!==16)throw new Error("Array length must be 16 but got "+m.length);return[[m[0],m[1],m[2],m[3]],[m[4],m[5],m[6],m[7]],[m[8],m[9],m[10],m[11]],[m[12],m[13],m[14],m[15]]]}(f)}function zf(n){return n instanceof Be?{height:n.shape[0],width:n.shape[1]}:{height:n.height,width:n.width}}function so(n){return n-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}function Lf(n){return n instanceof Be?n:mC(n)}function si(n,e){I(n.width!==0,function(){return e+" width cannot be 0."}),I(n.height!==0,function(){return e+" height cannot be 0."})}function IO(n,e){var t=function(r,s,o,i){var a=s-r,u=i-o,l=u/a;return{scale:l,offset:o-r*l}}(0,255,e[0],e[1]);return be(function(){return ie(q(n,t.scale),t.offset)})}function zl(n,e,t){var r=e.outputTensorSize,s=e.keepAspectRatio,o=e.borderMode,i=e.outputTensorFloatRange,a=zf(n),u=function(d,f){return f?{xCenter:f.xCenter*d.width,yCenter:f.yCenter*d.height,width:f.width*d.width,height:f.height*d.height,rotation:f.rotation}:{xCenter:.5*d.width,yCenter:.5*d.height,width:d.width,height:d.height,rotation:0}}(a,t),l=function(d,f,m){if(m===void 0&&(m=!1),!m)return{top:0,left:0,right:0,bottom:0};var x=f.height,b=f.width;si(f,"targetSize"),si(d,"roi");var v,k,$=x/b,N=d.height/d.width,R=0,O=0;return $>N?(v=d.width,k=d.width*$,O=(1-N/$)/2):(v=d.height/$,k=d.height,R=(1-$/N)/2),d.width=v,d.height=k,{top:O,left:R,right:R,bottom:O}}(u,r,s),h=CO(u,a.width,a.height),c=be(function(){var d=Lf(n),f=Wn(function(b,v,k){return si(k,"inputResolution"),[1/k.width*b[0][0]*v.width,1/k.height*b[0][1]*v.width,b[0][3]*v.width,1/k.width*b[1][0]*v.height,1/k.height*b[1][1]*v.height,b[1][3]*v.height,0,0]}(h,a,r),[1,8]),m=o==="zero"?"constant":"nearest",x=wo.transform(Ht(Pe(d,"float32")),f,"bilinear",m,0,[r.height,r.width]);return i!=null?IO(x,i):x});return{imageTensor:c,padding:l,transformationMatrix:h}}function Ll(n,e,t,r){return r===1?.5*(n+e):n+(e-n)*t/(r-1)}function Bl(n){return{xCenter:n.xMin+n.width/2,yCenter:n.yMin+n.height/2,width:n.width,height:n.height}}function kO(n){var e=n.relativeKeypoints;if(e.length<=1)throw new Error("2 or more keypoints required to calculate a rect.");var t=Number.MAX_VALUE,r=Number.MAX_VALUE,s=Number.MIN_VALUE,o=Number.MIN_VALUE;return e.forEach(function(i){t=Math.min(t,i.x),s=Math.max(s,i.x),r=Math.min(r,i.y),o=Math.max(o,i.y)}),{xCenter:(t+s)/2,yCenter:(r+o)/2,width:s-t,height:o-r}}function NO(n,e,t,r,s){var o=t==="rect"?function(i,a,u){var l,h=i.locationData;return l=Bl(h.boundingBox),l}(n):function(i,a){var u=i.locationData;return a==="boundingbox"?Bl(u.relativeBoundingBox):kO(u)}(n,e);return s&&(o.rotation=function(i,a,u){var l,h=i.locationData,c=u.rotationVectorStartKeypointIndex,d=u.rotationVectorEndKeypointIndex;l=u.rotationVectorTargetAngle?u.rotationVectorTargetAngle:Math.PI*u.rotationVectorTargetAngleDegree/180;var f=h.relativeKeypoints[c].x*a.width,m=h.relativeKeypoints[c].y*a.height,x=h.relativeKeypoints[d].x*a.width,b=h.relativeKeypoints[d].y*a.height;return so(l-Math.atan2(-(b-m),x-f))}(n,r,s)),o}function $O(n){return be(function(){var e=function(s){return be(function(){return[pe(s,[0,0,0],[1,-1,1]),pe(s,[0,0,1],[1,-1,-1])]})}(n),t=e[0],r=e[1];return{boxes:Ge(r),logits:Ge(t)}})}function TO(n,e,t,r){return Ot(this,void 0,void 0,function(){var s,o,i,a,u;return Ft(this,function(l){switch(l.label){case 0:return n.sort(function(h,c){return Math.max.apply(Math,c.score)-Math.max.apply(Math,h.score)}),s=Wn(n.map(function(h){return[h.locationData.relativeBoundingBox.yMin,h.locationData.relativeBoundingBox.xMin,h.locationData.relativeBoundingBox.yMax,h.locationData.relativeBoundingBox.xMax]})),o=Ye(n.map(function(h){return h.score[0]})),[4,wo.nonMaxSuppressionAsync(s,o,e,t)];case 1:return[4,(i=l.sent()).array()];case 2:return a=l.sent(),u=n.filter(function(h,c){return a.indexOf(c)>-1}),De([s,o,i]),[2,u]}})})}function EO(n,e){return n.map(function(t){var r=tt(tt({},t),{x:t.x*e.width,y:t.y*e.height});return t.z!=null&&(r.z=t.z*e.width),r})}function _O(n,e,t){return Ot(this,void 0,void 0,function(){var r,s,o,i,a;return Ft(this,function(u){switch(u.label){case 0:return r=n[0],s=n[1],o=function(l,h,c){return be(function(){var d,f,m,x;c.reverseOutputOrder?(f=Ge(pe(l,[0,c.boxCoordOffset+0],[-1,1])),d=Ge(pe(l,[0,c.boxCoordOffset+1],[-1,1])),x=Ge(pe(l,[0,c.boxCoordOffset+2],[-1,1])),m=Ge(pe(l,[0,c.boxCoordOffset+3],[-1,1]))):(d=Ge(pe(l,[0,c.boxCoordOffset+0],[-1,1])),f=Ge(pe(l,[0,c.boxCoordOffset+1],[-1,1])),m=Ge(pe(l,[0,c.boxCoordOffset+2],[-1,1])),x=Ge(pe(l,[0,c.boxCoordOffset+3],[-1,1]))),f=ie(q(ye(f,c.xScale),h.w),h.x),d=ie(q(ye(d,c.yScale),h.h),h.y),c.applyExponentialOnBoxSize?(m=q(un(ye(m,c.hScale)),h.h),x=q(un(ye(x,c.wScale)),h.w)):(m=q(ye(m,c.hScale),h.h),x=q(ye(x,c.wScale),h.h));var b=fe(d,ye(m,2)),v=fe(f,ye(x,2)),k=ie(d,ye(m,2)),$=ie(f,ye(x,2)),N=je([M(b,[c.numBoxes,1]),M(v,[c.numBoxes,1]),M(k,[c.numBoxes,1]),M($,[c.numBoxes,1])],1);if(c.numKeypoints)for(var R=0;R<c.numKeypoints;++R){var O=c.keypointCoordOffset+R*c.numValuesPerKeypoint,F=void 0,B=void 0;c.reverseOutputOrder?(F=Ge(pe(l,[0,O],[-1,1])),B=Ge(pe(l,[0,O+1],[-1,1]))):(B=Ge(pe(l,[0,O],[-1,1])),F=Ge(pe(l,[0,O+1],[-1,1])));var L=ie(q(ye(F,c.xScale),h.w),h.x),W=ie(q(ye(B,c.yScale),h.h),h.y);N=je([N,M(L,[c.numBoxes,1]),M(W,[c.numBoxes,1])],1)}return N})}(s,e,t),i=be(function(){var l=r;return t.sigmoidScore?(t.scoreClippingThresh!=null&&(l=hp(r,-t.scoreClippingThresh,t.scoreClippingThresh)),l=Vn(l)):l}),[4,AO(o,i,t)];case 1:return a=u.sent(),De([o,i]),[2,a]}})})}function AO(n,e,t){return Ot(this,void 0,void 0,function(){var r,s,o,i,a,u,l,h,c,d,f,m;return Ft(this,function(x){switch(x.label){case 0:return r=[],[4,n.data()];case 1:return s=x.sent(),[4,e.data()];case 2:for(o=x.sent(),i=0;i<t.numBoxes;++i)if(!(t.minScoreThresh!=null&&o[i]<t.minScoreThresh||(a=i*t.numCoords,u=RO(s[a+0],s[a+1],s[a+2],s[a+3],o[i],t.flipVertically,i),(l=u.locationData.relativeBoundingBox).width<0||l.height<0))){if(t.numKeypoints>0)for((h=u.locationData).relativeKeypoints=[],c=t.numKeypoints*t.numValuesPerKeypoint,d=0;d<c;d+=t.numValuesPerKeypoint)f=a+t.keypointCoordOffset+d,m={x:s[f+0],y:t.flipVertically?1-s[f+1]:s[f+1]},h.relativeKeypoints.push(m);r.push(u)}return[2,r]}})})}function RO(n,e,t,r,s,o,i){return{score:[s],ind:i,locationData:{relativeBoundingBox:{xMin:e,yMin:o?1-t:n,xMax:r,yMax:o?1-n:t,width:r-e,height:t-n}}}}function DO(n,e){return n==="none"?e:function(t){return 1/(1+Math.exp(-t))}(e)}function Ml(n,e,t,r){return Ot(this,void 0,void 0,function(){var s,o,i,a,u,l,h,c;return Ft(this,function(d){switch(d.label){case 0:return t=t||e.flipHorizontally||!1,r=r||e.flipVertically||!1,s=n.size,o=s/e.numLandmarks,[4,n.data()];case 1:for(i=d.sent(),a=[],u=0;u<e.numLandmarks;++u)l=u*o,(c={x:0,y:0}).x=t?e.inputImageWidth-i[l]:i[l],o>1&&(c.y=r?e.inputImageHeight-i[l+1]:i[l+1]),o>2&&(c.z=i[l+2]),o>3&&(c.score=DO(e.visibilityActivation,i[l+3])),a.push(c);for(h=0;h<a.length;++h)(c=a[h]).x=c.x/e.inputImageWidth,c.y=c.y/e.inputImageHeight,c.z=c.z/e.inputImageWidth/(e.normalizeZ||1);return[2,a]}})})}function Vl(n,e,t){var r=n.width,s=n.height,o=n.rotation;if(t.rotation==null&&t.rotationDegree==null||(o=function(h,c){return c.rotation!=null?h+=c.rotation:c.rotationDegree!=null&&(h+=Math.PI*c.rotationDegree/180),so(h)}(o,t)),o===0)n.xCenter=n.xCenter+r*t.shiftX,n.yCenter=n.yCenter+s*t.shiftY;else{var i=(e.width*r*t.shiftX*Math.cos(o)-e.height*s*t.shiftY*Math.sin(o))/e.width,a=(e.width*r*t.shiftX*Math.sin(o)+e.height*s*t.shiftY*Math.cos(o))/e.height;n.xCenter=n.xCenter+i,n.yCenter=n.yCenter+a}if(t.squareLong){var u=Math.max(r*e.width,s*e.height);r=u/e.width,s=u/e.height}else if(t.squareShort){var l=Math.min(r*e.width,s*e.height);r=l/e.width,s=l/e.height}return n.width=r*t.scaleX,n.height=s*t.scaleY,n}function PO(n,e){for(var t=function(V,ee){var J=V[0].x*ee.width,ne=V[0].y*ee.height,re=(V[4].x+V[8].x)/2,he=(V[4].y+V[8].y)/2;return re=(re+V[6].x)/2*ee.width,he=(he+V[6].y)/2*ee.height,so(Math.PI/2-Math.atan2(-(he-ne),re-J))}(n,e),r=so(-t),s=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY,i=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY,u=0,l=n;u<l.length;u++){var h=(b=l[u]).x,c=b.y;s=Math.min(s,h),o=Math.max(o,h),i=Math.min(i,c),a=Math.max(a,c)}var d=(o+s)/2,f=(a+i)/2;s=Number.POSITIVE_INFINITY,o=Number.NEGATIVE_INFINITY,i=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY;for(var m=0,x=n;m<x.length;m++){var b,v=((b=x[m]).x-d)*e.width,k=(b.y-f)*e.height,$=v*Math.cos(r)-k*Math.sin(r),N=v*Math.sin(r)+k*Math.cos(r);s=Math.min(s,$),o=Math.max(o,$),i=Math.min(i,N),a=Math.max(a,N)}var R=(o+s)/2,O=(a+i)/2,F=R*Math.cos(t)-O*Math.sin(t)+e.width*d,B=R*Math.sin(t)+O*Math.cos(t)+e.height*f,L=(o-s)/e.width,W=(a-i)/e.height;return{xCenter:F/e.width,yCenter:B/e.height,width:L,height:W,rotation:t}}var OO={reduceBoxesInLowestLayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:4,minScale:.1484375,maxScale:.75,inputSizeHeight:192,inputSizeWidth:192,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,16,16],aspectRatios:[1],fixedAnchorSize:!0},oi={runtime:"tfjs",modelType:"full",maxHands:2,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/handpose_3d/detector/full/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/handpose_3d/landmark/full/1"},ii={flipHorizontal:!1,staticImageMode:!1},FO={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2016,numCoords:18,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:7,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:192,yScale:192,hScale:192,wScale:192,minScoreThresh:.5},zO=.3,LO={shiftX:0,shiftY:-.5,scaleX:2.6,scaleY:2.6,squareLong:!0},BO={shiftX:0,shiftY:-.1,scaleX:2,scaleY:2,squareLong:!0},MO={outputTensorSize:{width:192,height:192},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},VO={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},WO={numLandmarks:21,inputImageWidth:224,inputImageHeight:224,normalizeZ:.4,visibilityActivation:"none",flipHorizontally:!1,flipVertically:!1},UO={numLandmarks:21,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"none",flipHorizontally:!1,flipVertically:!1},oo,GO=function(){function n(e,t,r){this.detectorModel=e,this.landmarkModel=t,this.maxHands=r,this.prevHandRectsFromLandmarks=null,this.anchors=function(u){u.reduceBoxesInLowestLayer==null&&(u.reduceBoxesInLowestLayer=!1),u.interpolatedScaleAspectRatio==null&&(u.interpolatedScaleAspectRatio=1),u.fixedAnchorSize==null&&(u.fixedAnchorSize=!1);for(var l=[],h=0;h<u.numLayers;){for(var c=[],d=[],f=[],m=[],x=h;x<u.strides.length&&u.strides[x]===u.strides[h];){var b=Ll(u.minScale,u.maxScale,x,u.strides.length);if(x===0&&u.reduceBoxesInLowestLayer)f.push(1),f.push(2),f.push(.5),m.push(.1),m.push(b),m.push(b);else{for(var v=0;v<u.aspectRatios.length;++v)f.push(u.aspectRatios[v]),m.push(b);if(u.interpolatedScaleAspectRatio>0){var k=x===u.strides.length-1?1:Ll(u.minScale,u.maxScale,x+1,u.strides.length);m.push(Math.sqrt(b*k)),f.push(u.interpolatedScaleAspectRatio)}}x++}for(var $=0;$<f.length;++$){var N=Math.sqrt(f[$]);c.push(m[$]/N),d.push(m[$]*N)}var R=0,O=0;if(u.featureMapHeight.length>0)R=u.featureMapHeight[h],O=u.featureMapWidth[h];else{var F=u.strides[h];R=Math.ceil(u.inputSizeHeight/F),O=Math.ceil(u.inputSizeWidth/F)}for(var B=0;B<R;++B)for(var L=0;L<O;++L)for(var W=0;W<c.length;++W){var V={xCenter:(L+u.anchorOffsetX)/O,yCenter:(B+u.anchorOffsetY)/R,width:0,height:0};u.fixedAnchorSize?(V.width=1,V.height=1):(V.width=d[W],V.height=c[W]),l.push(V)}h=x}return l}(OO);var s=Ye(this.anchors.map(function(u){return u.width})),o=Ye(this.anchors.map(function(u){return u.height})),i=Ye(this.anchors.map(function(u){return u.xCenter})),a=Ye(this.anchors.map(function(u){return u.yCenter}));this.anchorTensor={x:i,y:a,w:s,h:o}}return n.prototype.estimateHands=function(e,t){return Ot(this,void 0,void 0,function(){var r,s,o,i,a,u,l,h,c,d,f,m,x,b,v,k,$,N,R=this;return Ft(this,function(O){switch(O.label){case 0:return r=function(L){if(L==null)return tt({},ii);var W=tt({},L);return W.flipHorizontal==null&&(W.flipHorizontal=ii.flipHorizontal),W.staticImageMode==null&&(W.staticImageMode=ii.staticImageMode),W}(t),e==null?(this.reset(),[2,[]]):(s=zf(e),o=be(function(){var L=Pe(Lf(e),"float32");return r.flipHorizontal&&(L=Ge(wo.flipLeftRight(Ht(L,0)),[0])),L}),i=this.prevHandRectsFromLandmarks,r.staticImageMode||i==null||i.length<this.maxHands?[4,this.detectPalm(o)]:[3,2]);case 1:return(u=O.sent()).length===0?(this.reset(),o.dispose(),[2,[]]):(l=u.map(function(L){return R.palmDetectionToRoi(L,s)}),a=l,[3,3]);case 2:a=i,O.label=3;case 3:return F=.5,B=[],[a].forEach(function(L){return L.forEach(function(W){(B=B.filter(function(V){return SO(W,V)<=F})).push(W)})}),a=B,[4,Promise.all(a.map(function(L){return R.handLandmarks(L,o)}))];case 4:for(h=O.sent(),c=[],this.prevHandRectsFromLandmarks=[],d=0,f=h;d<f.length;d++)(m=f[d])!=null&&(x=m.landmarks,b=m.worldLandmarks,v=m.handScore,k=m.handedness,this.prevHandRectsFromLandmarks.push(this.handLandmarksToRoi(x,s)),($=EO(x,s))!=null&&$.forEach(function(L,W){delete L.z,L.name=ro[W]}),(N=b)!=null&&N.forEach(function(L,W){L.name=ro[W]}),c.push({keypoints:$,keypoints3D:N,handedness:k,score:v}));return o.dispose(),[2,c]}var F,B})})},n.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),De([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h])},n.prototype.reset=function(){this.prevHandRectsFromLandmarks=null},n.prototype.detectPalm=function(e){return Ot(this,void 0,void 0,function(){var t,r,s,o,i,a,u,l,h,c;return Ft(this,function(d){switch(d.label){case 0:return t=zl(e,MO),r=t.imageTensor,s=t.padding,o=this.detectorModel.predict(r),i=$O(o),a=i.boxes,[4,_O([u=i.logits,a],this.anchorTensor,FO)];case 1:return(l=d.sent()).length===0?(De([r,o,u,a]),[2,l]):[4,TO(l,this.maxHands,zO)];case 2:return h=d.sent(),c=function(f,m){f===void 0&&(f=[]);for(var x=m.left,b=m.top,v=m.left+m.right,k=m.top+m.bottom,$=0;$<f.length;$++){var N=f[$],R=N.locationData.relativeBoundingBox,O=(R.xMin-x)/(1-v),F=(R.yMin-b)/(1-k),B=R.width/(1-v),L=R.height/(1-k);R.xMin=O,R.yMin=F,R.width=B,R.height=L,R.xMax=O+B,R.yMax=F+L;var W=N.locationData.relativeKeypoints;W&&W.forEach(function(V){var ee=(V.x-x)/(1-v),J=(V.y-b)/(1-k);V.x=ee,V.y=J})}return f}(h,s),De([r,o,u,a]),[2,c]}})})},n.prototype.palmDetectionToRoi=function(e,t){return Vl(NO(e,"boundingbox","normRect",t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:2,rotationVectorTargetAngleDegree:90}),t,LO)},n.prototype.handLandmarks=function(e,t){return Ot(this,void 0,void 0,function(){var r,s,o,i,a,u,l,h,c,d,f,m,x,b,v,k;return Ft(this,function($){switch($.label){case 0:return r=zl(t,VO,e),s=r.imageTensor,o=r.padding,i=this.landmarkModel.execute(s,["Identity_2:0","Identity_1:0","Identity:0","Identity_3:0"]),a=i[0],u=i[1],l=i[2],h=i[3],[4,u.data()];case 1:return(c=$.sent()[0])<.5?(De(i),De(s),[2,null]):[4,l.data()];case 2:return d=$.sent()[0],f=d>=.5?"Left":"Right",[4,Ml(a,WO)];case 3:return m=$.sent(),[4,Ml(h,UO)];case 4:return x=$.sent(),b=function(N,R){var O=R.left,F=R.top,B=R.left+R.right,L=R.top+R.bottom;return N.map(function(W){return tt(tt({},W),{x:(W.x-O)/(1-B),y:(W.y-F)/(1-L),z:W.z/(1-B)})})}(m,o),v=function(N,R,O){O===void 0&&(O={ignoreRotation:!1});for(var F=[],B=0,L=N;B<L.length;B++){var W=L[B],V=W.x-.5,ee=W.y-.5,J=O.ignoreRotation?0:R.rotation,ne=Math.cos(J)*V-Math.sin(J)*ee,re=Math.sin(J)*V+Math.cos(J)*ee;ne=ne*R.width+R.xCenter,re=re*R.height+R.yCenter;var he=W.z*R.width,Le=tt({},W);Le.x=ne,Le.y=re,Le.z=he,F.push(Le)}return F}(b,e),k=function(N,R){for(var O=[],F=0,B=N;F<B.length;F++){var L=B[F],W=L.x,V=L.y,ee=R.rotation,J=Math.cos(ee)*W-Math.sin(ee)*V,ne=Math.sin(ee)*W+Math.cos(ee)*V,re=tt({},L);re.x=J,re.y=ne,O.push(re)}return O}(x,e),De(i),De(s),[2,{landmarks:v,worldLandmarks:k,handScore:c,handedness:f}]}})})},n.prototype.handLandmarksToRoi=function(e,t){return Vl(PO([].concat(e.slice(0,4),e.slice(5,7),e.slice(9,11),e.slice(13,15),e.slice(17,19)),t),t,BO)},n}();function HO(n){return Ot(this,void 0,void 0,function(){var e,t,r,s,o,i;return Ft(this,function(a){switch(a.label){case 0:return e=function(u){if(u==null)return tt({},oi);var l=tt({},u);if(l.runtime="tfjs",l.maxHands==null&&(l.maxHands=oi.maxHands),l.modelType==null&&(l.modelType=oi.modelType),l.modelType!=="lite"&&l.modelType!=="full")throw new Error("Model type must be one of lite or full, but got "+l.modelType);return l.detectorModelUrl==null&&(l.modelType==="lite"?l.detectorModelUrl="https://tfhub.dev/mediapipe/tfjs-model/handpose_3d/detector/lite/1":l.detectorModelUrl="https://tfhub.dev/mediapipe/tfjs-model/handpose_3d/detector/full/1"),l.landmarkModelUrl==null&&(l.modelType==="lite"?l.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/handpose_3d/landmark/lite/1":l.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/handpose_3d/landmark/full/1"),l}(n),t=e.detectorModelUrl.indexOf("https://tfhub.dev")>-1,r=e.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([Ol(e.detectorModelUrl,{fromTFHub:t}),Ol(e.landmarkModelUrl,{fromTFHub:r})])];case 1:return s=a.sent(),o=s[0],i=s[1],[2,new GO(o,i,e.maxHands)]}})})}function jO(n,e){return Ot(this,void 0,void 0,function(){var t,r;return Ft(this,function(s){if(n===oo.MediaPipeHands){if(r=void 0,(t=e)!=null){if(t.runtime==="tfjs")return[2,HO(t)];if(t.runtime==="mediapipe")return[2,vO(t)];r=t.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' or 'mediapipe', but got "+r)}throw new Error(n+" is not a supported model name.")})})}(function(n){n.MediaPipeHands="MediaPipeHands"})(oo||(oo={}));let Wl=[];const qO="index_finger middle_finger ring_finger pinky".split(" "),KO=qO.map(n=>`${n}_tip`);async function XO(){const n={runtime:"mediapipe",modelType:"lite",solutionPath:"https://cdn.jsdelivr.net/npm/@mediapipe/hands/"};return await jO(oo.MediaPipeHands,n)}const YO=(n,e,t)=>{let r={};for(const s of KO){const o=t.find(a=>a.name==s),i=Wl.find(a=>a.name==s);if(o&&i){const a={x:(o.x-i.x)/n,y:(o.y-i.y)/e};r[s]={delta:a,point:o}}}return Wl=t,r},Ul=async(n,e,t)=>{const r=n.createShaderModule({code:e}),s=await r.getCompilationInfo();if(s.messages.length>0){for(let o of s.messages)console.warn(`${o.message} 
  at ${t} line ${o.lineNum}`);throw new Error(`Could not compile ${t}`)}return r},QO=`@group(0) @binding(0) var samp : sampler;
@group(0) @binding(1) var tex : texture_2d<f32>;

struct VertexOutput {
  @builtin(position) Position : vec4f,
    @location(0) fragUV : vec2f,
}

@vertex
fn vert(@builtin(vertex_index) VertexIndex : u32) -> VertexOutput {

  const pos = array(
    vec2( 1.0,  1.0),
    vec2( 1.0, -1.0),
    vec2(-1.0, -1.0),
    vec2( 1.0,  1.0),
    vec2(-1.0, -1.0),
    vec2(-1.0,  1.0),
  );

  const uv = array(
    vec2(1.0, 0.0),
    vec2(1.0, 1.0),
    vec2(0.0, 1.0),
    vec2(1.0, 0.0),
    vec2(0.0, 1.0),
    vec2(0.0, 0.0),
  );

  var output : VertexOutput;
  output.Position = vec4(pos[VertexIndex], 0.0, 1.0);
  output.fragUV = uv[VertexIndex];
  return output;
}

@fragment
fn frag(@location(0) fragUV : vec2f) -> @location(0) vec4f {
  var color = textureSample(tex, samp, fragUV);
  return color;
}`,Gl=`// // https://www.pcg-random.org/
fn random(n: u32) -> f32 {
    var h = n * 747796405u + 2891336453u;
    h = ((h >> ((h >> 28u) + 4u)) ^ h) * 277803737u;
    h = (h >> 22u) ^ h;
    return f32(h) / f32(0xffffffff);
}

fn normalRandom(n: u32) -> f32 {
  // box muller algorithm
  let u1 = random(n);
  let u2 = random(n + 1);
  let rSquared = -2.0 * log(u1);
  let theta = 2.0 * 3.141592654 * u2;
  return sqrt(rSquared) * cos(theta);
}

fn rndCircle(s: u32, r: f32) -> vec2f {
  return vec2(r * normalRandom(s), r * normalRandom(s + 1));
}

// fn lerp(start: vec3f, end: vec3f, i: f32) -> vec3f {
//   let delta = end - start;
//   let step = delta * i;
//   return start + step;
// }

// fn hsvToRgb(c: vec3f) -> vec3f {
//   let K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
//   let p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
//   return c.z * mix(K.xxx, clamp(p - K.xxx, vec3f(), vec3f(1.0)), c.y);
// }

fn index(coords : vec2i) -> i32 {
  return coords.x + coords.y * i32(params.dimensions.x);
}

fn in_range(coords_1d: i32) -> bool {
  return coords_1d > 0 && coords_1d < i32(params.dimensions.x * params.dimensions.y);
}

// fn agent_behavior(kind: u32, agent_pixel: u32, bit: u32) -> bool {
//   if kind == 1 {
//     return (agent_pixel & bit) > 0u;
//   }
//   if kind == 2 {
//     return agent_pixel == bit;
//   }
//   if kind == 3 {
//     return agent_pixel > 0u;
//   }
//   return false;
// }

struct Params {
  dimensions: vec2f,
  frame: f32,
}

@group(0) @binding(0)
  var<uniform> params : Params;

@group(0) @binding(1)
  var<storage, read_write> colorBuffer : array<vec4f>;

struct Agent {
  pos: vec2f,
  velocity: vec2f,
  color: vec4f,
}

@group(0) @binding(2)
  var<storage, read_write> agents : array<Agent>;

@group(0) @binding(3)
  var<storage, read_write> agentPixels : array<u32>;

@compute @workgroup_size(32)
fn compute(@builtin(global_invocation_id) id: vec3u) {
  let seed = u32(params.frame) + id.x * 780;
  var agent = agents[id.x];
  let maxDistance = length(vec2f(params.dimensions.x, params.dimensions.y)) * 2;
  let agentBit = 1u << u32(id.x);

  if agent.pos.x < 0.0 || agent.pos.y < 0.0 {
    return;
  }
  
  let ix0 = index(vec2i(agent.pos));
  agentPixels[ix0] |= agentBit;
  colorBuffer[ix0] = vec4(1.0);

  for (var i = 0.0; i < 50.0; i += 1.0) {
    let rndSeed = random(id.x + 1) - 0.5;
    let speed = (5.0 * rndSeed + 50.0);
    let angle = (((sign(rndSeed) * (params.frame * speed + i) / 360.0) % 1.0) - 0.5) * 3.1415928 * 2;
    let step = vec2f(cos(angle), sin(angle));

    var coord = vec2(0.0);
    var ix = index(vec2i(agent.pos));
    var pixel = colorBuffer[ix];
    var agentPixel = agentPixels[ix];
    var agentCapabilities = agentPixels[ix];
    
    // while agent_behavior(u32(agent.kind), agentPixel, agentBit) && in_range(ix) && length(coord) < diagonal {
    while (agentPixel == agentCapabilities) && in_range(ix) && length(coord) < maxDistance {
      coord += step;
      ix = index(vec2i(agent.pos + coord));
      pixel = colorBuffer[ix];
      agentPixel = agentPixels[ix];
    }
    if in_range(ix) {
      colorBuffer[ix] = clamp(vec4(0.0), vec4(1.0), colorBuffer[ix] + agent.color);
      agentPixels[ix] |= agentBit;
    }
  }

  // update position
  agent.pos = (agent.pos + agent.velocity + params.dimensions) % params.dimensions;
  agent.velocity = normalize(agent.velocity + rndCircle(seed, 0.05)) * 0.3;
  agents[id.x] = agent;
}

@group(0) @binding(4) var outTex : texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(16, 16) 
fn copy(@builtin(global_invocation_id) id: vec3u) {
  var color = colorBuffer[index(vec2i(id.xy))];
  textureStore(outTex, id.xy, color);
}

@compute @workgroup_size(16, 16) 
fn fade(@builtin(global_invocation_id) id: vec3u) {
  let ix = index(vec2i(id.xy));
  let color = colorBuffer[ix];
  if color.w > 0.0 {
    colorBuffer[ix] = color * 0.996;
  }
}
`;async function ZO(n,e,t){const r=ge=>{const ce=n*e,Ae=4,Ze=new Float32Array(ce*Ae),Jt=ge.createBuffer({size:Ze.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC,mappedAtCreation:!0});return new Float32Array(Jt.getMappedRange()).set(Ze),Jt.unmap(),Jt},s=ge=>{const ce=n*e,Ae=new Uint32Array(ce),Ze=ge.createBuffer({size:Ae.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC,mappedAtCreation:!0});return new Float32Array(Ze.getMappedRange()).set(Ae),Ze.unmap(),Ze},o=new Float32Array([n,e,3,0]),i=ge=>{const ce=ge.createBuffer({size:o.byteLength,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});return new Float32Array(ce.getMappedRange()).set(o),ce.unmap(),ce},a=new Float32Array(Array.from(new Array(32*8)).map(ge=>-1));let u=0;const l=ge=>{const ce=ge.createBuffer({size:a.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});return new Float32Array(ce.getMappedRange()).set(a),ce.unmap(),ce},h=await navigator.gpu.requestAdapter(),c=h.features.has("bgra8unorm-storage"),d=await h.requestDevice({requiredFeatures:c?["bgra8unorm-storage"]:[]}),f=c?navigator.gpu.getPreferredCanvasFormat():"rgba8unorm";let m=Gl;f==="bgra8unorm"&&(m=Gl.replace("var outTex : texture_storage_2d<rgba8unorm, write>;","var outTex : texture_storage_2d<bgra8unorm, write>;")),t.configure({device:d,format:f,alphaMode:"premultiplied"});const x=r(d),b=i(d),v=l(d),k=s(d),$=d.createTexture({size:{width:n,height:e},format:f,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT}),N=GPUShaderStage.COMPUTE,R=d.createBindGroupLayout({label:"agentsLayout",entries:[{visibility:N,binding:0,buffer:{type:"uniform"}},{visibility:N,binding:1,buffer:{type:"storage"}},{visibility:N,binding:2,buffer:{type:"storage"}},{visibility:N,binding:3,buffer:{type:"storage"}}]}),O=await Ul(d,m,"agents.wgsl"),F=d.createComputePipeline({label:"AgentsPipeline",layout:d.createPipelineLayout({bindGroupLayouts:[R]}),compute:{module:O,entryPoint:"compute"}}),B=await d.createBindGroup({layout:F.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:b,size:b.size,offset:0}},{binding:1,resource:{buffer:x,size:x.size,offset:0}},{binding:2,resource:{buffer:v,size:v.size,offset:0}},{binding:3,resource:{buffer:k,size:k.size,offset:0}}]}),L=d.createBindGroupLayout({label:"copyLayout",entries:[{visibility:N,binding:0,buffer:{type:"uniform"}},{visibility:N,binding:1,buffer:{type:"storage"}},{visibility:N,binding:4,storageTexture:{format:f}}]}),W=d.createComputePipeline({layout:d.createPipelineLayout({bindGroupLayouts:[L]}),compute:{module:O,entryPoint:"copy"}}),V=await d.createBindGroup({layout:W.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:b,size:b.size,offset:0}},{binding:1,resource:{buffer:x,size:x.size,offset:0}},{binding:4,resource:$.createView()}]}),ee=d.createBindGroupLayout({label:"fadeLayout",entries:[{visibility:N,binding:0,buffer:{type:"uniform"}},{visibility:N,binding:1,buffer:{type:"storage"}}]}),J=d.createComputePipeline({label:"FadePipeline",layout:d.createPipelineLayout({bindGroupLayouts:[ee]}),compute:{module:O,entryPoint:"fade"}}),ne=await d.createBindGroup({layout:J.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:b,size:b.size,offset:0}},{binding:1,resource:{buffer:x,size:x.size,offset:0}}]});try{let ge=await d.popErrorScope();if(ge)throw new Error(`Could not create bind group: ${ge.message}`)}catch(ge){console.warn(ge)}const re=await Ul(d,QO,"quad.wgsl"),he=d.createRenderPipeline({layout:"auto",vertex:{module:re,entryPoint:"vert"},fragment:{module:re,entryPoint:"frag",targets:[{format:f}]},primitive:{topology:"triangle-list"}}),Le=d.createBindGroup({layout:he.getBindGroupLayout(0),entries:[{binding:0,resource:d.createSampler({magFilter:"nearest",minFilter:"nearest"})},{binding:1,resource:$.createView()}]});return{addAgent(ge,ce){if(u>=32*8)return!1;const Ae=1,Ze=[Math.floor(ge),Math.floor(ce),(Math.random()-.5)**2,(Math.random()-.5)**2,Ae*(0+.3*Math.random()),Ae*(0+.2*Math.random()),Ae*(.1+.3*Math.random()),Ae];return a.set(Ze,u),d.queue.writeBuffer(v,0,a),u+=Ze.length,!0},run(){const ge=d.createCommandEncoder();let ce=ge.beginComputePass();ce.setPipeline(J),ce.setBindGroup(0,ne),ce.dispatchWorkgroups(Math.ceil(n/16),Math.ceil(e/16),1),ce.end(),ce=ge.beginComputePass(),ce.setPipeline(F),ce.setBindGroup(0,B),ce.dispatchWorkgroups(a.length/8,1,1),ce.end(),ce=ge.beginComputePass(),ce.setPipeline(W),ce.setBindGroup(0,V),ce.dispatchWorkgroups(Math.ceil(n/16),Math.ceil(e/16),1),ce.end();const Ae=ge.beginRenderPass({colorAttachments:[{view:t.getCurrentTexture().createView(),clearValue:{r:0,g:1,b:0,a:1},loadOp:"clear",storeOp:"store"}]});Ae.setPipeline(he),Ae.setBindGroup(0,Le),Ae.draw(6,1,0,0),Ae.end(),d.queue.submit([ge.finish()]),o[2]++,d.queue.writeBuffer(b,0,o)}}}Yg("webgpu");const Rt={width:640,height:360,frame:0},as={video:{width:{exact:Rt.width},height:{exact:Rt.height}}};function JO(n){const e=document.createElement("canvas");e.width=as.video.width.exact,e.height=as.video.height.exact,e.style.position="absolute",e.style.left="-320px",e.style.top="-160px",n.appendChild(e);const t=e.getContext("2d");return t.translate(e.width,0),t.scale(-1,1),t}function eF(n){const e=document.createElement("canvas");return e.width=as.video.width.exact,e.height=as.video.height.exact,e.style.position="absolute",e.style.left="-320px",e.style.top="-160px",n.appendChild(e),e.getContext("webgpu")}(async function(){try{const n=await navigator.mediaDevices.getUserMedia(as),e=document.querySelector("video");e.srcObject=n,e.style.display="none";const t=document.querySelector("main"),r=JO(t),s=eF(t),o=await XO(),i=await ZO(Rt.width,Rt.height,s);let a=!0;async function u(){const l=a&&await o.estimateHands(e);if(r.drawImage(e,0,0,Rt.width,Rt.height,0,0,Rt.width,Rt.height),l){let h=l[0]||{keypoints:[]},c=YO(Rt.width,Rt.height,h.keypoints);for(let[d,f]of Object.entries(c)){const m=f.delta.x**2+f.delta.y**2,x=f.delta.y<0;m>.08**2&&x&&(i.addAgent(Rt.width-f.point.x,f.point.y)||(a=!1))}}i.run(),requestAnimationFrame(u)}u()}catch(n){console.log("Rejected!",n)}})();
